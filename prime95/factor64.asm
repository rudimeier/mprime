; Copyright 1995-2016 Mersenne Research, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; This routine implements fast trial factoring of Mersenne numbers
;
; This only runs on 64-bit CPUs.  For 32-bit CPUs see factor32.asm
;

; IDEAS:
; test where primearray loses effectiveness 

TITLE   factor64

INCLUDE	unravel.mac
INCLUDE	factor64.mac

; In 32-bit mode we are so starved for registers that we are forced to
; use the stack pointer to access the asm_data.  In 64-bit mode we
; use one of the extra 8 registers.  We can't use the rsp trick because
; that violates the Window's exception handling stack unwind mechanism.

AD_BASE		EQU	<r11>

;
; Define the offsets into the C / assembly communication structure
;

p			EQU	QWORD PTR [AD_BASE+0*8]		; Exponent of Mersenne number being trial factored
twop			EQU	QWORD PTR [AD_BASE+1*8]		; 2*p -- useful since we factors are 1 more than multiples of 2*p
facdists		EQU	QWORD PTR [AD_BASE+2*8]		; 64 distances between sieve factors
facdist64		EQU	QWORD PTR [AD_BASE+66*8]	
facdist12K		EQU	QWORD PTR [AD_BASE+67*8]	; Distance to first factor in next sieve
savefac1		EQU	QWORD PTR [AD_BASE+68*8]	; LSW of the first factor in the sieve
savefac0		EQU	QWORD PTR [AD_BASE+69*8]	; MSW of the first factor in the sieve
sieve			EQU	[AD_BASE+70*8]			; Area to sieve, or an already sieved area to TF
primearray		EQU	[AD_BASE+71*8]			; Array of primes and offsets
initsieve		EQU	[AD_BASE+72*8]			; Array used to initialize sieve
initlookup		EQU	[AD_BASE+73*8]			; Lookup table into initsieve

TWO_TO_FACSIZE_PLUS_62	EQU	QWORD PTR [AD_BASE+74*8]

FACPASS			EQU	DWORD PTR [AD_BASE+75*8+0*4]
FACHSW			EQU	DWORD PTR [AD_BASE+75*8+1*4]
FACMSW			EQU	DWORD PTR [AD_BASE+75*8+2*4]
FACLSW			EQU	DWORD PTR [AD_BASE+75*8+3*4]
CPU_FLAGS		EQU	DWORD PTR [AD_BASE+75*8+4*4]
SSE2_LOOP_COUNTER	EQU	DWORD PTR [AD_BASE+75*8+5*4]
initstart		EQU	DWORD PTR [AD_BASE+75*8+6*4]	; First dword in initsieve to copy

;;pad to next cache line to match facasm_data structure defined in commonb.c
YMM_INITVAL		EQU	DWORD PTR [AD_BASE+80*8]
XMM_INITVAL		EQU	DWORD PTR [AD_BASE+80*8]
XMM_INIT120BS		EQU	DWORD PTR [AD_BASE+84*8]
XMM_INITBS		EQU	DWORD PTR [AD_BASE+85*8]
XMM_BS			EQU	DWORD PTR [AD_BASE+86*8]
XMM_SHIFTER		EQU	DWORD PTR [AD_BASE+87*8]	; 32 quad word shifter values

;; SSE2 supports 128-bit operations on integers (four factors simultaneously)
;; Use the XMM registers and the memory area below
;; AVX2 supports 256-bit operations on integers (eight trial factors simultaneouly)
;; Use the YMM registers and the memory area below

XMM_INVFAC		EQU	DWORD PTR [AD_BASE+120*8]
XMM_INVFACa		EQU	DWORD PTR [AD_BASE+122*8]
XMM_I1			EQU	DWORD PTR [AD_BASE+124*8]
XMM_I1a			EQU	DWORD PTR [AD_BASE+126*8]
XMM_I2			EQU	DWORD PTR [AD_BASE+128*8]
XMM_I2a			EQU	DWORD PTR [AD_BASE+130*8]
XMM_F1			EQU	DWORD PTR [AD_BASE+132*8]
XMM_F1a			EQU	DWORD PTR [AD_BASE+134*8]
XMM_F2			EQU	DWORD PTR [AD_BASE+136*8]
XMM_F2a			EQU	DWORD PTR [AD_BASE+138*8]
XMM_F3			EQU	DWORD PTR [AD_BASE+140*8]
XMM_F3a			EQU	DWORD PTR [AD_BASE+142*8]
XMM_TWO_120_MODF1	EQU	DWORD PTR [AD_BASE+144*8]
XMM_TWO_120_MODF1a	EQU	DWORD PTR [AD_BASE+146*8]
XMM_TWO_120_MODF2	EQU	DWORD PTR [AD_BASE+148*8]
XMM_TWO_120_MODF2a	EQU	DWORD PTR [AD_BASE+150*8]
XMM_TWO_120_MODF3	EQU	DWORD PTR [AD_BASE+152*8]
XMM_TWO_120_MODF3a	EQU	DWORD PTR [AD_BASE+154*8]

YMM_INVFAC		EQU	DWORD PTR [AD_BASE+120*8]
YMM_INVFACa		EQU	DWORD PTR [AD_BASE+124*8]
YMM_I1			EQU	DWORD PTR [AD_BASE+128*8]
YMM_I1a			EQU	DWORD PTR [AD_BASE+132*8]
YMM_I2			EQU	DWORD PTR [AD_BASE+136*8]
YMM_I2a			EQU	DWORD PTR [AD_BASE+140*8]
YMM_F1			EQU	DWORD PTR [AD_BASE+144*8]
YMM_F1a			EQU	DWORD PTR [AD_BASE+148*8]
YMM_F2			EQU	DWORD PTR [AD_BASE+152*8]
YMM_F2a			EQU	DWORD PTR [AD_BASE+156*8]
YMM_F3			EQU	DWORD PTR [AD_BASE+160*8]
YMM_F3a			EQU	DWORD PTR [AD_BASE+164*8]
YMM_TWO_120_MODF1	EQU	DWORD PTR [AD_BASE+168*8]
YMM_TWO_120_MODF1a	EQU	DWORD PTR [AD_BASE+172*8]
YMM_TWO_120_MODF2	EQU	DWORD PTR [AD_BASE+176*8]
YMM_TWO_120_MODF2a	EQU	DWORD PTR [AD_BASE+180*8]
YMM_TWO_120_MODF3	EQU	DWORD PTR [AD_BASE+184*8]
YMM_TWO_120_MODF3a	EQU	DWORD PTR [AD_BASE+188*8]

;; Non-SSE2 and non-AVX2 queues can share the SSE2/AVX2 memory

fac1			EQU	QWORD PTR [AD_BASE+120*8]	; Queued factors to test
fac2			EQU	QWORD PTR [AD_BASE+121*8]
fac3			EQU	QWORD PTR [AD_BASE+122*8]
fac4			EQU	QWORD PTR [AD_BASE+123*8]
fac1hi			EQU	QWORD PTR [AD_BASE+124*8]	; High word of queued factors to test
fac2hi			EQU	QWORD PTR [AD_BASE+125*8]
fac3hi			EQU	QWORD PTR [AD_BASE+126*8]
fac4hi			EQU	QWORD PTR [AD_BASE+127*8]

;; Other variables (start after the AVX2 variables)

primearray12		EQU	[AD_BASE+192*8]			; Ptr into primearray
shifter			EQU	QWORD PTR [AD_BASE+193*8]
shift66			EQU	QWORD PTR [AD_BASE+194*8]	; Two shift counts used in 66-bit factoring
initval1		EQU	QWORD PTR [AD_BASE+195*8]	; Lower 64 bits of initial value for squarer
initval0		EQU	QWORD PTR [AD_BASE+196*8]	; Upper 64 bits of initial value for squarer
initshift		EQU	QWORD PTR [AD_BASE+197*8]	; Initial shift count to make first quotient
initshift2		EQU	QWORD PTR [AD_BASE+198*8]	; Initial shift count to make first quotient
initdiv0		EQU	QWORD PTR [AD_BASE+199*8]	; Value to compute 1 / factor
shift_count		EQU	QWORD PTR [AD_BASE+200*8]	; Shift count used in squaring loop
temp			EQU	QWORD PTR [AD_BASE+201*8]
memshifter		EQU	QWORD PTR [AD_BASE+202*8]	; tlp66 case doesn't have a free register to store shifter
SAVED_REG1		EQU	[AD_BASE+203*8]
SAVED_REG2		EQU	[AD_BASE+204*8]
SAVED_REG3		EQU	[AD_BASE+205*8]
SAVED_REG4		EQU	[AD_BASE+206*8]
SAVED_REG5		EQU	[AD_BASE+207*8]
SAVED_REG6		EQU	[AD_BASE+208*8]
facinv2_in_memory	EQU	QWORD PTR [AD_BASE+209*8]

;
; Global variables
;

_GWDATA SEGMENT PAGE
rems		DQ	1,7,17,23,31,41,47,49,71,73,79,89,97,103,113,119
smfacendpt	DQ	100000000000h					; Limit for brute force factoring code (2^44)
	align 16
XMM_LOWONE		DD	1,0,0,0
XMM_HIGHONE		DD	0,0,1,0
XMM_BITS28		DD	0FFFFFFFh,0,0FFFFFFFh,0
XMM_BITS30		DD	3FFFFFFFh,0,3FFFFFFFh,0
TWO_TO_30		DQ	1073741824.0				;; 2^30
	align 32
YMM_BITS28		DD	0FFFFFFFh,0,0FFFFFFFh,0,0FFFFFFFh,0,0FFFFFFFh,0
YMM_BITS30		DD	3FFFFFFFh,0,3FFFFFFFh,0,3FFFFFFFh,0,3FFFFFFFh,0
YMM_28TH_BIT		DD	08000000h,0,08000000h,0,08000000h,0,08000000h,0
YMM_ONE			DD	1,0,1,0,1,0,1,0

;
; Prime data
;

sivinfo	DB	1, 2, 1, 2, 1, 2, 3, 1, 3, 2, 1, 2, 3
	DB	3, 1, 3, 2, 1, 3, 2, 3, 4, 2, 1, 2, 1, 2, 7
	DB	2, 3, 1, 5, 1, 3, 3, 2, 3, 3, 1, 5, 1, 2, 1
	DB	6, 6, 2, 1, 2, 3, 1, 5, 3, 3, 3, 1, 3, 2, 1
	DB	5, 7, 2, 1, 2, 7, 3, 5, 1, 2, 3, 4, 3, 3, 2
	DB	3, 4, 2, 4, 5, 1, 5, 1, 3, 2, 3, 4, 2, 1, 2
	DB	6, 4, 2, 4, 2, 3, 6, 1, 9, 3, 5, 3, 3, 1, 3
	DB	5, 3, 3, 1, 3, 3, 2, 1, 6, 5, 1, 2, 3, 3, 1
	DB	6, 2, 3, 4, 5, 4, 5, 4, 3, 3, 2, 4, 3, 2, 4
	DB	2, 7, 5, 6, 1, 5, 1, 2, 1, 5, 7, 2, 1, 2, 7
	DB	2, 1, 2, 10, 2, 4, 5, 4, 2, 3, 3, 7, 2, 3, 3
	DB	4, 3, 6, 2, 3, 1, 5, 1, 3, 5, 1, 5, 1, 3, 9
	DB	2, 1, 2, 3, 3, 4, 3, 3, 11, 1, 5, 4, 5, 3, 3
	DB	4, 6, 2, 3, 3, 1, 3, 6, 5, 9, 1, 2, 3, 1, 3
	DB	2, 1, 2, 6, 1, 3, 17, 3, 3, 4, 9, 5, 7, 2, 1
	DB	2, 3, 4, 2, 1, 3, 6, 5, 1, 2, 1, 2, 3, 6, 6
	DB	4, 6, 3, 2, 3, 4, 2, 4, 2, 7, 2, 3, 1, 2, 3
	DB	1, 3, 5, 10, 3, 2, 1, 12, 2, 1, 5, 6, 1, 5, 4
	DB	3, 3, 3, 9, 3, 2, 1, 6, 5, 6, 4, 8, 7, 3, 2
	DB	1, 2, 1, 5, 6, 3, 3, 9, 1, 8, 1, 11, 3, 4, 3
	DB	2, 1, 2, 4, 3, 5, 1, 5, 7, 5, 3, 6, 1, 2, 1
	DB	5, 6, 1, 8, 1, 3, 2, 1, 5, 4, 9, 12, 2, 3, 4
	DB	8, 1, 2, 4, 8, 1, 2, 4, 3, 3, 2, 6, 1, 11, 3
	DB	1, 3, 2, 3, 7, 3, 2, 1, 3, 2, 3, 6, 3, 3, 7
	DB	2, 3, 6, 4, 3, 2, 13, 9, 5, 4, 2, 3, 1, 3, 11
	DB	6, 1, 8, 4, 2, 6, 7, 5, 1, 2, 4, 3, 3, 2, 1
	DB	2, 3, 4, 2, 1, 3, 5, 1, 5, 4, 2, 7, 5, 6, 1
	DB	3, 2, 1, 8, 7, 2, 3, 4, 3, 2, 9, 4, 5, 3, 3
	DB	4, 5, 6, 7, 2, 3, 3, 1, 14, 1, 5, 4, 2, 7, 2
	DB	4, 6, 3, 6, 2, 3, 10, 5, 1, 8, 13, 2, 1, 6, 3
	DB	2, 6, 3, 4, 2, 4, 11, 1, 2, 1, 6, 14, 1, 3, 3
	DB	3, 2, 3, 1, 6, 2, 6, 1, 5, 1, 8, 1, 8, 3, 10
	DB	8, 4, 2, 1, 2, 1, 11, 4, 6, 3, 5, 1, 2, 3, 1
	DB	3, 5, 1, 6, 5, 1, 5, 7, 3, 2, 3, 4, 3, 3, 8
	DB	6, 1, 2, 7, 3, 2, 4, 5, 4, 3, 3, 11, 3, 1, 5
	DB	7, 2, 3, 9, 1, 5, 7, 2, 1, 5, 7, 2, 4, 9, 2
	DB	3, 1, 2, 3, 1, 6, 2, 10, 11, 6, 1, 2, 3, 3, 1
	DB	3, 11, 1, 3, 8, 3, 6, 1, 3, 6, 8, 1, 2, 3, 7
	DB	2, 1, 9, 12, 5, 3, 1, 5, 1, 5, 1, 5, 3, 1, 5
	DB	1, 5, 3, 4, 15, 5, 1, 5, 4, 3, 5, 9, 3, 6, 6
	DB	1, 9, 3, 2, 3, 3, 9, 1, 5, 7, 3, 2, 1, 2, 12
	DB	1, 6, 3, 8, 4, 3, 3, 9, 8, 1, 2, 3, 1, 3, 3
	DB	5, 3, 6, 6, 9, 1, 3, 2, 9, 4, 12, 2, 1, 2, 3
	DB	1, 6, 2, 7, 15, 5, 3, 6, 7, 3, 5, 6, 1, 2, 3
	DB	4, 3, 5, 1, 2, 7, 3, 3, 2, 3, 1, 5, 1, 8, 6
	DB	4, 9, 2, 3, 6, 1, 3, 3, 3, 14, 3, 7, 2, 4, 5
	DB	4, 6, 9, 2, 1, 2, 12, 6, 3, 1, 8, 3, 3, 7, 5
	DB	7, 2, 15, 3, 3, 3, 4, 3, 2, 1, 6, 3, 2, 1, 3
	DB	11, 3, 1, 2, 9, 1, 2, 6, 1, 3, 2, 13, 3, 3, 2
	DB	4, 5, 16, 8, 1, 3, 2, 1, 2, 1, 5, 7, 3, 2, 4
	DB	5, 3, 10, 2, 1, 3, 15, 2, 4, 5, 3, 3, 4, 3, 6
	DB	2, 3, 1, 3, 2, 3, 1, 5, 1, 8, 3, 10, 2, 6, 7
	DB	14, 3, 10, 2, 9, 4, 3, 2, 3, 7, 3, 3, 5, 1, 5
	DB	6, 4, 5, 1, 5, 4, 6, 5, 12, 1, 2, 4, 3, 2, 4
	DB	9, 5, 3, 3, 1, 3, 5, 6, 1, 5, 3, 3, 3, 4, 3
	DB	5, 3, 1, 3, 3, 3, 5, 4, 12, 3, 11, 1, 9, 2, 4
	DB	5, 15, 4, 9, 2, 1, 5, 3, 1, 3, 2, 9, 4, 6, 9
	DB	8, 3, 1, 6, 3, 5, 1, 5, 1, 3, 5, 7, 2, 12, 1
	DB	8, 1, 5, 1, 5, 10, 2, 1, 2, 4, 8, 3, 3, 1, 6
	DB	8, 4, 2, 3, 15, 1, 5, 1, 3, 2, 3, 3, 4, 3, 2
	DB	6, 3, 4, 6, 2, 7, 6, 5, 12, 3, 6, 3, 1, 11, 4
	DB	9, 5, 3, 7, 2, 1, 3, 5, 4, 3, 2, 3, 15, 7, 5
	DB	1, 6, 5, 1, 8, 1, 9, 12, 9, 3, 8, 9, 3, 1, 9
	DB	2, 3, 1, 5, 4, 5, 3, 3, 4, 2, 3, 1, 5, 1, 6
	DB	2, 3, 3, 1, 6, 2, 7, 9, 2, 3, 10, 2, 4, 3, 2
	DB	4, 2, 7, 3, 2, 7, 6, 2, 1, 15, 2, 12, 3, 3, 6
	DB	6, 7, 3, 2, 1, 2, 9, 3, 6, 4, 3, 2, 6, 1, 6
	DB	15, 8, 1, 3, 11, 7, 3, 5, 6, 3, 1, 2, 4, 5, 3
	DB	3, 12, 7, 3, 2, 4, 6, 9, 5, 1, 5, 1, 2, 3, 10
	DB	3, 2, 7, 2, 1, 2, 7, 3, 6, 12, 5, 3, 4, 5, 1
	DB	15, 2, 3, 1, 6, 2, 7, 3, 17, 6, 4, 3, 5, 1, 2
	DB	10, 5, 4, 8, 1, 5, 7, 2, 1, 6, 3, 8, 3, 4, 2
	DB	4, 2, 3, 4, 3, 3, 6, 3, 2, 3, 3, 4, 9, 2, 10
	DB	2, 6, 1, 5, 3, 1, 5, 6, 1, 2, 10, 3, 15, 3, 2
	DB	4, 5, 6, 3, 1, 14, 1, 3, 2, 1, 8, 6, 1, 3, 5
	DB	4, 12, 6, 3, 9, 3, 2, 7, 3, 2, 6, 4, 3, 6, 2
	DB	3, 6, 3, 6, 1, 8, 10, 2, 1, 5, 9, 4, 2, 7, 2
	DB	1, 3, 11, 3, 7, 3, 3, 5, 3, 1, 5, 1, 2, 1, 11
	DB	1, 2, 3, 3, 6, 3, 7, 5, 6, 3, 4, 2, 18, 7, 6
	DB	3, 2, 3, 1, 6, 3, 6, 8, 1, 5, 4, 11, 1, 6, 3
	DB	2, 3, 9, 1, 6, 3, 2, 6, 4, 3, 6, 2, 3, 6, 3
	DB	1, 6, 6, 2, 7, 3, 8, 3, 1, 5, 4, 9, 3, 17, 1
	DB	14, 1, 11, 3, 1, 5, 6, 1, 3, 2, 4, 11, 3, 1, 5
	DB	4, 2, 3, 4, 2, 6, 9, 6, 10, 2, 3, 3, 4, 2, 1
	DB	8, 6, 1, 5, 4, 5, 1, 2, 3, 7, 6, 11, 4, 14, 1
	DB	2, 10, 2, 1, 2, 7, 5, 6, 1, 6, 8, 1, 14, 4, 11
	DB	4, 2, 3, 3, 7, 2, 4, 6, 3, 3, 2, 10, 2, 9, 1
	DB	6, 3, 2, 3, 7, 9, 5, 4, 5, 16, 3, 5, 3, 3, 1
	DB	3, 8, 3, 1, 6, 3, 14, 1, 5, 4, 8, 3, 4, 3, 5
	DB	12, 10, 5, 1, 5, 1, 6, 2, 3, 10, 2, 1, 6, 9, 5
	DB	1, 5, 1, 2, 10, 8, 13, 2, 4, 3, 2, 6, 3, 4, 6
	DB	6, 3, 2, 4, 11, 1, 8, 7, 5, 3, 6, 6, 7, 3, 2
	DB	10, 2, 6, 3, 1, 3, 3, 8, 4, 11, 1, 14, 4, 3, 2
	DB	10, 2, 6, 12, 10, 2, 4, 5, 1, 8, 1, 6, 6, 17, 1
	DB	2, 3, 6, 3, 3, 4, 3, 2, 1, 3, 12, 2, 10, 5, 3
	DB	3, 7, 2, 3, 3, 1, 6, 3, 5, 1, 5, 3, 10, 2, 13
	DB	2, 1, 3, 11, 1, 12, 2, 3, 1, 2, 3, 12, 3, 4, 2
	DB	1, 17, 3, 4, 8, 6, 1, 5, 1, 5, 3, 4, 2, 4, 6
	DB	11, 3, 7, 2, 13, 2, 1, 6, 5, 4, 2, 4, 6, 2, 7
	DB	3, 8, 3, 4, 2, 3, 3, 4, 3, 5, 6, 1, 3, 3, 8
	DB	4, 3, 3, 6, 5, 1, 3, 9, 2, 3, 3, 3, 6, 9, 4
	DB	3, 5, 4, 9, 2, 7, 3, 9, 5, 4, 5, 6, 1, 3, 6
	DB	6, 18, 2, 3, 4, 2, 3, 1, 2, 9, 6, 3, 4, 3, 3
	DB	2, 9, 1, 2, 1, 12, 2, 3, 3, 7, 15, 3, 2, 3, 6
	DB	3, 10, 2, 4, 2, 4, 3, 3, 2, 15, 1, 5, 6, 4, 5
	DB	4, 12, 3, 6, 2, 7, 2, 3, 1, 14, 7, 8, 1, 6, 3
	DB	2, 10, 5, 3, 3, 3, 4, 5, 6, 7, 5, 7, 8, 7, 5
	DB	7, 3, 8, 3, 4, 3, 8, 10, 5, 1, 3, 2, 1, 2, 6
	DB	1, 5, 1, 3, 11, 3, 1, 2, 9, 4, 5, 4, 11, 1, 5
	DB	9, 7, 2, 1, 2, 9, 1, 2, 3, 4, 5, 1, 15, 2, 15
	DB	1, 5, 1, 9, 2, 9, 3, 7, 5, 1, 2, 10, 18, 3, 2
	DB	3, 7, 2, 10, 5, 7, 11, 3, 1, 15, 6, 5, 9, 1, 2
	DB	7, 3, 11, 9, 1, 6, 3, 2, 4, 2, 4, 3, 5, 1, 6
	DB	9, 5, 7, 8, 7, 2, 3, 3, 1, 3, 2, 1, 14, 1, 14
	DB	3, 1, 2, 3, 7, 2, 6, 7, 8, 7, 2, 3, 4, 3, 2
	DB	3, 3, 3, 4, 2, 4, 2, 7, 8, 4, 3, 2, 6, 4, 8
	DB	1, 5, 4, 2, 3, 13, 3, 5, 4, 2, 3, 6, 7, 15, 2
	DB	7, 11, 4, 6, 2, 3, 4, 5, 3, 7, 5, 3, 1, 5, 6
	DB	6, 7, 3, 3, 9, 5, 3, 4, 9, 2, 3, 1, 3, 5, 1
	DB	5, 4, 3, 3, 5, 1, 9, 5, 1, 6, 2, 3, 4, 5, 6
	DB	7, 6, 2, 4, 5, 3, 3, 10, 2, 7, 8, 7, 5, 4, 5
	DB	6, 1, 9, 3, 6, 5, 6, 1, 2, 1, 6, 3, 2, 4, 2
	DB	22, 2, 1, 2, 1, 5, 6, 3, 3, 7, 2, 3, 3, 3, 4
	DB	3, 18, 9, 2, 3, 1, 6, 3, 3, 3, 2, 7, 11, 6, 1
	DB	9, 5, 3, 13, 12, 2, 1, 2, 1, 2, 7, 2, 3, 3, 4
	DB	8, 6, 1, 21, 2, 1, 2, 12, 3, 3, 1, 9, 2, 7, 3
	DB	14, 9, 7, 3, 5, 6, 1, 3, 6, 15, 3, 2, 3, 3, 7
	DB	2, 1, 12, 2, 3, 3, 13, 5, 9, 3, 4, 3, 3, 15, 2
	DB	6, 6, 1, 8, 1, 3, 2, 6, 9, 1, 3, 2, 13, 6, 3
	DB	6, 2, 12, 12, 6, 3, 1, 6, 14, 4, 2, 3, 6, 1, 9
	DB	3, 2, 3, 3, 10, 8, 1, 3, 3, 9, 5, 3, 1, 2, 4
	DB	3, 3, 12, 8, 3, 4, 5, 3, 7, 11, 4, 8, 3, 1, 6
	DB	2, 1, 11, 4, 9, 17, 1, 3, 9, 2, 3, 3, 4, 5, 4
	DB	9, 3, 2, 1, 2, 4, 8, 1, 6, 6, 3, 9, 2, 3, 3
	DB	3, 1, 3, 6, 5, 10, 6, 9, 2, 3, 1, 8, 1, 5, 7
	DB	2, 15, 1, 5, 6, 1, 12, 3, 8, 4, 5, 1, 6, 11, 3
	DB	1, 8, 10, 5, 1, 6, 6, 9, 5, 6, 3, 1, 5, 1, 3
	DB	5, 9, 1, 6, 3, 2, 3, 1, 12, 14, 1, 2, 1, 5, 1
	DB	8, 6, 4, 11, 1, 3, 2, 1, 5, 3, 10, 6, 5, 4, 6
	DB	3, 3, 3, 2, 9, 1, 2, 6, 9, 1, 6, 3, 2, 1, 8
	DB	6, 6, 7, 2, 4, 9, 2, 6, 7, 3, 3, 2, 4, 3, 2
	DB	10, 6, 5, 7, 2, 1, 8, 1, 6, 15, 2, 3, 12, 10, 12
	DB	5, 4, 6, 5, 6, 3, 6, 6, 3, 4, 8, 7, 3, 2, 3
	DB	18, 10, 5, 15, 6, 1, 2, 1, 14, 6, 7, 3, 11, 4, 2
	DB	9, 3, 7, 9, 2, 3, 1, 3, 17, 9, 1, 8, 3, 9, 1
	DB	12, 2, 1, 3, 6, 3, 6, 5, 4, 3, 8, 6, 4, 5, 7
	DB	20, 3, 1, 3, 2, 6, 7, 2, 1, 2, 1, 2, 4, 3, 5
	DB	3, 3, 1, 3, 3, 3, 6, 3, 12, 5, 1, 5, 3, 6, 3
	DB	3, 7, 3, 3, 26, 10, 3, 5, 1, 5, 4, 5, 6, 6, 1
	DB	3, 2, 7, 8, 4, 6, 3, 11, 1, 5, 4, 3, 11, 1, 11
	DB	3, 4, 5, 6, 6, 1, 5, 3, 6, 1, 2, 7, 5, 1, 3
	DB	9, 2, 6, 4, 9, 6, 3, 3, 2, 3, 3, 7, 2, 1, 6
	DB	6, 2, 3, 9, 9, 6, 1, 8, 6, 4, 9, 5, 13, 2, 3
	DB	4, 3, 3, 2, 1, 5, 10, 2, 3, 4, 2, 10, 5, 1, 17
	DB	1, 2, 12, 1, 6, 6, 5, 3, 1, 6, 15, 3, 6, 8, 6
	DB	1, 11, 9, 6, 7, 5, 1, 6, 6, 2, 1, 2, 3, 6, 1
	DB	8, 9, 1, 20, 4, 8, 3, 4, 5, 1, 2, 9, 4, 5, 4
	DB	6, 2, 9, 1, 9, 5, 1, 2, 1, 2, 4, 14, 1, 3, 11
	DB	6, 3, 7, 9, 2, 3, 4, 3, 3, 5, 4, 2, 1, 9, 5
	DB	3, 10, 11, 4, 3, 15, 2, 1, 2, 9, 3, 15, 1, 2, 4
	DB	3, 2, 3, 6, 7, 17, 7, 3, 2, 1, 3, 2, 7, 2, 1
	DB	3, 14, 1, 2, 3, 4, 5, 1, 5, 1, 5, 1, 2, 15, 1
	DB	6, 6, 5, 9, 6, 7, 5, 1, 6, 3, 5, 3, 7, 6, 2
	DB	7, 2, 9, 1, 5, 4, 2, 4, 5, 6, 9, 9, 4, 3, 9
	DB	8, 7, 3, 3, 5, 7, 2, 3, 1, 6, 6, 2, 3, 3, 6
	DB	1, 8, 1, 6, 3, 2, 7, 3, 2, 1, 6, 9, 2, 18, 9
	DB	6, 6, 1, 2, 1, 2, 4, 6, 2, 18, 3, 9, 1, 6, 5
	DB	3, 6, 12, 4, 3, 3, 8, 6, 1, 9, 5, 10, 5, 1, 3
	DB	9, 2, 1, 20, 3, 1, 8, 1, 2, 4, 9, 5, 6, 3, 1
	DB	5, 4, 2, 3, 6, 1, 5, 9, 4, 3, 2, 10, 2, 3, 18
	DB	3, 1, 5, 3, 12, 3, 7, 8, 3, 9, 1, 5, 10, 5, 4
	DB	3, 2, 3, 1, 5, 1, 6, 2, 1, 2, 4, 5, 3, 6, 9
	DB	7, 6, 8, 4, 3, 8, 4, 2, 1, 3, 9, 12, 9, 5, 6
	DB	1, 2, 7, 5, 3, 3, 3, 9, 6, 1, 14, 9, 7, 8, 6
	DB	7, 12, 6, 11, 3, 1, 5, 4, 2, 1, 2, 7, 6, 3, 2
	DB	3, 7, 2, 1, 2, 15, 3, 1, 3, 5, 1, 15, 11, 1, 2
	DB	3, 4, 3, 3, 8, 6, 6, 3, 4, 2, 1, 12, 6, 2, 3
	DB	4, 3, 3, 5, 1, 3, 6, 14, 7, 3, 2, 6, 4, 3, 6
	DB	2, 3, 7, 3, 6, 5, 3, 3, 4, 3, 3, 2, 1, 2, 4
	DB	6, 2, 7, 9, 5, 1, 8, 3, 10, 3, 5, 4, 2, 15, 18
	DB	6, 4, 11, 6, 1, 3, 6, 8, 3, 3, 1, 9, 2, 13, 2
	DB	4, 9, 5, 4, 5, 3, 7, 2, 10, 11, 9, 6, 4, 14, 6
	DB	3, 3, 4, 3, 6, 12, 8, 7, 2, 7, 6, 3, 5, 6, 10
	DB	3, 2, 4, 9, 6, 9, 5, 1, 2, 10, 5, 7, 2, 3, 1
	DB	5, 12, 9, 1, 2, 10, 8, 7, 5, 7, 3, 2, 3, 10, 3
	DB	5, 3, 1, 6, 3, 15, 5, 4, 3, 2, 3, 4, 20, 1, 2
	DB	1, 6, 9, 2, 3, 4, 5, 3, 9, 9, 1, 6, 8, 4, 3
	DB	2, 3, 3, 1, 26, 7, 2, 10, 8, 1, 2, 3, 6, 1, 3
	DB	6, 6, 3, 2, 7, 5, 3, 3, 7, 5, 7, 8, 4, 3, 6
	DB	2, 4, 11, 3, 1, 9, 11, 3, 1, 9, 3, 8, 7, 5, 3
	DB	6, 1, 3, 2, 4, 9, 6, 8, 1, 2, 7, 2, 4, 6, 6
	DB	15, 8, 4, 2, 1, 3, 11, 6, 4, 5, 3, 3, 3, 7, 3
	DB	9, 5, 6, 1, 5, 1, 2, 13, 2, 6, 4, 2, 9, 4, 5
	DB	7, 8, 3, 3, 4, 5, 3, 4, 3, 6, 5, 10, 5, 4, 2
	DB	6, 13, 9, 2, 6, 9, 3, 15, 3, 4, 3, 11, 6, 1, 2
	DB	3, 3, 1, 5, 1, 2, 3, 3, 1, 3, 11, 9, 3, 9, 6
	DB	4, 6, 3, 5, 6, 1, 8, 1, 5, 1, 5, 9, 3, 10, 2
	DB	1, 3, 11, 3, 3, 9, 3, 7, 6, 8, 1, 3, 3, 2, 7
	DB	6, 2, 1, 9, 8, 18, 6, 3, 7, 14, 1, 6, 3, 6, 3
	DB	2, 1, 8, 15, 4, 12, 3, 15, 5, 1, 9, 2, 3, 6, 4
	DB	11, 1, 3, 11, 9, 1, 5, 1, 5, 15, 1, 14, 3, 7, 8
	DB	3, 10, 8, 1, 3, 2, 16, 2, 1, 2, 3, 1, 6, 2, 3
	DB	3, 6, 1, 3, 2, 3, 4, 3, 2, 10, 2, 16, 5, 4, 8
	DB	1, 11, 1, 2, 3, 4, 3, 8, 7, 2, 9, 4, 2, 10, 3
	DB	6, 6, 3, 5, 1, 5, 1, 6, 14, 6, 9, 1, 9, 5, 4
	DB	5, 24, 1, 2, 3, 4, 5, 1, 5, 15, 1, 18, 3, 5, 3
	DB	1, 9, 2, 3, 4, 8, 7, 8, 3, 7, 2, 10, 2, 3, 1
	DB	5, 6, 1, 3, 6, 3, 3, 2, 6, 1, 3, 2, 6, 3, 4
	DB	2, 1, 3, 9, 5, 3, 4, 6, 3, 11, 1, 3, 6, 9, 2
	DB	7, 3, 2, 10, 3, 8, 4, 2, 4, 11, 4, 6, 3, 3, 8
	DB	6, 9, 15, 4, 2, 1, 2, 3, 13, 2, 7, 12, 11, 3, 1
	DB	3, 5, 3, 7, 3, 3, 6, 5, 3, 1, 6, 5, 6, 4, 9
	DB	9, 5, 3, 4, 8, 3, 3, 4, 8, 10, 2, 1, 5, 1, 5
	DB	6, 3, 4, 3, 5, 10, 5, 9, 13, 2, 3, 15, 1, 2, 4
	DB	3, 6, 6, 9, 2, 4, 11, 3, 1, 6, 17, 3, 9, 6, 3
	DB	1, 14, 7, 8, 7, 2, 7, 6, 2, 3, 3, 1, 18, 2, 3
	DB	10, 6, 12, 3, 11, 1, 8, 9, 6, 6, 9, 1, 3, 3, 3
	DB	2, 3, 7, 2, 1, 11, 4, 6, 3, 5, 3, 4, 6, 9, 6
	DB	3, 5, 1, 11, 7, 3, 3, 2, 9, 3, 10, 11, 1, 6, 12
	DB	2, 9, 9, 1, 11, 1, 2, 6, 4, 6, 5, 7, 2, 1, 9
	DB	8, 19, 3, 3, 3, 6, 5, 3, 6, 4, 3, 2, 3, 7, 15
	DB	3, 5, 4, 11, 3, 4, 6, 5, 1, 5, 1, 3, 5, 1, 5
	DB	6, 9, 10, 3, 2, 4, 11, 3, 3, 15, 3, 7, 3, 6, 6
	DB	3, 5, 1, 5, 15, 1, 8, 4, 2, 1, 3, 9, 2, 1, 3
	DB	2, 13, 2, 4, 3, 5, 1, 2, 3, 4, 2, 3, 15, 6, 1
	DB	3, 3, 2, 10, 11, 4, 2, 1, 2, 36, 4, 2, 4, 11, 1
	DB	2, 7, 5, 1, 2, 10, 3, 5, 9, 3, 10, 8, 3, 4, 3
	DB	2, 10, 6, 11, 1, 2, 1, 6, 5, 9, 1, 11, 3, 9, 15
	DB	1, 5, 7, 5, 4, 8, 25, 3, 5, 4, 5, 6, 3, 9, 1
	DB	11, 3, 1, 2, 3, 4, 3, 3, 5, 9, 1, 11, 1, 8, 7
	DB	5, 3, 1, 6, 5, 10, 2, 7, 3, 2, 18, 1, 2, 3, 6
	DB	1, 2, 7, 6, 3, 2, 3, 1, 3, 2, 10, 5, 1, 5, 3
	DB	6, 1, 12, 6, 6, 3, 3, 2, 12, 1, 2, 12, 1, 3, 2
	DB	3, 4, 8, 3, 1, 5, 6, 7, 3, 17, 3, 7, 3, 2, 1
	DB	15, 11, 4, 2, 3, 4, 2, 1, 14, 1, 3, 2, 13, 9, 11
	DB	1, 3, 8, 3, 1, 8, 6, 1, 6, 2, 3, 3, 7, 5, 3
	DB	4, 6, 2, 9, 1, 5, 4, 8, 3, 3, 15, 1, 5, 9, 1
	DB	5, 4, 2, 4, 6, 12, 20, 1, 6, 5, 3, 6, 1, 6, 2
	DB	1, 2, 3, 9, 7, 6, 3, 2, 7, 15, 2, 4, 5, 4, 3
	DB	5, 9, 4, 2, 7, 8, 3, 4, 2, 3, 1, 5, 1, 6, 2
	DB	1, 2, 3, 4, 2, 3, 16, 12, 5, 4, 9, 5, 1, 3, 5
	DB	1, 2, 9, 3, 6, 1, 8, 1, 11, 3, 3, 4, 9, 2, 9
	DB	6, 4, 3, 2, 10, 3, 15, 11, 6, 1, 3, 9, 2, 31, 2
	DB	1, 6, 3, 5, 1, 6, 6, 14, 1, 2, 7, 11, 3, 1, 3
	DB	3, 5, 7, 2, 1, 5, 3, 4, 5, 7, 5, 3, 1, 6, 11
	DB	9, 4, 5, 9, 6, 1, 6, 2, 6, 1, 5, 1, 3, 9, 3
	DB	3, 17, 3, 1, 6, 2, 3, 9, 9, 1, 8, 3, 3, 4, 3
	DB	5, 9, 4, 5, 4, 5, 1, 2, 9, 13, 6, 11, 1, 2, 1
	DB	11, 3, 3, 7, 8, 3, 10, 5, 6, 1, 9, 21, 2, 12, 1
	DB	3, 5, 6, 1, 3, 5, 4, 2, 3, 6, 6, 4, 2, 3, 6
	DB	15, 10, 3, 12, 3, 5, 6, 1, 5, 10, 3, 3, 2, 6, 7
	DB	5, 9, 6, 4, 3, 6, 2, 7, 5, 1, 6, 15, 8, 1, 6
	DB	3, 2, 1, 2, 3, 13, 2, 9, 1, 2, 3, 7, 27, 3, 26
	DB	1, 8, 3, 3, 6, 13, 2, 1, 3, 11, 3, 1, 6, 6, 3
	DB	5, 9, 1, 6, 6, 5, 9, 6, 3, 4, 3, 5, 3, 4, 2
	DB	1, 2, 10, 12, 3, 3, 5, 7, 5, 1, 11, 3, 7, 5, 13
	DB	2, 9, 4, 6, 6, 5, 6, 3, 4, 8, 3, 4, 3, 3, 11
	DB	1, 5, 10, 5, 3, 22, 9, 3, 5, 1, 2, 3, 7, 2, 13
	DB	2, 1, 6, 5, 4, 2, 4, 6, 2, 6, 4, 11, 4, 3, 5
	DB	9, 3, 3, 4, 3, 6, 2, 4, 9, 5, 6, 3, 6, 1, 3
	DB	2, 1, 8, 6, 6, 7, 5, 7, 3, 5, 6, 1, 6, 3, 2
	DB	3, 1, 6, 2, 13, 3, 9, 3, 5, 3, 1, 9, 5, 4, 2
	DB	13, 5, 10, 3, 8, 10, 6, 5, 4, 5, 1, 8, 3, 10, 5
	DB	10, 2, 15, 1, 2, 4, 8, 1, 9, 2, 1, 3, 5, 9, 6
	DB	7, 9, 3, 8, 10, 3, 2, 4, 3, 2, 3, 6, 4, 5, 1
	DB	6, 3, 2, 1, 3, 5, 1, 8, 6, 7, 5, 3, 4, 3, 14
	DB	1, 3, 9, 15, 17, 1, 8, 6, 1, 9, 8, 3, 4, 5, 4
	DB	5, 4, 5, 22, 3, 3, 2, 10, 2, 1, 2, 7, 14, 4, 3
	DB	8, 7, 15, 3, 15, 2, 7, 5, 3, 3, 4, 2, 9, 6, 3
	DB	1, 11, 6, 4, 3, 6, 2, 7, 2, 3, 1, 2, 9, 10, 3
	DB	8, 19, 8, 1, 2, 3, 1, 20, 21, 7, 2, 3, 1, 12, 5
	DB	3, 1, 9, 5, 6, 1, 8, 1, 3, 8, 3, 4, 2, 1, 5
	DB	3, 4, 5, 1, 9, 8, 4, 6, 9, 6, 3, 6, 5, 3, 3
	DB	9, 6, 7, 2, 1, 5, 10, 3, 6, 3, 8, 13, 2, 9, 1
	DB	2, 16, 5, 4, 3, 2, 3, 3, 7, 3, 9, 2, 1, 9, 5
	DB	4, 5, 4, 5, 1, 2, 3, 1, 5, 21, 4, 6, 2, 3, 9
	DB	1, 8, 4, 2, 1, 5, 7, 6, 5, 10, 2, 4, 5, 19, 2
	DB	3, 1, 5, 10, 5, 6, 3, 6, 13, 6, 2, 4, 14, 4, 2
	DB	4, 12, 3, 5, 4, 3, 8, 6, 4, 5, 6, 4, 11, 3, 1
	DB	5, 1, 3, 5, 3, 3, 4, 3, 2, 7, 14, 4, 8, 9, 4
	DB	2, 3, 10, 2, 9, 3, 1, 12, 12, 3, 3, 6, 6, 2, 1
	DB	11, 1, 5, 3, 4, 6, 2, 10, 9, 3, 2, 6, 12, 3, 3
	DB	27, 4, 3, 2, 13, 18, 2, 1, 2, 13, 6, 6, 2, 3, 3
	DB	4, 6, 5, 1, 6, 8, 9, 3, 4, 3, 6, 9, 5, 1, 27
	DB	2, 1, 5, 15, 6, 4, 2, 4, 8, 7, 6, 3, 2, 3, 6
	DB	3, 1, 2, 7, 6, 2, 7, 3, 12, 3, 3, 5, 6, 6, 10
	DB	9, 3, 3, 8, 4, 2, 3, 10, 2, 16, 2, 7, 5, 1, 3
	DB	6, 8, 1, 2, 3, 6, 1, 5, 4, 3, 2, 1, 5, 7, 3
	DB	3, 6, 9, 17, 4, 5, 3, 12, 3, 1, 5, 6, 1, 15, 5
	DB	7, 6, 6, 8, 3, 3, 1, 9, 2, 3, 15, 7, 2, 3, 3
	DB	1, 3, 2, 3, 7, 3, 2, 4, 5, 6, 3, 16, 5, 4, 11
	DB	1, 5, 3, 12, 4, 2, 15, 3, 1, 6, 8, 4, 3, 2, 3
	DB	4, 8, 7, 3, 3, 2, 1, 5, 6, 1, 8, 7, 2, 1, 2
	DB	10, 9, 5, 1, 5, 3, 6, 15, 4, 9, 6, 5, 1, 3, 3
	DB	2, 6, 6, 1, 2, 6, 9, 12, 1, 5, 3, 4, 8, 4, 3
	DB	6, 5, 7, 3, 6, 3, 3, 2, 1, 12, 2, 3, 4, 3, 2
	DB	1, 2, 3, 7, 2, 4, 5, 12, 12, 6, 1, 3, 6, 11, 15
	DB	1, 3, 9, 5, 3, 3, 4, 2, 1, 3, 5, 4, 5, 3, 4
	DB	8, 3, 7, 3, 2, 12, 4, 5, 1, 6, 3, 2, 18, 1, 11
	DB	3, 4, 3, 5, 4, 3, 6, 5, 7, 5, 3, 9, 6, 1, 6
	DB	2, 13, 5, 7, 8, 9, 4, 9, 6, 6, 3, 8, 7, 12, 5
	DB	6, 4, 11, 3, 1, 5, 30, 3, 1, 2, 4, 8, 7, 5, 3
	DB	12, 3, 6, 9, 12, 1, 15, 2, 1, 6, 3, 5, 1, 2, 7
	DB	3, 8, 1, 5, 4, 11, 10, 3, 2, 16, 3, 9, 2, 1, 2
	DB	1, 2, 4, 26, 7, 11, 1, 11, 10, 5, 4, 5, 1, 3, 2
	DB	7, 2, 3, 10, 2, 3, 1, 6, 6, 3, 6, 8, 1, 6, 5
	DB	4, 2, 3, 1, 14, 6, 4, 5, 6, 1, 2, 7, 14, 4, 3
	DB	2, 1, 2, 3, 1, 6, 29, 3, 7, 5, 1, 3, 14, 16, 2
	DB	15, 4, 3, 2, 3, 6, 6, 1, 2, 3, 3, 7, 8, 4, 15
	DB	2, 1, 5, 4, 3, 2, 3, 13, 2, 6, 1, 5, 9, 6, 6
	DB	9, 1, 2, 6, 4, 6, 5, 10, 2, 4, 8, 6, 4, 3, 8
	DB	4, 5, 6, 7, 3, 2, 4, 6, 2, 10, 3, 20, 4, 8, 3
	DB	18, 1, 3, 2, 3, 1, 11, 9, 1, 5, 3, 18, 7, 6, 2
	DB	9, 4, 2, 7, 5, 1, 5, 4, 2, 1, 9, 8, 6, 7, 5
	DB	7, 3, 3, 21, 5, 3, 3, 10, 5, 4, 6, 2, 6, 9, 1
	DB	5, 7, 9, 5, 9, 4, 3, 2, 7, 3, 5, 15, 7, 3, 3
	DB	2, 6, 19, 2, 1, 2, 3, 4, 6, 5, 3, 9, 3, 25, 3
	DB	2, 3, 6, 4, 5, 16, 3, 11, 1, 5, 6, 9, 1, 3, 2
	DB	15, 4, 3, 3, 9, 5, 1, 2, 6, 10, 5, 4, 12, 5, 1
	DB	3, 11, 3, 1, 9, 5, 6, 1, 15, 9, 6, 14, 1, 3, 2
	DB	3, 7, 3, 6, 5, 4, 2, 6, 13, 5, 4, 3, 8, 1, 5
	DB	9, 7, 3, 2, 3, 7, 8, 1, 3, 2, 6, 10, 2, 10, 2
	DB	3, 6, 1, 18, 2, 3, 1, 5, 1, 11, 4, 3, 5, 6, 6
	DB	9, 7, 12, 18, 2, 10, 12, 5, 3, 1, 14, 3, 9, 4, 2
	DB	3, 4, 3, 2, 1, 6, 14, 9, 7, 8, 7, 9, 5, 4, 3
	DB	2, 3, 3, 4, 11, 6, 1, 5, 9, 3, 1, 9, 5, 1, 6
	DB	5, 9, 16, 3, 2, 3, 3, 4, 3, 3, 5, 10, 3, 6, 5
	DB	4, 5, 7, 3, 5, 7, 2, 1, 11, 9, 1, 5, 1, 2, 10
	DB	2, 1, 17, 1, 6, 3, 5, 1, 5, 9, 3, 7, 6, 6, 11
	DB	4, 3, 8, 3, 4, 2, 6, 3, 4, 2, 18, 3, 3, 10, 12
	DB	3, 6, 9, 5, 1, 5, 13, 3, 8, 4, 3, 2, 12, 9, 4
	DB	6, 6, 5, 9, 6, 1, 12, 2, 6, 9, 6, 7, 5, 1, 2
	DB	12, 6, 7, 5, 3, 1, 3, 2, 3, 13, 2, 3, 3, 1, 11
	DB	4, 9, 2, 9, 4, 2, 12, 1, 6, 6, 2, 1, 26, 1, 9
	DB	3, 2, 3, 6, 1, 3, 6, 5, 4, 2, 1, 12, 5, 1, 5
	DB	1, 6, 3, 9, 20, 3, 10, 8, 1, 6, 3, 5, 6, 1, 2
	DB	3, 7, 6, 6, 11, 3, 4, 2, 1, 8, 9, 6, 1, 3, 8
	DB	3, 1, 3, 2, 6, 15, 4, 8, 1, 9, 5, 12, 1, 3, 12
	DB	2, 1, 11, 1, 8, 1, 3, 6, 2, 9, 4, 2, 7, 2, 9
	DB	12, 3, 1, 3, 5, 1, 5, 19, 3, 5, 7, 3, 3, 12, 2
	DB	1, 6, 8, 7, 8, 6, 1, 3, 5, 13, 2, 1, 6, 3, 2
	DB	6, 4, 6, 5, 9, 3, 7, 14, 1, 3, 5, 1, 2, 7, 17
	DB	1, 3, 11, 1, 5, 7, 2, 1, 8, 4, 5, 3, 4, 5, 4
	DB	2, 3, 1, 8, 3, 3, 9, 15, 7, 3, 2, 15, 1, 5, 7
	DB	2, 10, 5, 4, 2, 4, 9, 2, 7, 3, 2, 12, 3, 3, 9
	DB	9, 1, 18, 3, 5, 7, 6, 2, 3, 1, 15, 3, 2, 1, 3
	DB	14, 10, 2, 10, 6, 12, 8, 9, 6, 7, 3, 2, 6, 16, 6
	DB	3, 5, 4, 5, 3, 9, 1, 8, 7, 3, 11, 3, 6, 1, 9
	DB	2, 4, 15, 6, 2, 6, 1, 5, 19, 11, 1, 2, 7, 3, 6
	DB	12, 2, 1, 2, 7, 6, 5, 1, 8, 3, 10, 2, 10, 11, 6
	DB	1, 2, 1, 6, 11, 12, 3, 3, 1, 3, 2, 3, 1, 5, 6
	DB	6, 3, 1, 3, 8, 4, 3, 2, 9, 6, 6, 7, 2, 6, 3
	DB	4, 3, 9, 3, 5, 6, 7, 3, 2, 4, 11, 3, 1, 14, 9
	DB	1, 9, 5, 3, 7, 5, 1, 5, 7, 3, 5, 1, 11, 3, 4
	DB	3, 8, 6, 4, 11, 1, 2, 7, 9, 6, 3, 12, 3, 5, 1
	DB	6, 11, 9, 3, 10, 3, 5, 7, 2, 1, 3, 6, 11, 7, 6
	DB	2, 3, 4, 11, 1, 5, 6, 4, 20, 1, 3, 5, 4, 2, 21
	DB	10, 2, 16, 6, 5, 3, 6, 6, 1, 5, 4, 3, 2, 4, 2
	DB	13, 9, 2, 4, 14, 3, 9, 3, 6, 1, 5, 3, 3, 7, 5
	DB	6, 7, 12, 3, 2, 10, 11, 1, 9, 2, 3, 6, 1, 8, 9
	DB	7, 3, 3, 2, 3, 4, 9, 2, 7, 15, 2, 9, 4, 5, 1
	DB	2, 4, 6, 2, 6, 9, 1, 6, 5, 1, 8, 4, 2, 15, 1
	DB	3, 14, 1, 5, 1, 9, 5, 7, 2, 13, 3, 9, 2, 10, 3
	DB	2, 4, 9, 2, 6, 13, 12, 2, 10, 11, 1, 9, 11, 1, 2
	DB	6, 1, 3, 3, 3, 2, 3, 7, 2, 12, 6, 3, 9, 1, 6
	DB	14, 7, 2, 3, 4, 11, 3, 6, 9, 4, 2, 10, 3, 2, 3
	DB	1, 9, 3, 2, 6, 6, 4, 14, 3, 4, 5, 1, 12, 6, 5
	DB	12, 4, 5, 10, 6, 3, 6, 6, 2, 7, 6, 12, 17, 9, 4
	DB	5, 3, 9, 4, 2, 4, 8, 7, 3, 2, 3, 12, 1, 3, 2
	DB	3, 1, 8, 3, 3, 10, 12, 2, 1, 2, 7, 2, 9, 1, 3
	DB	6, 2, 7, 2, 1, 9, 8, 3, 3, 1, 8, 10, 3, 3, 15
	DB	2, 4, 3, 12, 8, 3, 3, 4, 6, 15, 2, 9, 9, 4, 2
	DB	13, 5, 1, 11, 4, 5, 7, 3, 2, 9, 4, 6, 14, 1, 3
	DB	2, 6, 3, 12, 3, 4, 5, 10, 8, 4, 15, 3, 3, 2, 1
	DB	5, 7, 3, 5, 16, 11, 9, 1, 2, 1, 2, 4, 11, 4, 9
	DB	6, 14, 1, 8, 6, 9, 7, 5, 9, 6, 3, 16, 5, 7, 3
	DB	5, 1, 5, 1, 3, 11, 1, 2, 3, 4, 5, 3, 7, 3, 2
	DB	6, 15, 12, 3, 3, 4, 3, 2, 1, 2, 3, 4, 3, 3, 11
	DB	9, 4, 2, 1, 9, 3, 2, 1, 8, 9, 10, 5, 3, 3, 15
	DB	1, 6, 14, 3, 3, 3, 1, 6, 5, 4, 9, 9, 2, 4, 9
	DB	5, 1, 14, 1, 5, 7, 2, 1, 15, 6, 11, 13, 5, 4, 3
	DB	5, 4, 8, 7, 3, 3, 5, 7, 3, 2, 1, 5, 6, 1, 3
	DB	5, 4, 2, 1, 5, 13, 11, 3, 1, 6, 9, 2, 13, 2, 4
	DB	5, 3, 7, 5, 1, 9, 3, 5, 10, 3, 3, 2, 12, 1, 2
	DB	4, 3, 8, 7, 8, 9, 1, 2, 6, 1, 5, 1, 3, 6, 5
	DB	3, 3, 10, 3, 2, 3, 19, 2, 3, 6, 7, 2, 6, 4, 5
	DB	6, 6, 4, 2, 3, 7, 5, 3, 6, 1, 5, 9, 1, 9, 5
	DB	4, 5, 1, 6, 2, 7, 14, 1, 8, 1, 9, 3, 5, 3, 4
	DB	8, 7, 15, 5, 10, 3, 5, 12, 1, 14, 1, 6, 8, 3, 4
	DB	18, 2, 4, 2, 7, 6, 5, 4, 6, 2, 3, 4, 2, 3, 7
	DB	11, 4, 3, 2, 1, 5, 3, 10, 5, 4, 3, 3, 11, 9, 1
	DB	8, 3, 10, 2, 13, 2, 7, 11, 7, 2, 6, 3, 4, 2, 3
	DB	3, 13, 5, 1, 9, 9, 2, 1, 8, 1, 9, 2, 3, 4, 2
	DB	3, 6, 1, 3, 3, 14, 19, 2, 4, 8, 13, 2, 1, 5, 6
	DB	1, 5, 4, 3, 5, 6, 1, 5, 1, 12, 2, 15, 13, 3, 3
	DB	9, 3, 3, 11, 1, 5, 9, 13, 2, 9, 4, 3, 3, 6, 8
	DB	3, 4, 8, 3, 4, 8, 1, 21, 29, 4, 2, 3, 1, 2, 4
	DB	8, 3, 10, 2, 6, 6, 3, 6, 1, 5, 1, 3, 11, 1, 5
	DB	3, 4, 3, 5, 7, 3, 3, 2, 9, 4, 5, 4, 8, 7, 5
	DB	1, 5, 1, 6, 3, 2, 10, 5, 4, 26, 4, 5, 3, 1, 5
	DB	4, 5, 3, 3, 4, 5, 1, 11, 1, 2, 3, 7, 2, 1, 12
	DB	6, 2, 13, 9, 2, 3, 7, 15, 3, 2, 3, 1, 11, 4, 2
	DB	3, 1, 11, 3, 4, 8, 3, 7, 2, 3, 9, 4, 6, 3, 6
	DB	12, 15, 8, 4, 17, 4, 11, 3, 7, 5, 9, 7, 2, 6, 4
	DB	2, 18, 3, 3, 1, 5, 1, 2, 10, 3, 3, 5, 6, 3, 1
	DB	20, 4, 3, 14, 3, 1, 6, 9, 2, 12, 7, 3, 3, 5, 10
	DB	5, 7, 8, 7, 8, 3, 4, 18, 2, 6, 6, 3, 6, 25, 6
	DB	3, 2, 3, 3, 4, 3, 5, 1, 5, 1, 9, 5, 7, 8, 4
	DB	3, 2, 10, 2, 1, 5, 3, 7, 9, 5, 19, 5, 9, 1, 5
	DB	1, 6, 2, 1, 2, 7, 3, 5, 4, 20, 3, 10, 2, 6, 4
	DB	3, 17, 4, 11, 4, 6, 5, 1, 8, 21, 6, 4, 11, 4, 11
	DB	4, 3, 17, 1, 3, 2, 7, 3, 8, 1, 11, 3, 4, 12, 11
	DB	3, 1, 6, 2, 3, 7, 2, 4, 12, 2, 3, 3, 1, 11, 10
	DB	3, 2, 7, 2, 3, 3, 4, 3, 5, 3, 4, 3, 8, 7, 3
	DB	3, 11, 3, 12, 16, 3, 9, 3, 9, 5, 4, 15, 9, 3, 8
	DB	6, 3, 6, 1, 3, 2, 6, 4, 3, 11, 4, 3, 2, 7, 5
	DB	9, 10, 5, 1, 3, 2, 1, 14, 9, 1, 5, 3, 3, 3, 7
	DB	20, 12, 1, 2, 4, 6, 2, 10, 2, 16, 9, 8, 3, 18, 4
	DB	3, 2, 3, 7, 2, 3, 13, 3, 5, 7, 9, 5, 3, 3, 7
	DB	5, 3, 3, 7, 3, 12, 2, 7, 11, 4, 6, 5, 4, 6, 9
	DB	5, 9, 4, 12, 5, 4, 2, 12, 3, 9, 3, 1, 5, 15, 1
	DB	5, 1, 2, 1, 20, 1, 14, 4, 3, 3, 9, 3, 5, 7, 2
	DB	9, 15, 9, 1, 6, 15, 3, 15, 2, 9, 6, 1, 2, 7, 3
	DB	5, 3, 4, 3, 5, 6, 1, 3, 6, 5, 1, 9, 2, 10, 2
	DB	3, 7, 3, 3, 11, 3, 3, 4, 9, 9, 5, 1, 5, 1, 3
	DB	2, 3, 6, 9, 1, 5, 4, 2, 9, 1, 3, 3, 3, 5, 4
	DB	5, 3, 9, 6, 4, 6, 3, 2, 3, 7, 8, 1, 6, 2, 3
	DB	19, 3, 3, 8, 10, 14, 10, 5, 3, 3, 7, 2, 13, 2, 7
	DB	5, 9, 7, 14, 1, 2, 7, 8, 1, 14, 3, 4, 3, 17, 4
	DB	2, 9, 1, 8, 4, 3, 20, 4, 9, 2, 15, 3, 6, 1, 15
	DB	3, 5, 7, 20, 7, 5, 1, 6, 5, 4, 2, 4, 3, 3, 14
	DB	1, 2, 6, 7, 8, 4, 15, 8, 9, 1, 5, 9, 3, 16, 2
	DB	9, 3, 1, 6, 5, 9, 1, 3, 5, 7, 9, 14, 3, 4, 8
	DB	1, 2, 10, 5, 4, 9, 5, 1, 5, 4, 2, 3, 6, 3, 10
	DB	2, 1, 3, 2, 10, 5, 13, 9, 5, 1, 9, 3, 8, 7, 2
	DB	13, 2, 7, 5, 6, 7, 3, 3, 2, 7, 5, 1, 15, 9, 11
	DB	1, 8, 1, 2, 4, 3, 3, 8, 1, 3, 6, 5, 4, 6, 2
	DB	7, 2, 3, 10, 5, 6, 1, 3, 3, 2, 1, 5, 1, 15, 8
	DB	6, 10, 9, 2, 3, 1, 2, 4, 8, 7, 9, 11, 3, 1, 11
	DB	3, 3, 9, 1, 5, 18, 4, 2, 3, 10, 2, 6, 3, 7, 2
	DB	1, 14, 12, 4, 2, 3, 6, 15, 9, 16, 11, 4, 18, 3, 2
	DB	6, 1, 6, 2, 3, 10, 5, 9, 9, 4, 3, 2, 12, 4, 5
	DB	7, 3, 2, 4, 6, 8, 1, 8, 3, 4, 8, 6, 7, 5, 15
	DB	7, 2, 6, 4, 6, 3, 5, 1, 6, 14, 3, 6, 6, 10, 5
	DB	1, 5, 7, 3, 3, 15, 2, 4, 6, 2, 1, 5, 7, 2, 13
	DB	9, 6, 5, 3, 4, 2, 6, 3, 12, 9, 4, 5, 1, 6, 2
	DB	6, 6, 3, 1, 11, 1, 2, 1, 6, 8, 7, 5, 1, 8, 9
	DB	16, 2, 3, 10, 11, 4, 5, 1, 5, 3, 1, 2, 7, 3, 12
	DB	2, 4, 2, 3, 6, 6, 4, 3, 5, 6, 4, 5, 1, 5, 6
	DB	3, 6, 6, 10, 14, 10, 5, 7, 5, 4, 5, 3, 1, 2, 7
	DB	3, 3, 6, 3, 6, 5, 7, 5, 7, 8, 4, 5, 13, 2, 1
	DB	3, 2, 7, 2, 3, 6, 4, 3, 15, 9, 6, 3, 6, 8, 6
	DB	6, 1, 14, 3, 7, 5, 18, 1, 2, 3, 4, 6, 11, 9, 1
	DB	15, 9, 11, 10, 9, 5, 19, 3, 2, 1, 12, 2, 3, 3, 1
	DB	5, 3, 7, 5, 4, 2, 12, 7, 8, 7, 11, 3, 10, 5, 7
	DB	2, 6, 6, 1, 8, 4, 3, 3, 9, 2, 3, 7, 11, 3, 1
	DB	21, 8, 1, 5, 3, 1, 2, 3, 4, 5, 10, 8, 15, 4, 5
	DB	4, 5, 1, 15, 3, 3, 18, 5, 4, 8, 3, 1, 6, 14, 1
	DB	2, 3, 9, 6, 3, 4, 5, 1, 2, 25, 2, 10, 2, 15, 4
	DB	2, 3, 6, 1, 12, 2, 4, 9, 3, 2, 3, 4, 5, 1, 2
	DB	1, 20, 9, 18, 15, 15, 4, 8, 7, 3, 6, 14, 1, 11, 1
	DB	2, 6, 15, 6, 3, 1, 2, 7, 5, 1, 9, 11, 6, 9, 1
	DB	5, 9, 16, 3, 2, 1, 3, 5, 10, 6, 5, 3, 6, 10, 6
	DB	3, 2, 1, 8, 1, 8, 3, 7, 2, 1, 8, 1, 3, 8, 3
	DB	4, 2, 4, 11, 9, 4, 6, 2, 4, 3, 12, 11, 3, 1, 6
	DB	15, 3, 5, 6, 3, 1, 11, 3, 1, 6, 3, 11, 4, 6, 11
	DB	1, 5, 3, 9, 6, 1, 3, 6, 9, 3, 2, 10, 11, 4, 6
	DB	12, 8, 7, 5, 15, 9, 1, 3, 2, 7, 5, 1, 6, 5, 6
	DB	3, 1, 8, 6, 1, 3, 6, 5, 1, 5, 3, 1, 6, 6, 8
	DB	10, 5, 6, 4, 15, 5, 7, 2, 3, 4, 3, 2, 10, 9, 12
	DB	2, 6, 4, 2, 1, 12, 3, 12, 5, 1, 2, 3, 1, 3, 3
	DB	3, 2, 12, 1, 5, 6, 1, 3, 5, 4, 3, 5, 9, 1, 3
	DB	2, 10, 12, 5, 6, 1, 6, 3, 12, 2, 18, 7, 8, 4, 11
	DB	3, 4, 2, 1, 3, 11, 10, 8, 6, 9, 1, 6, 8, 3, 3
	DB	6, 3, 6, 1, 3, 6, 5, 4, 8, 4, 3, 8, 4, 6, 2
	DB	3, 3, 10, 6, 6, 2, 3, 10, 2, 6, 1, 5, 1, 3, 15
	DB	11, 3, 1, 2, 19, 5, 1, 2, 1, 11, 1, 8, 1, 3, 5
	DB	10, 3, 12, 2, 6, 7, 6, 2, 19, 5, 15, 3, 1, 6, 6
	DB	2, 3, 15, 7, 2, 4, 9, 18, 2, 3, 10, 2, 1, 6, 5
	DB	1, 3, 5, 6, 3, 6, 4, 3, 3, 12, 2, 15, 10, 3, 18
	DB	5, 1, 6, 3, 2, 4, 3, 2, 6, 4, 3, 6, 2, 3, 7
	DB	2, 10, 6, 2, 3, 9, 1, 2, 9, 1, 8, 6, 15, 3, 3
	DB	4, 20, 4, 24, 3, 8, 9, 7, 6, 3, 9, 2, 10, 5, 1
	DB	3, 5, 4, 15, 2, 6, 10, 3, 6, 3, 3, 17, 3, 3, 9
	DB	3, 4, 5, 6, 3, 4, 5, 1, 2, 12, 3, 4, 11, 3, 1
	DB	6, 3, 5, 6, 3, 12, 3, 7, 6, 18, 2, 12, 1, 5, 4
	DB	5, 3, 7, 5, 16, 2, 4, 5, 6, 13, 9, 2, 3, 10, 2
	DB	10, 3, 8, 3, 1, 15, 6, 3, 5, 1, 3, 5, 6, 4, 2
	DB	1, 3, 5, 6, 13, 11, 4, 3, 2, 7, 3, 3, 15, 2, 3
	DB	7, 2, 1, 14, 1, 3, 11, 4, 2, 9, 9, 9, 1, 6, 3
	DB	2, 10, 5, 3, 3, 7, 5, 6, 1, 6, 15, 17, 6, 4, 3
	DB	2, 1, 5, 1, 8, 6, 1, 5, 4, 9, 12, 3, 2, 6, 7
	DB	2, 4, 2, 7, 2, 3, 3, 10, 3, 2, 4, 9, 26, 1, 2
	DB	6, 4, 2, 19, 2, 13, 12, 8, 6, 3, 1, 6, 6, 8, 1
	DB	3, 3, 2, 6, 7, 8, 4, 6, 9, 8, 3, 4, 5, 3, 7
	DB	5, 6, 1, 5, 1, 2, 12, 3, 21, 12, 4, 5, 3, 3, 3
	DB	1, 6, 2, 7, 3, 3, 14, 3, 1, 5, 6, 6, 3, 10, 2
	DB	3, 7, 2, 1, 6, 5, 6, 12, 3, 4, 3, 3, 2, 12, 6
	DB	10, 8, 7, 15, 9, 3, 2, 13, 6, 2, 3, 1, 3, 2, 1
	DB	14, 4, 20, 1, 5, 4, 2, 10, 3, 9, 5, 1, 2, 22, 3
	DB	9, 6, 3, 2, 3, 1, 11, 3, 7, 15, 5, 12, 1, 5, 4
	DB	8, 9, 1, 9, 11, 4, 5, 3, 3, 7, 2, 4, 9, 2, 1
	DB	9, 9, 9, 3, 2, 12, 9, 1, 8, 3, 3, 9, 10, 8, 10
	DB	2, 7, 3, 2, 10, 9, 5, 1, 3, 5, 12, 1, 5, 12, 3
	DB	3, 12, 3, 6, 1, 14, 6, 7, 3, 3, 6, 3, 11, 6, 6
	DB	4, 18, 2, 6, 7, 2, 10, 5, 6, 12, 1, 2, 3, 6, 1
	DB	2, 1, 5, 6, 13, 3, 8, 4, 2, 4, 5, 4, 3, 17, 1
	DB	6, 8, 12, 3, 1, 5, 1, 9, 2, 4, 3, 8, 3, 1, 3
	DB	3, 3, 2, 7, 2, 10, 3, 2, 10, 3, 6, 11, 3, 1, 5
	DB	6, 1, 3, 2, 4, 6, 2, 7, 6, 5, 7, 2, 6, 13, 5
	DB	7, 2, 13, 3, 15, 2, 9, 9, 4, 3, 8, 4, 5, 7, 5
	DB	4, 5, 10, 11, 10, 8, 1, 9, 3, 2, 3, 3, 6, 1, 5
	DB	13, 2, 4, 9, 9, 3, 9, 3, 2, 3, 12, 3, 10, 17, 13
	DB	5, 1, 14, 6, 4, 5, 6, 1, 3, 11, 1, 6, 8, 1, 3
	DB	3, 5, 7, 8, 10, 3, 2, 19, 3, 5, 3, 4, 8, 21, 1
	DB	3, 2, 3, 3, 3, 7, 8, 7, 2, 10, 5, 1, 2, 4, 9
	DB	5, 6, 18, 1, 5, 21, 4, 2, 10, 12, 8, 4, 11, 3, 4
	DB	2, 1, 3, 11, 3, 3, 4, 14, 1, 5, 9, 7, 3, 2, 9
	DB	4, 5, 7, 2, 6, 4, 5, 6, 7, 2, 1, 6, 6, 2, 3
	DB	9, 15, 6, 19, 3, 6, 5, 1, 9, 5, 6, 4, 2, 4, 3
	DB	2, 1, 12, 6, 9, 2, 1, 2, 1, 29, 6, 4, 12, 5, 1
	DB	2, 3, 3, 6, 1, 2, 7, 3, 3, 8, 6, 1, 2, 16, 2
	DB	12, 3, 3, 4, 5, 1, 11, 9, 6, 10, 3, 15, 2, 15, 3
	DB	1, 2, 7, 3, 2, 7, 8, 1, 6, 5, 1, 3, 6, 6, 5
	DB	3, 4, 11, 4, 6, 6, 3, 8, 3, 9, 10, 11, 9, 1, 11
	DB	1, 8, 1, 11, 7, 5, 10, 5, 16, 2, 4, 5, 3, 1, 11
	DB	3, 6, 1, 3, 2, 1, 2, 7, 6, 12, 5, 1, 6, 8, 1
	DB	2, 3, 7, 3, 5, 6, 1, 8, 7, 17, 6, 1, 3, 3, 3
	DB	2, 10, 5, 13, 6, 6, 2, 1, 2, 4, 5, 1, 2, 1, 11
	DB	3, 3, 7, 2, 9, 6, 13, 3, 5, 4, 8, 1, 2, 10, 5
	DB	3, 21, 1, 5, 3, 4, 12, 6, 3, 2, 3, 6, 1, 14, 4
	DB	6, 9, 9, 3, 23, 4, 5, 3, 7, 2, 1, 3, 2, 3, 21
	DB	4, 5, 4, 5, 1, 9, 2, 3, 6, 6, 1, 2, 10, 5, 6
	DB	6, 4, 2, 13, 9, 11, 4, 3, 8, 7, 8, 1, 9, 5, 1
	DB	3, 3, 5, 7, 2, 1, 15, 2, 1, 2, 4, 5, 3, 1, 6
	DB	8, 3, 28, 5, 1, 6, 5, 4, 6, 3, 2, 7, 5, 1, 2
	DB	4, 3, 2, 10, 3, 6, 11, 3, 16, 5, 1, 5, 6, 7, 3
	DB	14, 18, 3, 3, 1, 6, 2, 3, 3, 4, 11, 1, 9, 5, 1
	DB	3, 2, 10, 5, 4, 2, 3, 7, 9, 3, 21, 11, 1, 2, 1
	DB	14, 1, 2, 9, 3, 3, 3, 6, 1, 12, 5, 18, 3, 1, 6
	DB	5, 13, 12, 9, 8, 3, 3, 7, 12, 6, 2, 4, 3, 6, 2
	DB	4, 8, 10, 20, 13, 2, 6, 1, 3, 2, 1, 5, 7, 5, 1
	DB	2, 13, 6, 14, 1, 8, 13, 3, 5, 1, 3, 5, 3, 4, 3
	DB	3, 3, 5, 6, 3, 10, 20, 10, 2, 1, 8, 6, 3, 6, 4
	DB	2, 9, 1, 6, 5, 13, 6, 8, 1, 9, 12, 6, 2, 7, 11
	DB	10, 5, 7, 6, 2, 9, 6, 4, 5, 6, 3, 15, 7, 2, 12
	DB	3, 15, 3, 3, 1, 3, 11, 16, 3, 2, 3, 3, 10, 8, 1
	DB	5, 4, 6, 5, 1, 3, 5, 4, 8, 18, 4, 3, 2, 1, 14
	DB	1, 14, 6, 1, 5, 3, 7, 5, 3, 3, 3, 4, 3, 2, 7
	DB	9, 2, 3, 6, 1, 5, 9, 4, 15, 20, 1, 9, 2, 3, 7
	DB	9, 3, 2, 6, 3, 6, 3, 7, 5, 13, 3, 8, 1, 8, 15
	DB	1, 5, 1, 21, 3, 14, 7, 3, 5, 1, 6, 9, 6, 3, 5
	DB	6, 6, 10, 3, 2, 1, 5, 3, 6, 6, 7, 6, 17, 3, 1
	DB	6, 5, 3, 4, 3, 2, 6, 19, 3, 5, 9, 1, 14, 1, 3
	DB	6, 15, 8, 1, 5, 4, 2, 1, 8, 9, 13, 2, 3, 4, 9
	DB	11, 3, 10, 2, 3, 6, 1, 3, 6, 2, 9, 3, 1, 11, 6
	DB	4, 3, 8, 9, 15, 6, 12, 1, 5, 1, 3, 3, 2, 3, 18
	DB	7, 3, 11, 1, 29, 4, 6, 3, 5, 1, 20, 4, 3, 14, 1
	DB	2, 7, 3, 3, 9, 5, 4, 2, 7, 2, 4, 15, 2, 3, 4
	DB	3, 3, 9, 2, 1, 2, 7, 6, 9, 5, 1, 2, 6, 1, 5
	DB	4, 5, 7, 5, 9, 6, 4, 3, 5, 7, 5, 4, 11, 1, 3
	DB	11, 6, 3, 4, 6, 14, 1, 24, 6, 2, 9, 4, 5, 7, 5
	DB	7, 2, 6, 15, 12, 3, 4, 3, 2, 4, 27, 2, 1, 5, 6
	DB	4, 5, 6, 6, 9, 1, 12, 2, 4, 11, 6, 10, 2, 6, 1
	DB	6, 8, 1, 14, 1, 3, 12, 5, 1, 14, 1, 2, 10, 2, 6
	DB	3, 7, 2, 3, 7, 11, 12, 10, 2, 7, 3, 3, 5, 15, 4
	DB	5, 9, 1, 3, 3, 8, 1, 3, 3, 2, 1, 12, 2, 1, 12
	DB	5, 3, 1, 5, 1, 3, 11, 4, 2, 4, 3, 2, 9, 1, 9
	DB	2, 4, 8, 13, 2, 3, 4, 11, 10, 8, 4, 2, 3, 12, 3
	DB	7, 6, 8, 1, 6, 2, 7, 5, 1, 2, 6, 9, 16, 5, 7
	DB	12, 6, 20, 4, 17, 6, 7, 2, 9, 1, 14, 6, 10, 3, 5
	DB	1, 20, 9, 7, 6, 2, 18, 3, 1, 11, 3, 7, 5, 12, 21
	DB	1, 8, 1, 17, 4, 3, 2, 1, 2, 7, 20, 4, 6, 3, 12
	DB	9, 2, 3, 1, 3, 2, 1, 2, 1, 12, 5, 4, 3, 3, 5
	DB	7, 3, 8, 9, 7, 9, 12, 2, 3, 3, 4, 2, 10, 5, 3
	DB	6, 1, 6, 2, 7, 3, 3, 3, 2, 7, 8, 18, 7, 3, 2
	DB	7, 2, 3, 12, 4, 2, 10, 5, 7, 6, 17, 4, 5, 3, 3
	DB	3, 7, 2, 7, 6, 3, 5, 9, 7, 5, 6, 3, 1, 3, 3
	DB	14, 1, 2, 12, 3, 1, 2, 4, 8, 3, 10, 2, 1, 5, 1
	DB	5, 4, 32, 3, 4, 6, 2, 7, 6, 5, 1, 6, 3, 5, 9
	DB	12, 3, 1, 5, 4, 3, 8, 10, 2, 7, 3, 3, 6, 3, 2
	DB	3, 1, 2, 4, 11, 3, 4, 2, 1, 8, 9, 7, 3, 11, 7
	DB	5, 7, 2, 3, 1, 2, 7, 5, 6, 4, 8, 4, 5, 4, 12
	DB	20, 3, 6, 1, 3, 9, 2, 1, 2, 15, 1, 15, 2, 4, 9
	DB	6, 6, 2, 1, 2, 7, 18, 8, 9, 1, 6, 5, 3, 6, 9
	DB	1, 9, 3, 3, 11, 9, 19, 3, 5, 9, 1, 5, 4, 3, 8
	DB	12, 7, 3, 2, 3, 7, 8, 12, 3, 6, 4, 6, 5, 7, 23
	DB	1, 8, 1, 11, 3, 1, 5, 1, 5, 1, 3, 2, 10, 5, 3
	DB	15, 4, 3, 3, 2, 15, 4, 3, 3, 3, 11, 18, 1, 2, 4
	DB	3, 3, 2, 7, 6, 5, 10, 2, 1, 2, 15, 3, 7, 8, 6
	DB	15, 1, 2, 3, 4, 15, 5, 4, 17, 9, 6, 4, 11, 10, 2
	DB	7, 5, 10, 3, 2, 1, 5, 7, 2, 13, 3, 18, 6, 9, 2
	DB	4, 3, 2, 3, 1, 14, 3, 3, 12, 4, 5, 13, 3, 12, 2
	DB	4, 12, 5, 10, 2, 1, 5, 7, 8, 1, 3, 3, 2, 3, 4
	DB	9, 14, 7, 3, 8, 7, 3, 2, 3, 3, 4, 2, 1, 2, 6
	DB	1, 6, 3, 6, 14, 1, 3, 6, 5, 7, 2, 22, 3, 5, 1
	DB	6, 6, 15, 2, 6, 1, 3, 5, 6, 1, 5, 1, 5, 3, 4
	DB	5, 3, 7, 8, 4, 3, 6, 5, 1, 5, 4, 6, 5, 9, 4
	DB	2, 1, 2, 13, 3, 11, 3, 7, 5, 3, 1, 14, 3, 4, 23
	DB	3, 3, 9, 3, 3, 4, 3, 5, 9, 1, 3, 6, 9, 5, 4
	DB	6, 15, 5, 1, 5, 1, 2, 3, 9, 1, 2, 10, 6, 2, 3
	DB	4, 17, 3, 3, 12, 6, 4, 18, 8, 1, 3, 2, 1, 2, 3
	DB	10, 3, 12, 2, 1, 2, 9, 10, 3, 11, 4, 23, 9, 1, 8
	DB	10, 11, 1, 12, 11, 1, 8, 12, 10, 8, 1, 2, 4, 5, 1
	DB	5, 7, 2, 4, 9, 2, 4, 2, 7, 5, 1, 12, 8, 4, 3
	DB	8, 10, 5, 1, 3, 2, 15, 1, 8, 16, 3, 6, 5, 12, 4
	DB	6, 9, 8, 1, 6, 3, 2, 6, 3, 1, 14, 9, 1, 11, 3
	DB	3, 3, 1, 3, 8, 7, 3, 15, 8, 1, 5, 1, 2, 6, 1
	DB	6, 5, 7, 3, 5, 4, 14, 1, 18, 3, 8, 7, 2, 10, 12
	DB	3, 2, 4, 2, 9, 4, 2, 7, 2, 3, 1, 12, 8, 7, 2
	DB	13, 8, 1, 5, 16, 3, 2, 3, 6, 3, 18, 4, 6, 2, 1
	DB	2, 4, 3, 2, 10, 6, 5, 12, 6, 1, 6, 5, 3, 6, 1
	DB	3, 9, 2, 3, 3, 3, 4, 12, 3, 5, 6, 15, 7, 5, 4
	DB	6, 3, 5, 6, 1, 9, 3, 2, 4, 2, 12, 10, 2, 4, 5
;;; Location of "DB 0" prior to version 28.9
	DB	6, 4, 6, 8, 3, 7, 2, 4, 2, 9, 25, 3, 3, 2, 3
	DB	4, 3, 5, 13, 5, 3, 1, 5, 1, 5, 3, 19, 6, 2, 4
	DB	5, 10, 3, 3, 3, 9, 5, 1, 6, 8, 1, 6, 6, 2, 13
	DB	5, 3, 10, 9, 20, 6, 4, 5, 6, 1, 9, 6, 5, 1, 5
	DB	13, 2, 3, 6, 4, 2, 15, 3, 1, 3, 8, 12, 12, 9, 6
	DB	6, 4, 3, 2, 4, 5, 4, 3, 2, 10, 5, 13, 2, 12, 3
	DB	1, 6, 21, 9, 3, 2, 13, 3, 14, 3, 1, 5, 4, 3, 3
	DB	5, 4, 5, 1, 11, 1, 2, 10, 2, 3, 18, 7, 2, 10, 11
	DB	3, 7, 3, 5, 4, 2, 1, 2, 7, 9, 17, 4, 11, 7, 5
	DB	12, 3, 1, 5, 1, 3, 5, 13, 9, 5, 9, 12, 9, 1, 12
	DB	20, 1, 2, 3, 1, 3, 5, 13, 3, 6, 6, 3, 2, 18, 1
	DB	5, 6, 12, 1, 2, 4, 5, 3, 1, 2, 12, 1, 2, 18, 1
	DB	11, 7, 12, 9, 21, 3, 5, 1, 12, 8, 6, 1, 2, 1, 5
	DB	1, 5, 4, 2, 18, 4, 2, 6, 9, 3, 3, 7, 11, 1, 3
	DB	12, 3, 5, 12, 10, 11, 3, 7, 18, 14, 3, 4, 3, 12, 3
	DB	6, 14, 1, 9, 2, 1, 2, 10, 11, 4, 5, 1, 9, 2, 4
	DB	5, 7, 5, 3, 4, 3, 3, 6, 8, 6, 7, 5, 9, 1, 5
	DB	12, 12, 3, 6, 1, 11, 3, 10, 11, 1, 2, 6, 1, 3, 18
	DB	3, 11, 3, 1, 14, 6, 9, 1, 2, 7, 3, 2, 1, 5, 1
	DB	8, 1, 5, 4, 3, 5, 9, 6, 3, 7, 2, 3, 9, 6, 13
	DB	2, 3, 7, 3, 5, 6, 1, 2, 1, 5, 12, 4, 5, 16, 5
	DB	4, 5, 3, 1, 9, 6, 14, 15, 1, 9, 2, 3, 7, 3, 2
	DB	4, 11, 4, 15, 9, 5, 13, 2, 1, 11, 4, 2, 4, 3, 2
	DB	13, 2, 6, 10, 9, 3, 6, 5, 9, 1, 2, 3, 1, 6, 14
	DB	3, 10, 3, 8, 4, 3, 3, 2, 3, 10, 6, 3, 2, 10, 3
	DB	8, 3, 16, 5, 9, 1, 6, 8, 12, 3, 4, 6, 17, 3, 10
	DB	11, 1, 8, 7, 3, 2, 7, 3, 12, 15, 2, 4, 6, 3, 8
	DB	10, 5, 7, 2, 1, 8, 6, 1, 5, 4, 3, 15, 6, 5, 7
	DB	5, 4, 5, 3, 1, 2, 7, 5, 1, 5, 16, 9, 2, 4, 14
	DB	10, 2, 10, 3, 2, 15, 4, 3, 11, 9, 6, 1, 5, 6, 3
	DB	9, 3, 27, 3, 7, 2, 3, 3, 7, 12, 3, 6, 5, 6, 3
	DB	12, 6, 9, 4, 9, 2, 1, 2, 1, 11, 4, 5, 1, 6, 5
	DB	7, 3, 2, 1, 6, 23, 3, 3, 1, 3, 3, 15, 5, 4, 3
	DB	6, 2, 7, 3, 8, 6, 4, 5, 10, 9, 5, 3, 3, 6, 1
	DB	5, 7, 2, 1, 2, 12, 6, 4, 9, 2, 4, 8, 7, 6, 5
	DB	9, 6, 4, 9, 2, 7, 2, 3, 1, 11, 9, 4, 5, 13, 2
	DB	1, 12, 3, 2, 3, 6, 13, 2, 4, 5, 9, 3, 7, 5, 6
	DB	1, 6, 3, 2, 4, 6, 8, 1, 5, 3, 1, 11, 1, 2, 7
	DB	9, 5, 6, 10, 5, 3, 1, 2, 7, 6, 2, 4, 5, 1, 3
	DB	17, 3, 1, 8, 6, 4, 11, 4, 15, 5, 1, 12, 2, 7, 5
	DB	10, 8, 1, 2, 10, 5, 3, 4, 2, 4, 2, 12, 3, 7, 2
	DB	16, 2, 3, 7, 3, 2, 1, 11, 30, 1, 3, 12, 2, 7, 9
	DB	6, 9, 6, 3, 2, 15, 1, 8, 1, 11, 7, 8, 9, 3, 18
	DB	3, 9, 1, 5, 4, 2, 1, 3, 12, 9, 15, 3, 3, 17, 7
	DB	3, 26, 1, 8, 6, 7, 8, 4, 15, 2, 1, 3, 5, 6, 1
	DB	14, 3, 7, 6, 14, 9, 10, 2, 4, 3, 3, 2, 3, 4, 11
	DB	3, 12, 4, 3, 6, 6, 3, 6, 2, 10, 23, 9, 7, 5, 1
	DB	12, 2, 1, 12, 11, 7, 5, 3, 16, 6, 2, 1, 5, 1, 5
	DB	1, 2, 3, 3, 6, 6, 7, 3, 3, 14, 1, 9, 3, 3, 2
	DB	12, 1, 6, 6, 3, 2, 12, 12, 1, 3, 2, 19, 3, 5, 6
	DB	1, 6, 2, 10, 11, 6, 1, 5, 3, 9, 21, 6, 1, 3, 6
	DB	11, 7, 5, 3, 3, 1, 5, 9, 7, 2, 13, 8, 6, 4, 9
	DB	2, 1, 5, 4, 3, 2, 3, 3, 3, 7, 8, 1, 6, 3, 5
	DB	6, 1, 12, 2, 9, 1, 9, 5, 6, 10, 3, 8, 7, 3, 3
	DB	6, 8, 6, 10, 2, 4, 3, 17, 13, 5, 15, 3, 12, 3, 13
	DB	6, 8, 1, 5, 6, 1, 5, 3, 4, 21, 2, 4, 3, 2, 9
	DB	1, 3, 3, 3, 5, 4, 2, 3, 15, 6, 9, 12, 4, 2, 3
	DB	4, 5, 1, 2, 4, 8, 3, 19, 3, 3, 3, 15, 2, 7, 3
	DB	5, 4, 5, 13, 3, 9, 5, 3, 1, 24, 6, 17, 4, 6, 8
	DB	4, 3, 8, 7, 5, 7, 2, 3, 3, 7, 8, 3, 6, 1, 27
	DB	8, 3, 6, 1, 3, 17, 9, 3, 1, 9, 3, 2, 1, 12, 9
	DB	6, 2, 1, 6, 3, 3, 2, 6, 1, 5, 9, 4, 3, 2, 3
	DB	9, 3, 7, 3, 5, 3, 4, 5, 1, 17, 7, 15, 3, 2, 1
	DB	24, 14, 1, 3, 5, 6, 4, 2, 1, 3, 6, 6, 3, 2, 9
	DB	3, 6, 4, 2, 1, 3, 11, 1, 2, 7, 11, 15, 3, 1, 3
	DB	2, 3, 13, 2, 7, 8, 6, 4, 2, 1, 8, 7, 14, 6, 10
	DB	2, 6, 1, 3, 6, 5, 1, 9, 2, 7, 17, 6, 7, 2, 4
	DB	9, 8, 4, 9, 2, 3, 15, 7, 8, 4, 2, 3, 10, 32, 4
	DB	2, 7, 3, 17, 1, 27, 9, 9, 2, 3, 6, 10, 3, 12, 8
	DB	3, 3, 7, 2, 1, 11, 3, 7, 6, 2, 7, 18, 5, 1, 2
	DB	7, 5, 3, 4, 8, 3, 10, 2, 7, 5, 10, 5, 9, 4, 2
	DB	1, 5, 7, 2, 10, 9, 5, 9, 1, 9, 2, 4, 11, 9, 4
	DB	2, 1, 5, 4, 3, 3, 5, 7, 8, 4, 8, 1, 2, 4, 21
	DB	2, 6, 9, 1, 11, 6, 4, 9, 9, 2, 1, 17, 1, 2, 7
	DB	6, 2, 4, 6, 2, 7, 8, 22, 3, 3, 3, 14, 15, 1, 9
	DB	6, 6, 5, 4, 11, 1, 3, 2, 9, 3, 18, 3, 4, 2, 1
	DB	2, 3, 7, 5, 3, 3, 7, 2, 1, 5, 1, 3, 2, 10, 5
	DB	6, 12, 6, 7, 5, 12, 3, 4, 5, 6, 3, 1, 3, 6, 5
	DB	1, 14, 1, 5, 9, 12, 7, 6, 9, 3, 5, 4, 5, 13, 3
	DB	2, 6, 4, 2, 3, 13, 5, 4, 5, 1, 8, 1, 5, 13, 5
	DB	1, 9, 2, 3, 10, 6, 2, 3, 4, 6, 5, 1, 9, 11, 1
	DB	5, 22, 2, 10, 5, 19, 2, 7, 6, 5, 1, 5, 1, 2, 1
	DB	5, 7, 5, 4, 3, 3, 5, 3, 9, 3, 9, 13, 15, 3, 8
	DB	6, 4, 2, 3, 7, 18, 5, 16, 11, 19, 6, 2, 7, 5, 4
	DB	2, 4, 5, 10, 5, 1, 8, 10, 30, 6, 3, 2, 9, 9, 1
	DB	6, 5, 1, 12, 3, 5, 7, 3, 2, 1, 2, 4, 3, 5, 3
	DB	3, 7, 3, 6, 3, 2, 15, 15, 9, 1, 9, 2, 9, 3, 15
	DB	3, 3, 1, 14, 7, 8, 1, 9, 5, 4, 2, 1, 2, 3, 3
	DB	4, 2, 9, 4, 6, 20, 1, 6, 3, 2, 19, 6, 3, 5, 1
	DB	3, 8, 3, 19, 2, 10, 3, 5, 1, 12, 5, 3, 1, 15, 8
	DB	3, 7, 2, 3, 13, 18, 9, 2, 4, 2, 12, 10, 2, 1, 2
	DB	6, 6, 6, 3, 19, 2, 6, 3, 6, 6, 7, 2, 6, 3, 4
	DB	15, 12, 5, 1, 9, 8, 3, 3, 1, 5, 4, 11, 3, 1, 2
	DB	7, 5, 3, 3, 1, 11, 10, 3, 15, 2, 3, 7, 2, 10, 11
	DB	6, 15, 3, 1, 9, 5, 3, 4, 5, 4, 5, 7, 5, 9, 9
	DB	4, 3, 5, 7, 2, 3, 1, 2, 4, 9, 5, 1, 3, 3, 12
	DB	2, 3, 1, 5, 6, 1, 17, 3, 13, 15, 11, 10, 3, 18, 8
	DB	6, 1, 2, 3, 3, 6, 1, 9, 11, 7, 3, 12, 2, 25, 8
	DB	1, 6, 8, 6, 4, 12, 6, 8, 9, 12, 4, 2, 3, 1, 3
	DB	6, 6, 8, 6, 9, 7, 3, 2, 1, 2, 6, 1, 5, 6, 9
	DB	1, 3, 2, 9, 3, 3, 4, 6, 2, 1, 2, 3, 1, 3, 2
	DB	1, 2, 6, 10, 2, 7, 3, 23, 4, 20, 1, 6, 8, 1, 2
	DB	4, 5, 1, 17, 10, 8, 7, 11, 4, 2, 6, 12, 1, 9, 5
	DB	12, 15, 1, 12, 5, 13, 17, 1, 2, 4, 9, 5, 1, 8, 1
	DB	2, 7, 6, 5, 9, 3, 24, 4, 2, 3, 6, 6, 7, 5, 3
	DB	3, 7, 3, 6, 6, 9, 5, 1, 12, 3, 2, 3, 3, 12, 15
	DB	7, 2, 3, 13, 2, 1, 2, 7, 2, 4, 15, 5, 4, 2, 9
	DB	6, 4, 5, 7, 14, 3, 15, 6, 16, 8, 3, 3, 4, 3, 27
	DB	3, 9, 3, 8, 3, 1, 6, 2, 12, 1, 3, 5, 1, 5, 4
	DB	5, 1, 11, 15, 3, 4, 2, 4, 2, 4, 8, 1, 5, 9, 3
	DB	7, 6, 12, 3, 6, 6, 14, 13, 3, 12, 2, 6, 3, 1, 18
	DB	2, 3, 6, 10, 9, 3, 2, 3, 9, 1, 5, 10, 9, 5, 6
	DB	7, 6, 5, 10, 11, 1, 3, 5, 1, 3, 2, 3, 3, 9, 1
	DB	18, 11, 4, 15, 5, 1, 14, 7, 5, 12, 3, 4, 5, 9, 4
	DB	2, 1, 5, 9, 3, 10, 3, 8, 7, 17, 3, 4, 5, 3, 3
	DB	3, 1, 3, 2, 1, 5, 7, 2, 6, 4, 3, 6, 2, 3, 1
	DB	6, 2, 1, 2, 4, 5, 1, 14, 1, 15, 8, 1, 3, 11, 9
	DB	7, 3, 21, 5, 1, 3, 3, 9, 5, 9, 4, 5, 6, 1, 5
	DB	19, 2, 7, 6, 2, 3, 7, 18, 6, 5, 4, 6, 5, 3, 12
	DB	6, 7, 3, 2, 7, 5, 6, 4, 8, 12, 1, 2, 1, 5, 15
	DB	7, 23, 9, 3, 9, 3, 1, 9, 6, 6, 5, 3, 21, 1, 3
	DB	3, 8, 4, 3, 8, 9, 7, 11, 4, 6, 2, 1, 2, 10, 3
	DB	5, 6, 4, 2, 12, 3, 7, 2, 1, 5, 9, 15, 4, 5, 4
	DB	3, 15, 2, 12, 1, 5, 3, 7, 8, 1, 5, 4, 5, 6, 13
	DB	6, 5, 1, 11, 4, 5, 1, 8, 12, 7, 2, 3, 3, 27, 1
	DB	2, 4, 3, 6, 5, 1, 11, 4, 3, 20, 1, 12, 8, 6, 1
	DB	3, 11, 1, 3, 6, 3, 2, 10, 3, 3, 5, 3, 4, 5, 6
	DB	1, 11, 3, 1, 5, 13, 2, 1, 3, 5, 6, 3, 10, 11, 7
	DB	2, 1, 5, 1, 21, 2, 3, 4, 3, 2, 10, 6, 17, 10, 8
	DB	3, 1, 9, 11, 1, 3, 14, 1, 2, 3, 7, 2, 10, 23, 9
	DB	4, 2, 7, 6, 5, 1, 6, 3, 12, 2, 3, 4, 11, 18, 7
	DB	3, 11, 6, 3, 7, 8, 1, 6, 14, 4, 2, 4, 3, 2, 9
	DB	4, 11, 4, 2, 3, 15, 6, 1, 9, 6, 6, 9, 6, 9, 3
	DB	2, 1, 2, 3, 7, 2, 18, 3, 27, 3, 3, 4, 5, 6, 7
	DB	2, 1, 5, 1, 3, 11, 1, 14, 7, 3, 2, 4, 18, 3, 2
	DB	3, 12, 12, 1, 2, 1, 6, 5, 19, 2, 13, 14, 1, 5, 9
	DB	21, 7, 5, 10, 8, 1, 3, 3, 3, 11, 10, 3, 5, 3, 10
	DB	2, 1, 6, 3, 5, 1, 5, 1, 11, 7, 5, 6, 6, 1, 5
	DB	7, 6, 2, 7, 2, 4, 5, 1, 9, 6, 5, 15, 1, 3, 12
	DB	5, 4, 5, 1, 5, 9, 3, 12, 3, 1, 9, 5, 1, 6, 3
	DB	3, 9, 18, 3, 2, 7, 6, 3, 5, 7, 5, 7, 15, 3, 5
	DB	3, 10, 6, 9, 11, 6, 4, 3, 2, 6, 7, 2, 21, 15, 4
	DB	14, 6, 3, 3, 3, 4, 5, 10, 6, 2, 9, 3, 7, 5, 3
	DB	6, 1, 9, 2, 4, 8, 1, 5, 7, 2, 6, 16, 3, 3, 3
	DB	2, 7, 2, 6, 4, 3, 6, 5, 4, 5, 1, 5, 4, 2, 1
	DB	2, 15, 10, 2, 3, 3, 3, 1, 9, 11, 1, 2, 7, 21, 8
	DB	6, 3, 6, 1, 5, 4, 20, 15, 4, 2, 6, 4, 9, 2, 4
	DB	3, 3, 5, 3, 1, 3, 5, 1, 5, 12, 9, 9, 1, 3, 3
	DB	8, 9, 3, 4, 3, 8, 4, 8, 3, 3, 6, 3, 1, 6, 8
	DB	1, 6, 5, 1, 2, 12, 13, 5, 7, 5, 3, 18, 12, 1, 27
	DB	5, 7, 8, 3, 10, 6, 5, 3, 6, 1, 6, 2, 13, 2, 7
	DB	5, 3, 1, 2, 3, 1, 5, 1, 8, 6, 9, 9, 7, 8, 1
	DB	9, 3, 14, 1, 2, 1, 5, 6, 10, 6, 2, 3, 3, 10, 11
	DB	1, 2, 10, 8, 12, 1, 2, 3, 1, 21, 3, 2, 9, 3, 6
	DB	4, 2, 1, 3, 9, 3, 12, 2, 9, 9, 1, 5, 1, 20, 1
	DB	5, 15, 4, 9, 11, 1, 5, 4, 8, 6, 15, 4, 3, 3, 5
	DB	6, 3, 1, 9, 2, 15, 4, 5, 7, 2, 3, 4, 15, 3, 5
	DB	7, 9, 5, 9, 3, 4, 11, 4, 3, 8, 13, 11, 6, 3, 4
	DB	6, 5, 10, 5, 10, 9, 2, 6, 9, 16, 2, 1, 9, 2, 3
	DB	6, 4, 3, 3, 5, 4, 11, 6, 1, 3, 2, 7, 5, 10, 2
	DB	1, 14, 1, 5, 4, 9, 6, 3, 8, 4, 3, 5, 12, 3, 6
	DB	4, 2, 1, 2, 10, 15, 2, 6, 7, 2, 4, 2, 10, 5, 12
	DB	12, 6, 4, 5, 6, 10, 3, 2, 3, 4, 2, 10, 23, 10, 5
	DB	12, 1, 5, 3, 4, 3, 9, 5, 1, 5, 3, 7, 9, 8, 1
	DB	14, 7, 3, 2, 1, 3, 14, 1, 2, 3, 1, 6, 2, 30, 1
	DB	2, 7, 6, 6, 3, 6, 2, 10, 8, 6, 1, 9, 3, 5, 12
	DB	16, 5, 13, 2, 3, 7, 3, 2, 7, 2, 9, 7, 3, 5, 1
	DB	3, 2, 1, 5, 3, 10, 2, 12, 3, 22, 5, 1, 5, 16, 14
	DB	1, 3, 2, 6, 7, 6, 12, 5, 15, 4, 3, 3, 2, 1, 6
	DB	5, 4, 17, 7, 2, 3, 6, 1, 5, 6, 9, 4, 9, 6, 2
	DB	4, 9, 5, 7, 9, 6, 2, 6, 4, 8, 3, 6, 6, 9, 13
	DB	5, 1, 9, 6, 6, 20, 3, 10, 2, 3, 6, 1, 5, 4, 5
	DB	7, 2, 3, 7, 2, 3, 7, 3, 3, 5, 12, 6, 1, 6, 5
	DB	4, 21, 12, 5, 1, 11, 3, 1, 2, 4, 9, 2, 19, 5, 1
	DB	3, 2, 4, 3, 2, 3, 10, 6, 9, 5, 10, 2, 6, 4, 11
	DB	13, 6, 6, 2, 1, 2, 4, 8, 7, 18, 2, 3, 3, 7, 2
	DB	4, 5, 19, 12, 6, 5, 7, 2, 6, 4, 3, 2, 1, 3, 9
	DB	12, 3, 2, 16, 9, 5, 1, 9, 5, 6, 15, 4, 6, 5, 3
	DB	7, 3, 2, 4, 3, 2, 10, 21, 2, 6, 6, 3, 1, 27, 5
	DB	10, 3, 6, 3, 11, 21, 1, 2, 7, 14, 1, 11, 10, 5, 3
	DB	9, 3, 13, 9, 5, 1, 11, 3, 1, 6, 5, 3, 6, 1, 3
	DB	2, 10, 5, 6, 10, 5, 13, 2, 10, 12, 3, 14, 3, 3, 7
	DB	11, 6, 4, 15, 2, 4, 3, 2, 3, 1, 14, 3, 3, 4, 3
	DB	3, 5, 1, 5, 6, 3, 1, 3, 5, 3, 3, 4, 8, 9, 13
	DB	5, 1, 9, 3, 3, 5, 4, 3, 2, 18, 4, 5, 10, 11, 3
	DB	9, 12, 6, 7, 3, 23, 6, 1, 3, 14, 3, 3, 7, 8, 6
	DB	1, 5, 4, 8, 1, 9, 8, 7, 2, 10, 5, 3, 6, 1, 3
	DB	2, 13, 6, 2, 3, 6, 1, 9, 3, 6, 6, 3, 3, 2, 3
	DB	3, 10, 5, 1, 14, 1, 6, 14, 4, 2, 9, 4, 14, 1, 2
	DB	3, 4, 3, 5, 12, 15, 1, 6, 3, 23, 3, 6, 1, 2, 10
	DB	2, 6, 3, 12, 10, 8, 1, 5, 4, 5, 1, 5, 1, 2, 3
	DB	4, 5, 6, 7, 6, 6, 11, 3, 4, 8, 3, 1, 3, 21, 9
	DB	3, 2, 6, 6, 1, 3, 17, 7, 2, 3, 1, 2, 10, 14, 3
	DB	7, 9, 11, 1, 8, 10, 2, 3, 4, 2, 4, 11, 3, 1, 5
	DB	4, 5, 1, 2, 3, 7, 14, 3, 1, 2, 7, 11, 1, 5, 1
	DB	14, 18, 6, 7, 2, 6, 4, 3, 3, 12, 5, 19, 6, 17, 3
	DB	4, 8, 1, 9, 8, 3, 4, 2, 16, 9, 3, 8, 4, 3, 6
	DB	2, 3, 4, 6, 11, 3, 10, 12, 6, 8, 1, 5, 6, 9, 6
	DB	3, 1, 3, 6, 12, 2, 15, 3, 3, 7, 2, 1, 5, 10, 5
	DB	1, 6, 8, 4, 5, 6, 4, 3, 3, 12, 2, 3, 4, 8, 3
	DB	13, 5, 15, 1, 5, 1, 3, 2, 3, 1, 3, 12, 3, 3, 3
	DB	15, 20, 7, 2, 10, 2, 3, 6, 6, 1, 8, 7, 27, 15, 6
; Location of "DB 0" in version 28.9 (tested on Skylake with AVX2 factoring)
DB 0
IFDEF FOO
	DB	2, 4, 3, 11, 1, 6, 9, 9, 2, 4, 0
ENDIF

	;; Align so that other GWDATA areas are aligned on a cache line
	align 128
_GWDATA ENDS


initsize	EQU	7*11*13*17	; First 4 primes cleared in initsieve
initcount	EQU	4		; Count of primes cleared in initsieve
sievesize	EQU	00003000h	; 12KB sieve

;; Debugging macros

debug	MACRO ops:vararg
	IFDEF GDEBUG
	&ops
	ENDIF
	ENDM

assert	MACRO jcond
	LOCAL	ok
	IFDEF GDEBUG
	jcond	short ok
	sub	rsp, rsp
	pop	rax
ok:
	ENDIF
	ENDM


_TEXT	SEGMENT

; setupf (struct facasm_data *)
;	Initialize 64-bit factoring code
; Windows 64-bit (setupf)
;	Parameter ptr = rcx
; Linux 64-bit (setupf)
;	Parameter ptr = rdi

PROCF	setupf
	ad_prolog 0,0,rbx,rbp,rsi,rdi

; Compute various constants and addresses

	mov	rax, primearray
	add	rax, initcount*12
	mov	primearray12, rax

; Copy byte based prime array to double word based array

	mov	rsi, OFFSET sivinfo	; Source - array of bytes
	mov	rdi, primearray		; Destination - array of double words
	mov	rbx, 5			; Sivinfo contains primes larger than 5
	sub	rcx, rcx
initlp:	mov	cl, [rsi]
	and	cl, cl			; Test for end of table
	jz	short tabend
	add	rbx, rcx
	add	rbx, rcx
	cmp	rbx, sievesize*8	; Past maximum prime?
	jge	short tabend
	mov	[rdi], ebx		; Save the small prime
	xor	rdx, rdx		; Compute minimum number of bits in
	mov	eax, sievesize*8	; sieve that will be cleared
	div	rbx
	mov	[rdi+4], eax
	inc	rsi			; Next table entry
	lea	rdi, [rdi+12]		; Next primearray entry
	jmp	short initlp
tabend:	sub	rcx, rcx
	mov	[rdi], ecx		; Zero marks last entry

; Fill initsieve array with ones.  We make the table bigger than "necessary"
; so that filling the sieve can be done in one blast.

	mov	rax, -1
	mov	rcx, initsize + sievesize / 8
	mov	rdi, initsieve
	rep	stosq

; Clear the bits associated with the first 4 primes

	mov	rsi, primearray		; Ptr to first small prime
	mov	rdi, initsieve		; Address of initial sieve
	mov	rbx, sieve		; Used for temporary storage
ilp1:	mov	ecx, [rsi]		; Load small prime
	sub	rax, rax
ilp2:	btr	[rdi], rax		; Clear the bit
	add	rax, rcx		; Next bit #
	cmp	rax, initsize*64+sievesize*8; Past end of the init area?
	jb	short ilp2
	sub	rax, rax		; Save bit# (zero because the first
	mov	[rbx], eax		; in initsieve was cleared for all
					; small primes)
	mov	rax, 64			; Compute p - 64 mod p.  This value
ilp3:	sub	rax, rcx		; represents the bit# in the next
	jns	short ilp3		; word that was cleared for the
	neg	rax	    		; given small prime.  For example,
	mov	[rbx+4], eax		; 3 - 64 mod 3 = 2.  Thus, the 2nd
	add	rbx, 8			; bit in the second initsieve qword was
					; cleared by small prime 3.
	lea	rsi, [rsi+12]		; Next primearray entry
	cmp	rsi, primearray12	; Another small prime?
	jnz	short ilp1

; Fill lookup table into initsieve

	sub	rdi, rdi		; The first lookup points to the
	sub	rax, rax		; first entry in initsieve
ilp4:	mov	rsi, initlookup		; Set lookup table entry
	mov	[rsi][rax*4], edi	; Set lookup table entry
	inc	rdi			; Point to next initsieve dword
	mov	rsi, sieve		; Array of 64 mod p info
	mov	rbx, primearray		; Ptr to first small prime
	sub	rax, rax		; Build the index in eax
ilp5:	mov	ecx, [rbx]		; Load the small prime
	mul	rcx			; Multiply index by the small prime
	mov	edx, [rsi]		; Load bit#
	add	edx, [rsi+4]		; Compute bit# in next dword
ilp6:	sub	rdx, rcx		; Compute bit# mod smallp
	jns	short ilp6
	add	rdx, rcx
	mov	[rsi], edx		; Save bit# for next pass
	add	rax, rdx		; Add the bit# to the index
	lea	rsi, [rsi+8]
	lea	rbx, [rbx+12]		; Next primearray entry
	cmp	rbx, primearray12	; Last small prime?
	jne	short ilp5
	test	rax, rax		; Is lookup table completely built?
	jnz	short ilp4

; Return

	ad_epilog 0,0,rbx,rbp,rsi,rdi
setupf	ENDP


; factor64_pass_setup (struct facasm_data *)
;	Do setup required when starting a new mod 120 pass
; Windows 64-bit (factor64_pass_setup)
;	Parameter ptr = rcx
; Linux 64-bit (factor64_pass_setup)
;	Parameter ptr = rdi

PROCF	factor64_pass_setup
	ad_prolog 0,0,rbx,rbp,rsi,rdi

; First trial factor is first number of the form 2kp + 1
; greater than FACMSW * 2^32

	mov	edi, FACHSW		; Start point * 2^64
	mov	ebx, FACMSW		; Start point * 2^32
	shl	rbx, 32

	mov	rcx, twop		; Load twop for dividing
	mov	rax, rdi		; Do a mod on the start point
	xor	rdx, rdx
	div	rcx
	mov	rax, rbx
	div	rcx			
	sub	rcx, rdx		; Subtract remainder from twop
	inc	rcx			; and add 1 to find first test factor
	add	rbx, rcx
	adc	rdi, 0

; Make sure we have a factor with the right modulo for this pass

	mov	esi, FACPASS		; Get the pass number (0 to 15)
	mov	rbp, 120
flp1:	mov	rax, rdi		; Do a mod 120 in two parts
	xor	rdx, rdx
	div	rbp
	mov	rax, rbx		; Do a mod 120
	div	rbp
	mov	rax, OFFSET rems
	cmp	rdx, [rax+rsi*8]	; Is this the desired remainder
	jz	short flp2		; Yes, jump to flp2
	add	rbx, twop		; No, try next factor
	adc	rdi, 0
	jmp	short flp1		; Loop
flp2:	mov	savefac0, rdi
	mov	savefac1, rbx

; Loop through all the small primes determining sieve bit to clear

testp	EQU	rbp
prev	EQU	rbx
cur	EQU	rcx
bigrem	EQU	rdi
litrem	EQU	r8

	mov	rsi, primearray
smlp:	mov	ebp, [rsi]
	and	testp, testp
	jz	smdn
	cmp	testp, p
	jne	short smok
	mov	DWORD PTR [rsi], 0
	jmp	short smdn
smok:

;
; Let testp = an entry from our small primes array
; Let y = facdist mod testp
; Use Euclid's greatest common denominator algorithm to compute the number
; x such that x * y = -1 MOD testp
; We can then use x to compute the first bit in the sieve array that needs
; clearing.
;

	sub	prev, prev		; Set up: set bigrem = testp,
	mov	cur, 1			; litrem = facdist mod testp
	mov	bigrem, testp
	sub	rdx, rdx
	mov	rax, facdists+8
	div	bigrem
	mov	litrem, rdx
euclp:	cmp	litrem, 1		; Loop ends when litrem equals 1
	je	short eucdn
	sub	rdx, rdx		; Compute bigrem mod litrem
	mov	rax, bigrem
	div	litrem
	mov	bigrem, litrem
	mov	litrem, rdx
	imul	cur
	sub	prev, rax
	xchg	prev, cur
	jmp	short euclp
eucdn:	neg	cur			; set x = -cur if cur was negative
	jns	short eucdn2
	add	cur, testp		; else set x = testp - cur
eucdn2:	sub	rdx, rdx		; Divide first factor by testp
	mov	rax, savefac0
	div	testp
	mov	rax, savefac1
	div	testp
	mov	rax, rdx		; Multiply remainder by x
	mul	cur
	div	testp			; rdx now contains the bit number!
	mov	[rsi+8], edx		; Save that bit number!
	lea	rsi, [rsi+12]		; Next primearray entry
	jmp	smlp
smdn:

; Use the initlookup table to determine the first dword in initsieve to copy

	mov	rsi, primearray		; Ptr to first small prime
	sub	rax, rax		; Build the index in rax
lk1:	mul	DWORD PTR [rsi]		; Multiply index by the small prime
	add	eax, [rsi+8]		; Add the bit# to the index
	lea	rsi, [rsi+12]
	cmp	rsi, primearray12	; Last small prime?
	jne	short lk1
	mov	rsi, initlookup		; Load the lookup table address
	mov	eax, [rsi][rax*4]	; Load the initsieve start offset
	mov	initstart, eax		; Save the initsieve start offset

; Pre-square the number as much as possible.  We have separate code
; paths for single-word and double-word trial factors.

	mov	rbx, savefac0		; Load factor
	mov	rcx, savefac1
	and	rbx, rbx		; Test MSW
	jz	short psq64		; If zero, presquaring 64-bits or less

; This is the 65-bits and above presquare code.
; Calculate number of bits in the trial factor

	bsr	rax, rbx		; Look for highest set bit
	mov	rdx, 63			; Create shift count
	sub	rdx, rax
	mov	shift_count, rdx	; Save shift count for squaring loop

; Compute the two shift counts used in 66-bit factoring.  The counts for
; 66-bits is (33-1)*256+1, for 67-bits is (33-2)*256+2, etc.

	mov	rbx, 33
	sub	rbx, rax
	shl	rbx, 8
	add	rbx, rax
	mov	shift66, rbx

; Pre-square the number as much as possible.  We could push this a little
; further because the tlp65 and tlp66 code doesn't really care that the
; first remainder is larger than the trial factor.

	add	rax, 147		; Compute maximum size of initval
	mov	rcx, p			; Load p
	sub	rbx, rbx		; This will be the shifter
setlp:	shrd	rbx, rcx, 1		; Move bits from p to shifter
	shr	rcx, 1			; Remove bit from p
	cmp	rcx, rax		; Is p > max initval
	jg	short setlp		; Yes, keep shifting
	mov	shifter, rbx		; Save shifter
	sub	rcx, 64			; Compute initval = 2^(rcx-64)
	jmp	short psqdn		; Join common presquare code

; Same code as above, but for 64-bit factors
; Calculate number of bits in the trial factor

psq64:	bsr	rax, rcx		; Look for highest set bit
	mov	rdx, 63			; Create shift count
	sub	rdx, rax
	mov	shift_count, rdx	; Save shift count for squaring loop

; Pre-square the number as much as possible.  That is, make sure initval
; divided by trail factor will not result in a 65-bit quotient.  The 64-bit
; factoring code can handle one more bit than 63-bit and less code.

	add	rax, 63			; Compute maximum size of initval
	sub	rbx, rbx		; Set rbx to 1 if 64-bit factors
	shld	rbx, rcx, 1
	add	rax, rbx		; Inc max initval size if 64-bit factor
	mov	rcx, p			; Load p
	sub	rbx, rbx		; This will be the shifter
setlp64:shrd	rbx, rcx, 1		; Move bits from p to shifter
	shr	rcx, 1			; Remove bit from p
	cmp	rcx, rax		; Is p > max initval
	jg	short setlp64		; Yes, keep shifting
	mov	shifter, rbx		; Save shifter

; Common pre-square cleanup code

psqdn:	mov	rax, 127		; Compute initial shift count
	sub	rax, rcx
	sub	rax, shift_count
	mov	initshift, rax		; Save initial shift count
	mov	rdx, shift66		; Compute alternate initial shift count
	shr	rdx, 8
	add	rax, rdx
	mov	initshift2, rax		; Save alternate initial shift count
	mov	rax, 1			; Compute initval = 2^rcx
	xor	rdx, rdx
	and	rcx, rcx
	jz	short shfdn
shflp:	shld	rdx, rax, 1
	shl	rax, 1
	dec	rcx
	jnz	short shflp
shfdn:	mov	initval0, rdx		; Save initval
	mov	initval1, rax
	mov	rcx, shift_count	; Compute initdiv = 2^(63-shift_count)
	mov	rbx, 1
	shl	rbx, 63
	shr	rbx, cl
	mov	initdiv0, rbx		; Save initdiv
	inc	rcx			; Increase shift_count because only
	mov	shift_count, rcx	; 2^63 / factor fits in 64 bits.  This
					; extra shift will give us the right
					; number of bits in a quotient
	ad_epilog 0,0,rbx,rbp,rsi,rdi
factor64_pass_setup ENDP


; factor64_small (struct facasm_data *)
;	Trial divide for small factors without using a sieve.  Recommended for TF below 2^44.
; Windows 64-bit (factor64_small)
;	Parameter ptr = rcx
; Linux 64-bit (factor64_small)
;	Parameter ptr = rdi

PROCF	factor64_small
	ad_prolog 0,0,rbx,rbp,rsi,rdi

;
; Brute force code to find small factors of 2**p - 1.  It works
; for trial factors of 63-bits or less.  However, the sieving algorithm
; is better if you are planning on testing a lot of trial factors.  So we
; only use this for 44-bit factors.
;

	mov	rcx, p
smslp:	add	rcx, rcx		; Shift until top bit on
	jns	short smslp
	mov	r8, rcx			; Compute shifter in r8
	shl	r8, 6
	shr	rcx, 58			; Compute initial value(?) in r9
	mov	r9, 1
	shl	r9, cl

; First trial factor is 2p + 1

	mov	rcx, twop
	inc	rcx

; If factor = 3 or 5 mod 8, then it can't be a factor of 2**p - 1

	mov	rdi, smfacendpt
smtest:	mov	rax, rcx
	and	al, 6
	jz	short smdoit
	cmp	al, 6
	jnz	short smnext

; Square the number until we computed 2**p MOD factor

smdoit:	mov	rbx, r8
	mov	rax, r9
	sub	rdx, rdx
	div	rcx
smloop:	mov	rax, rdx		; Square remainder
	mul	rax
	div	rcx			; Divide squared rem by trial factor
	add	rbx, rbx
	jnc	short smloop
	jz	short smexit
	add	rdx, rdx		; Double remainder
	jmp	short smloop

; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1

smexit:	add	rdx, rdx
	dec	rdx
	cmp	rdx, rcx
	jz	short smwin

; Try next possible factor

smnext:	add	rcx, twop
	cmp	rcx, rdi
	jl	short smtest

; No small factor found - return for ESC check

	mov	rax, 2			; Return for ESC check
	shr	rdi, 32
	mov	FACMSW, edi		; Restart after endpt
	jmp	short smdone

; Divisor found, return TRUE

smwin:	mov	rax, 1
	mov	FACLSW, ecx
	shr	rcx, 32
	mov	FACMSW, ecx
	jmp	short smdone

; Pop registers and return

smdone:	ad_epilog 0,0,rbx,rbp,rsi,rdi

factor64_small ENDP


; factor64_sieve (struct facasm_data *)
;	Sieve one 12KB chunk to eliminate potential factors that are not prime
; Windows 64-bit (factor64_sieve)
;	Parameter ptr = rcx
; Linux 64-bit (factor64_sieve)
;	Parameter ptr = rdi

PROCF	factor64_sieve
	ad_prolog 0,0,rbx,rbp,rsi,rdi

;
; Init the sieve
;

initsv:	mov	rdi, sieve		; Load sieve address
	mov	rsi, initsieve		; Load sieve initialization bits addr
	mov	edx, initstart		; Load qword offset into initsieve
	lea	rsi, [rsi][rdx*8]	; Compute copy address
	mov	rcx, sievesize / 8	; Count of qwords to copy
	rep	movsq			; Copy the qwords
	add	rdx, sievesize / 8	; Compute next initsieve start offset
	cmp	rdx, initsize		; Compare to table's end address
	jle	short startok		; Jump if still within table
	sub	rdx, initsize		; Get address back in line
startok:mov	initstart, edx		; Save start position for next time

;
; Loop through the small prime array, clearing sieve bits.
;

	mov	rdi, sieve		; Load address of sieve bits
	mov	rbp, primearray12	; Ptr to first prime in array
sievelp:mov	ebx, [rbp]		; Load small prime
	and	rbx, rbx		; See if primearray fully processed
	jz	short sievedn		; Yes, break out of loop
	mov	ecx, [rbp+4]		; Load count of bits to clear
	mov	eax, [rbp+8]		; Load bit offset to clear
clrlp:	btr	[rdi], rax		; Clear the sieve bit
	add	rax, rbx		; Next bit to clear
	dec	rcx			; Test count of bits to clear
	jnz	short clrlp
	cmp	rax, sievesize*8	; Past the end of the sieve?
	jae	short noclr		; Yes, skip one last clear
	btr	[rdi], rax		; Clear one final sieve bit
	add	rax, rbx		; Next bit to clear
noclr:	sub	rax, sievesize*8	; Calculate next sieve's bit to clear
	mov	[rbp+8], eax		; Save bit clear offset for next time
	lea	rbp, [rbp+12]		; Next primearray address
	jmp	short sievelp		; Work on next small prime

; Bump the first factor in sieve for the caller (caller looks at the value to decide if more sieving is needed)

sievedn:
	mov	rax, facdist12K
	add	savefac1, rax
	adc	savefac0, 0

; Pop registers and return

	ad_epilog 0,0,rbx,rbp,rsi,rdi

factor64_sieve ENDP


; factor64_tf (struct facasm_data *)
;	Take a pre-sieved array and test potential factors
; Windows 64-bit (factor64_tf)
;	Parameter ptr = rcx
; Linux 64-bit (factor64_tf)
;	Parameter ptr = rdi

PROCF	factor64_tf
	ad_prolog 0,0,rbx,rbp,rsi,rdi,r12,r13,r14,r15,xmm6,xmm7,xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15

; Branch to proper code to do the TF

	mov	rbx, savefac0		; Load trial factor corresponding
	mov	rcx, savefac1		; to first sieve bit
	and	rbx, rbx		; Are we testing 65+ bit factors?
	jz	short oneword		; No, go do 64 bits or less

	test	CPU_FLAGS, 20000h	; Is this an AVX2 machine?
	jz	short notavx2		; No, use non-AVX2 code
	cmp	rbx, 400h		; Are we testing 75+ bit numbers?
	jge	atlp86			; Yes, use 75-86 bit AVX2 code
	jmp	atlp74			; No, use 65-74 bit AVX2 code

notavx2:
	test	CPU_FLAGS, 200h		; Is this an SSE2 machine?
	jz	short notsse2		; No, use non-SSE2 code
	cmp	rbx, 400h		; Are we testing 75+ bit numbers?
	jge	tlp86			; Yes, use 75-86 bit SSE2 code
	jmp	tlp74			; No, use 65-74 bit SSE2 code

notsse2:
	cmp	rbx, 1			; Are we testing 66+ bit factors?
	jg	tlp66			; Yes, go do it
	je	tlp65			; Jump if testing 65 bit factors?

oneword:
	mov	rax, rcx
	shr	rax, 58			; Testing 58 bit or less factors?
	jz	tlp58			; Yes, go test 58-bit factors
	shr	rax, 2			; Testing 60 bit or less factors?
	jz	tlp60			; Yes, go test 60-bit factors
	shr	rax, 1			; Testing 61 bit or less factors?
	jz	tlp61			; Yes, go test 61-bit factors
	shr	rax, 1			; Testing 62 bit or less factors?
	jz	tlp62			; Yes, go test 62-bit factors
	shr	rax, 1			; Testing 63 bit or less factors?
	jz	tlp63			; Yes, go test 63-bit factors
	jmp	tlp64			; No, go test 64-bit factors

;
; Make register assignments for one word remainders
;

facinv1	EQU	r13
facinv2	EQU	facinv2_in_memory	;; Formerly r11
facinv3	EQU	r15
temp3	EQU	rdi
rem3	EQU	r8
fac3reg	EQU	r9
temp2	EQU	r10
rem2	EQU	r14
fac2reg	EQU	r12
temp1	EQU	rbp
rem1	EQU	rbx
fac1reg	EQU	rsi

;
; Make different register assignments for two word remainders
;

rem3hi	EQU	rem3
rem3lo	EQU	fac3reg
rem2hi	EQU	rem2
rem2lo	EQU	fac2reg
rem1hi	EQU	rem1
rem1lo	EQU	fac1reg

;***********************************************************************
; Test up to 58 bit factors (actually handles most 59 bit factors too)
;***********************************************************************

tlp58:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
svlp58:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf58:	bsf	rdx, rax		; Look for a set bit
	jnz	short test58		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp58		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem58		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem58:	mov	r8, fac1		; Copy first trial factor in queue
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem58		; No, go copy another
	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf58
	jmp	short do58		; Go test the potential factors

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test58:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf58			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do58:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; zero and 6 * factor.  The squared remainder is up to 36 * factor^2.  The 
; quotient is up to 36 * factor.  For the shrd value to fit in 64 bits, the
; maximum factor is 2^63 / 36 = 2^57.  However, this estimate is too
; pessimistic.  It can be shown that the quotient is off by 2 only when facinv
; is large.  When facinv is large, the factor is small, and there is one fewer
; bit in the squared remainder, allowing 58 bits to work safely. 
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp58:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

;
; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.   Multiply by two if necessary, making the remainder
; between zero and 6 * factor.  Test for end of squaring loop
;

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp58			; If mul by 2 not needed, jump to loop
	jz	short exit58		; Are we done squaring?
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2		; Multiply remainder by 2
	add	rem3, rem3		; Multiply remainder by 2
	jmp	sqlp58			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit58:	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and 2*fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and 2*fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	sub	rcx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rcx
	sub	rdx, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win58
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win58a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win58b

	sub	rdi, rdi		; Clear queued factors count

	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf58			; Test next factor from sieve

win58:	mov	rax, fac1reg
	jmp	short win58c
win58a:	mov	rax, fac2reg
	jmp	short win58c
win58b:	mov	rax, fac3reg
win58c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test up to 60 bit factors
;***********************************************************************

tlp60:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 60
	xor	rdi, rdi		; Count of queued factors to be tested
svlp60:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf60:	bsf	rdx, rax		; Look for a set bit
	jnz	short test60		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp60		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem60a		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 60-bit overflow

oflow60:and	rdi, rdi		; Are there untested factors?
	jnz	short rem60		; Yes, go do remaining trial factors
	mov	FACMSW, 10000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem60a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf60
rem60:	mov	r8, fac1		; Copy first trial factor in queue
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem60		; No, go copy another
	jmp	short do60		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test60:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	cmp	r8, rbx			; Test for 60-bit overflow
	jae	short oflow60		; Jump if 60-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf60			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do60:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -2 * factor and 4 * factor.  The squared remainder is up to 16 * factor^2.
; quotient is up to 16 * factor.  For the shrd value to fit in 64 bits, the
; maximum factor is 2^63 / 16 = 2^59.  However, this estimate is too
; pessimistic.  It can be shown that the quotient is off by 2 only when facinv
; is large.  When facinv is large, the factor is small, there is one fewer
; bit in the squared remainder, allowing 60 bits to work safely. 
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp60:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Test for end of squaring loop.  Loop if doubling is
; not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp60			; Loop if mul by 2 not needed
	jz	short exit60		; Jump if we are done squaring

; Subtract factor so that remainder is between -1 * factor and 2 * factor.
; Multiply by two, making the remainder between -2 * factor and 4 * factor.

	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	jmp	sqlp60			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit60:	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and 2*fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and 2*fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	sub	rcx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rcx
	sub	rdx, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win60
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win60a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win60b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf60			; Test next factor from sieve

win60:	mov	rax, fac1reg
	jmp	short win60c
win60a:	mov	rax, fac2reg
	jmp	short win60c
win60b:	mov	rax, fac3reg
win60c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 61 bit factors
;***********************************************************************

tlp61:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 61
	xor	rdi, rdi		; Count of queued factors to be tested
svlp61:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf61:	bsf	rdx, rax		; Look for a set bit
	jnz	short test61		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp61		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem61a		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 61-bit overflow

oflow61:and	rdi, rdi		; Are there untested factors?
	jnz	short rem61		; Yes, go do remaining trial factors
	mov	FACMSW, 20000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem61a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf61
rem61:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem61		; No, go copy another
	jmp	short do61		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test61:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	cmp	r8, rbx			; Test for 61-bit overflow
	jae	short oflow61		; Jump if 61-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf61			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do61:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -2 * factor and 2 * factor.  The squared remainder is up to 4 * factor^2.
; The quotient is up to 4 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 4, or 2^61.
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp61:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and 2 * factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp61			; Loop if mul by 2 not needed
	jz	short exit61		; Jump if we are done squaring

; Subtract factor so that remainder is between -1 * factor and 1 * factor.
; Multiply by two, making the remainder between -2 * factor and 2 * factor.

	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	jmp	sqlp61			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit61:	mov	rax, rem1		; Make rem1 between 0 and fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win61
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win61a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win61b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf61			; Test next factor from sieve

win61:	mov	rax, fac1reg
	jmp	short win61c
win61a:	mov	rax, fac2reg
	jmp	short win61c
win61b:	mov	rax, fac3reg
win61c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 62 bit factors
;***********************************************************************

tlp62:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 62
	xor	rdi, rdi		; Count of queued factors to be tested
svlp62:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf62:	bsf	rdx, rax		; Look for a set bit
	jnz	short test62		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp62		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem62a		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 62-bit overflow

oflow62:and	rdi, rdi		; Are there untested factors?
	jnz	short rem62		; Yes, go do remaining trial factors
	mov	FACMSW, 40000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem62a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf62
rem62:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem62		; No, go copy another
	jmp	short do62		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test62:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	cmp	r8, rbx			; Test for 62-bit overflow
	jae	short oflow62		; Jump if 62-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf62			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do62:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -1 * factor and 1 * factor.  The squared remainder is up to 1 * factor^2.
; The quotient is up to 1 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 1, or 2^63.  So that is not a limitation.
; Instead we are limited by the fact that quotient can be off by 2, giving
; us problems fitting the remainder in 64 bits.  The maximum factor is
; 2^64 / 3 = 2^62.
;

	mov	temp1, shifter		; Load shifter
sqlp62:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv1			; Compute quotient
	imul	rdx, fac1reg 		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv2			; Compute quotient
	imul	rdx, fac2reg 		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv3			; Compute quotient
	imul	rdx, fac3reg 		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	cmovns	rem2, rdx
	sub	rdx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	cmovns	rem3, rax
	sub	rax, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp62			; Loop if mul by 2 not needed
	jz	short exit62		; Jump if we are done squaring

; Multiply by two, making the remainder between 0 and 2 * factor.
; Subtract factor so that remainder is between -1 * factor and 1 * factor.

	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	jmp	sqlp62			; Do next iteration

; Multiply remainder by two one last time (for the last carry out of shifter).
; If result = 1 mod factor, then we found a divisor of 2^p - 1

exit62:

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win62
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win62a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win62b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf62			; Test next factor from sieve

win62:	mov	rax, fac1reg
	jmp	short win62c
win62a:	mov	rax, fac2reg
	jmp	short win62c
win62b:	mov	rax, fac3reg
win62c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 63 bit factors
;***********************************************************************

tlp63:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
svlp63:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf63:	bsf	rdx, rax		; Look for a set bit
	jnz	short test63		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp63		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem63a		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 63-bit overflow

oflow63:and	rdi, rdi		; Are there untested factors?
	jnz	short rem63		; Yes, go do remaining trial factors
	mov	FACMSW, 80000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem63a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf63
rem63:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem63		; No, go copy another
	jmp	short do63		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test63:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	js	short oflow63		; Jump if 63-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf63			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do63:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -1 * factor and 1 * factor.  The squared remainder is up to 1 * factor^2.
; The quotient is up to 1 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 1, or 2^63.  So that is not a limitation.
; Instead we are limited by the fact that quotient can be off by 2, giving
; us problems fitting the remainder in 64 bits.  The maximum factor is
; 2^64 / 3.  So unfortunately we must calculate full double word remainders.
;

	mov	rcx, shifter		; Load shifter
sqlp63:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	mov	temp1, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv1			; Compute quotient
	mov	rax, fac1reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem1, rax		; Subtract from squared remainder
	sbb	temp1, rdx

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	mov	temp2, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv2			; Compute quotient
	mov	rax, fac2reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem2, rax		; Subtract from squared remainder
	sbb	temp2, rdx

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	mov	temp3, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv3			; Compute quotient
	mov	rax, fac3reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem3, rax		; Subtract from squared remainder
	sbb	temp3, rdx

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	sbb	temp1, 0
	cmovns	rem1, rax
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	sbb	temp1, 0
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	sbb	temp2, 0
	cmovns	rem2, rdx
	sub	rdx, fac2reg		; Make rem2 between 0 and fac
	sbb	temp2, 0
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	sbb	temp3, 0
	cmovns	rem3, rax
	sub	rax, fac3reg		; Make rem3 between 0 and fac
	sbb	temp3, 0
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp63			; Loop if mul by 2 not needed
	jz	short exit63		; Jump if we are done squaring

; Multiply by two, making the remainder between 0 and 2 * factor.
; Subtract factor so that remainder is between -1 * factor and 1 * factor.

	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	jmp	sqlp63			; Do next iteration

; Multiply remainder by two one last time (for the last carry out of shifter).
; If result = 1 mod factor, then we found a divisor of 2^p - 1

exit63:

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win63
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win63a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win63b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf63			; Test next factor from sieve

win63:	mov	rax, fac1reg
	jmp	short win63c
win63a:	mov	rax, fac2reg
	jmp	short win63c
win63b:	mov	rax, fac3reg
win63c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; For 64-bit factors
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp64:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	div	rcx
	mov	facinv3, rax
svlp64:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf64:	bsf	rdx, rax		; Look for a set bit
	jnz	test64			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp64		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem64a		; Yes, test them

; Save state

	mov	savefac1, rcx		; Save for the restart or more sieving

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 64-bit overflow

oflow64:and	rdi, rdi		; Are there untested factors?
	jnz	short rem64		; Yes, go do remaining trial factors
	mov	FACMSW, 0		; Return end point
	mov	FACHSW, 1
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem64a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf64
rem64:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem64		; No, go copy another
	jmp	short do64		; Go test queued factors

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test64:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	jns	short oflow64		; Jump if 64-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf64			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do64:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.  Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rax, fac1
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

debug	mov	rem1lo, initval1
debug	and	rem1lo, rem1lo
assert	jz

	sub	rem1lo, rem1lo		; Load initial value
	sub	rem2lo, rem2lo
	sub	rem3lo, rem3lo

; Assuming the inverse factor is accurate to 40 bits, we must jump to
; the code that computes the quotient in two parts if the shift count
; is less than 24.

	cmp	cl, 24			; Will shift count yield < 40-bit quot?
	jge	short fast64		; Yes, do the fast first iteration

; This is the slow code to compute the first quotient and remainder.

	mov	temp1, facinv1		; Quotient = val * 1 / factor
	shr	temp1, cl
	mov	temp2, facinv2		; Quotient = val * 1 / factor
	shr	temp2, cl
	mov	temp3, facinv3		; Quotient = val * 1 / factor
	shr	temp3, cl

	mov	rem1hi, initval0	; Load high part of initval
	mov	rem2hi, rem1hi
	mov	rem3hi, rem1hi

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1			; First iteration does not double
	jmp	slow64			; Jump into middle of squaring loop

; This is the fast code to compute the quotients and remainders

fast64:	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac1			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from initval
debug	mov	rem1hi, initval0
debug	sbb	rem1hi, rdx
assert	jz

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac2			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from initval
debug	mov	rem2hi, initval0
debug	sbb	rem2hi, rdx
assert	jz

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac3			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from initval
debug	mov	rem3hi, initval0
debug	sbb	rem3hi, rdx
assert	jz

;
; Square remainders and get new remainders.  Input remainder must be less than
; factor.
;

	mov	rcx, shifter		; Load shifter
sqlp64:	mov	rax, rem1lo		; Load remainder
	mul	rem1lo			; Square remainder
	mov	rem1lo, rax		; Save squared remainder
	mov	rem1hi, rdx

	mov	rax, rem2lo		; Load remainder
	mul	rem2lo			; Square remainder
	mov	rem2lo, rax		; Save squared remainder
	mov	rem2hi, rdx

	mov	rax, rem3lo		; Load remainder
	mul	rem3lo			; Square remainder
	mov	rem3lo, rax		; Save squared remainder
	mov	rem3hi, rdx

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	lea	temp1, [rdx+rdx]	; Save quotient

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	lea	temp2, [rdx+rdx]	; Save quotient

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	lea	temp3, [rdx+rdx]	; Save quotient

slow64:	mov	rax, fac1
	mul	temp1			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	mov	temp1, rem1hi		; Shift for computing accurate quotient
	shld	temp1, rem1lo, 31
	mov	temp2, rem2hi
	shld	temp2, rem2lo, 31
	mov	temp3, rem3hi
	shld	temp3, rem3lo, 31

	mov	rax, temp1		; Quotient = val * 1 / factor
	mul	facinv1
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
	jz	short qok64		; Most of the time branch will be taken
assert	jns
	sub	rem1lo, fac1		; Handle rare quotient too small case
debug	sbb	rem1hi, 0
assert	jz
qok64:

	mov	rax, temp2		; Quotient = val * 1 / factor
	mul	facinv2
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
	jz	short qok64a		; Most of the time branch will be taken
assert	jns
	sub	rem2lo, fac2		; Handle rare quotient too small case
debug	sbb	rem2hi, 0
assert	jz
qok64a:

	mov	rax, temp3		; Quotient = val * 1 / factor
	mul	facinv3
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
	jz	short qok64b		; Most of the time branch will be taken
assert	jns
	sub	rem3lo, fac3		; Handle rare quotient too small case
debug	sbb	rem3hi, 0
assert	jz
qok64b:

; Remainder might still be too large due to the rare quotient too small case.
; If so fix the remainder.

	cmp	rem1lo, fac1		; Fix rem1 if necessary
	jb	ok64
	sub	rem1lo, fac1
ok64:	cmp	rem2lo, fac2		; Fix rem2 if necessary
	jb	ok64a
	sub	rem2lo, fac2
ok64a:	cmp	rem3lo, fac3		; Fix rem3 if necessary
	jb	ok64b
	sub	rem3lo, fac3
ok64b:

;
; Multiply by two if necessary, test for end of squaring loop
;

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp64			; Loop if a mul by 2 is not needed
	jz	short exit64		; Are we done squaring?

	lea	temp1, [rem1lo+rem1lo]	; Multiply remainder by 2
	sub	temp1, fac1
	add	rem1lo, rem1lo
	cmovc	rem1lo, temp1		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem1lo, fac1
	cmovae	rem1lo, temp1		; or if rem > fac, use rem*2-fac

	lea	temp2, [rem2lo+rem2lo]	; Multiply remainder by 2
	sub	temp2, fac2
	add	rem2lo, rem2lo	
	cmovc	rem2lo, temp2		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem2lo, fac2
	cmovae	rem2lo, temp2		; or if rem > fac, use rem*2-fac

	lea	temp3, [rem3lo+rem3lo]	; Multiply remainder by 2
	sub	temp3, fac3
	add	rem3lo, rem3lo
	cmovc	rem3lo, temp3		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem3lo, fac3
	cmovae	rem3lo, temp3		; or if rem > fac, use rem*2-fac

	jmp	sqlp64			; Do next squaring

; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1

exit64:

debug	cmp	rem1, fac1		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3		; Remainder should be < factor
assert	jb

	add	rem1lo, rem1lo		; Double the remainder
	add	rem2lo, rem2lo		; Double the remainder
	add	rem3lo, rem3lo		; Double the remainder

	mov	rax, fac1		; Load factor #1
	sub	rem1lo, rax		; Subtract factor
	dec	rem1lo
	jz	short win64
	mov	rax, fac2		; Load factor #2
	sub	rem2lo, rax		; Subtract factor
	dec	rem2lo
	jz	short win64
	mov	rax, fac3		; Load factor #3
	sub	rem3lo, rax		; Subtract factor
	dec	rem3lo
	jz	short win64

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf64			; Test next factor from sieve

win64:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1			; Return TRUE
	jmp	done

;***********************************************************************
; For 65-bit factors
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp65:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	ror	rcx, 1			; Form high 64-bits of factor
	inc	rcx			; ceiling (high 64-bits of factor)
	div	rcx
	dec	rcx
	rol	rcx, 1			; Restore lower 64-bits of factor
	mov	facinv3, rax
svlp65:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf65:	bsf	rdx, rax		; Look for a set bit
	jnz	test65			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	jc	short oflow65a		; Jump if overflow of 65 bits
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp65		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem65a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 65-bit overflow

oflow65a:mov	rcx, -1			; Reset rcx so that it will generate a carry if we test
					; factors already in the queue and branch to bsf65
oflow65:and	rdi, rdi		; Are there untested factors?
	jnz	short rem65		; Yes, go do remaining trial factors
	mov	FACMSW, 0		; Return end point
	mov	FACHSW, 2
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem65a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
					; it will be re-added when we branch back to bsf65
rem65:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem65		; No, go copy another
	jmp	short do65		; Go test queued factors

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test65:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	jc	short oflow65		; Jump if 65-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf65			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do65:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.   Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rax, fac1
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shifted count

	and	rcx, rcx		; If quotient will be small,
	jns	short fast65		; jump to go compute it.

	sub	rem1hi, rem1hi		; Load initial value
	sub	rem1lo, rem1lo
	sub	rem2hi, rem2hi
	sub	rem2lo, rem2lo
	sub	rem3hi, rem3hi
	sub	rem3lo, rem3lo

	mov	rcx, initshift2		; Compute first quotients
	mov	temp1, facinv1
	shr	temp1, cl
	mov	temp2, facinv2
	shr	temp2, cl
	mov	temp3, facinv3
	shr	temp3, cl

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1
	jmp	slow65			; Jump into middle of squaring loop

fast65:	mov	rem1hi, initval1	; Load initial value
	sub	rem1lo, rem1lo
	mov	rem2hi, rem1hi
	sub	rem2lo, rem2lo
	mov	rem3hi, rem1hi
	sub	rem3lo, rem3lo

	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem1hi, rax		; Subtract quotient * factor_hi
	mul	fac1			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from initval
	sbb	rem1hi, rdx
assert	jns

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem2hi, rax		; Subtract quotient * factor_hi
	mul	fac2			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from initval
	sbb	rem2hi, rdx
assert	jns

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem3hi, rax		; Subtract quotient * factor_hi
	mul	fac3			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from initval
	sbb	rem3hi, rdx
assert	jns

;
; Square remainders and get new remainders
;

	mov	rcx, shifter		; Load shifter
sqlp65:	mov	temp1, rem1hi		; Load remainder_hi
	imul	temp1, temp1		; Square remainder_hi

	mov	temp2, rem2hi		; Load remainder_hi
	imul	temp2, temp2		; Square remainder_hi

	mov	temp3, rem3hi		; Load remainder_hi
	imul	temp3, temp3		; Square remainder_hi

	add	rem1hi, rem1hi		; Double remainder_hi
	add	rem2hi, rem2hi		; Double remainder_hi
	add	rem3hi, rem3hi		; Double remainder_hi

	mov	rax, rem1lo		; Load remainder_lo
	mul	rem1lo			; Square remainder_lo
	xchg	rem1lo, rax		; Save squared remainder_lo
	xchg	rem1hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem1hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp1, rdx

	mov	rax, rem2lo		; Load remainder_lo
	mul	rem2lo			; Square remainder_lo
	xchg	rem2lo, rax		; Save squared remainder_lo
	xchg	rem2hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem2hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp2, rdx

	mov	rax, rem3lo		; Load remainder_lo
	mul	rem3lo			; Square remainder_lo
	xchg	rem3lo, rax		; Save squared remainder_lo
	xchg	rem3hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem3hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp3, rdx

	shld	temp1, rem1hi, 31	; Shift for computing quotient
	shld	temp2, rem2hi, 31
	shld	temp3, rem3hi, 31

	mov	rax, facinv1		; Quotient = val * 1 / factor
	mul	temp1
	mov	temp1, rdx		; Save quotient

	mov	rax, facinv2		; Quotient = val * 1 / factor
	mul	temp2
	mov	temp2, rdx		; Save quotient

	mov	rax, facinv3		; Quotient = val * 1 / factor
	mul	temp3
	mov	temp3, rdx		; Save quotient

slow65:	mov	rax, fac1
	mul	temp1			; Compute quotient * factor_lo
	add	rdx, temp1		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor_lo
	add	rdx, temp2		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor_lo
	add	rdx, temp3		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	sub	rem1hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	sub	rem2hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	sub	rem3hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

;
; Multiply by two if necessary, test for end of squaring loop
;

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp65			; Loop if a mul by 2 is not needed
	jz	short exit65		; Are we done squaring?
	add	rem1lo, rem1lo		; Multiply remainder by 2
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Multiply remainder by 2
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Multiply remainder by 2
	adc	rem3hi, rem3hi
	jmp	sqlp65			; Do next squaring

;
; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1
;

exit65:	add	rem1lo, rem1lo		; Double the remainder
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Double the remainder
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Double the remainder
	adc	rem3hi, rem3hi
	mov	rax, fac1		; Load factor #1
sub65:	sub	rem1lo, rax		; Subtract factor
	sbb	rem1hi, 1
	jns	short sub65		; Subtract until result is negative
	add	rem1lo, rax		; Make it positive
	adc	rem1hi, 1
	dec	rem1lo			; If one, its a factor
	jnz	short fail65
	and	rem1hi, rem1hi
	jz	short win65
fail65:	mov	rax, fac2		; Load factor #2
sub65a:	sub	rem2lo, rax		; Subtract factor
	sbb	rem2hi, 1
	jns	short sub65a		; Subtract until result is negative
	add	rem2lo, rax		; Make it positive
	adc	rem2hi, 1
	dec	rem2lo			; If one, its a factor
	jnz	short fail65a
	and	rem2hi, rem2hi
	jz	short win65
fail65a:mov	rax, fac3		; Load factor #3
sub65b:	sub	rem3lo, rax		; Subtract factor
	sbb	rem3hi, 1
	jns	short sub65b		; Subtract until result is negative
	add	rem3lo, rax		; Make it positive
	adc	rem3hi, 1
	dec	rem3lo			; If one, its a factor
	jnz	short next65
	and	rem3hi, rem3hi
	jz	short win65

next65:	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf65			; Test next factor from sieve

win65:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	FACHSW, 1
	mov	rax, 1			; Return TRUE
	jmp	done


;***********************************************************************
; For 66-bit factors and above (up to 90 bits more or less).
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp66:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	shld	rbx, r8, cl		; Form high 64-bits of factor
	inc	rbx			; ceiling (high 64-bits of factor)
	div	rbx
	dec	rbx
	shr	rbx, cl			; Restore factor
	mov	rcx, r8
	mov	facinv3, rax
svlp66:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf66:	bsf	rdx, rax		; Look for a set bit
	jnz	test66			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp66		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem66a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow66:and	rdi, rdi		; Are there untested factors?
	jnz	short rem66		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem66a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
	sbb	rbx, 0			; it will be re-added when we branch back to bsf66
rem66:	mov	r8, fac1		; Copy first trial factor
	mov	r9, fac1hi
	mov	fac1[rdi*8], r8
	mov	fac1hi[rdi*8], r9
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem66		; No, go copy another
	jmp	short do66		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test66:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	short oflow66		; Jump if overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf66			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do66:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp
	mov	SAVED_REG6, r14

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.   Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rcx, shift_count
dec	rcx

	mov	rax, fac1hi		; Form upper 64 bits of factor
	mov	rdx, fac1
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2hi		; Form upper 64 bits of factor
	mov	rdx, fac2
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3hi		; Form upper 64 bits of factor
	mov	rdx, fac3
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shifted count

	and	rcx, rcx		; If quotient will be small,
	jns	short fast66		; jump to go compute it.

	sub	rem1hi, rem1hi		; Load initial value
	sub	rem1lo, rem1lo
	sub	rem2hi, rem2hi
	sub	rem2lo, rem2lo
	sub	rem3hi, rem3hi
	sub	rem3lo, rem3lo

	mov	rcx, initshift2		; Compute first quotients
	mov	temp1, facinv1
	shr	temp1, cl
	mov	temp2, facinv2
	shr	temp2, cl
	mov	temp3, facinv3
	shr	temp3, cl

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1
	mov	memshifter, rcx		; Save shifter
	mov	rcx, shift66
	jmp	slow66			; Jump into middle of squaring loop

fast66:	mov	rem1hi, initval1	; Load initial value
	sub	rem1lo, rem1lo
	mov	rem2hi, rem1hi
	sub	rem2lo, rem2lo
	mov	rem3hi, rem1hi
	sub	rem3lo, rem3lo

	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp1, fac1hi		; Subtract quotient * factor_hi
	imul	temp1, rax
	sub	rem1hi, temp1
	mul	fac1			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from initval
	sbb	rem1hi, rdx
assert	jns

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp2, fac2hi		; Subtract quotient * factor_hi
	imul	temp2, rax
	sub	rem2hi, temp2
	mul	fac2			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from initval
	sbb	rem2hi, rdx
assert	jns

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp3, fac3hi		; Subtract quotient * factor_hi
	imul	temp3, rax
	sub	rem3hi, temp3
	mul	fac3			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from initval
	sbb	rem3hi, rdx
assert	jns

;
; Square remainders and get new remainders
;

	mov	rcx, shifter		; Load shifter
	mov	memshifter, rcx		; Save shifter
	mov	rcx, shift66
sqlp66:	mov	temp1, rem1hi		; Load remainder_hi
	imul	temp1, temp1		; Square remainder_hi

	mov	temp2, rem2hi		; Load remainder_hi
	imul	temp2, temp2		; Square remainder_hi

	mov	temp3, rem3hi		; Load remainder_hi
	imul	temp3, temp3		; Square remainder_hi

	add	rem1hi, rem1hi		; Double remainder_hi
	add	rem2hi, rem2hi		; Double remainder_hi
	add	rem3hi, rem3hi		; Double remainder_hi

	mov	rax, rem1lo		; Load remainder_lo
	mul	rem1lo			; Square remainder_lo
	xchg	rem1lo, rax		; Save squared remainder_lo
	xchg	rem1hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem1hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp1, rdx

	mov	rax, rem2lo		; Load remainder_lo
	mul	rem2lo			; Square remainder_lo
	xchg	rem2lo, rax		; Save squared remainder_lo
	xchg	rem2hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem2hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp2, rdx

	mov	rax, rem3lo		; Load remainder_lo
	mul	rem3lo			; Square remainder_lo
	xchg	rem3lo, rax		; Save squared remainder_lo
	xchg	rem3hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem3hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp3, rdx

	shld	temp1, rem1hi, 31	; Shift for computing quotient
	shld	temp2, rem2hi, 31
	shld	temp3, rem3hi, 31

	mov	rax, facinv1		; Quotient = val * 1 / factor
	mul	temp1
	mov	temp1, rdx		; Save quotient

	mov	rax, facinv2		; Quotient = val * 1 / factor
	mul	temp2
	mov	temp2, rdx		; Save quotient

	mov	rax, facinv3		; Quotient = val * 1 / factor
	mul	temp3
	mov	temp3, rdx		; Save quotient

slow66:	ror	rcx, 8			; Use shift count in ch

	mov	rax, fac1
	mul	temp1			; Compute quotient * factor_lo
	imul	temp1, fac1hi		; Compute quotient * factor_hi
	add	rdx, temp1		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor_lo
	imul	temp2, fac2hi		; Compute quotient * factor_hi
	add	rdx, temp2		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor_lo
	imul	temp3, fac3hi		; Compute quotient * factor_hi
	add	rdx, temp3		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	rol	rcx, 8			; Restore shift count

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	shr	rdx, cl
	mov	temp1, fac1hi		; Compute quotient * factor_hi
	imul	temp1, rdx
	sub	rem1hi, temp1		; Subtract quotient * factor_hi
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	shr	rdx, cl
	mov	temp2, fac2hi		; Compute quotient * factor_hi
	imul	temp2, rdx
	sub	rem2hi, temp2		; Subtract quotient * factor_hi
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	shr	rdx, cl
	mov	temp3, fac3hi		; Compute quotient * factor_hi
	imul	temp3, rdx
	sub	rem3hi, temp3		; Subtract quotient * factor_hi
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

;
; Multiply by two if necessary, test for end of squaring loop
;

	mov	rax, memshifter		; One squaring completed, shift
	add	rax, rax
	mov	memshifter, rax
	jnc	sqlp66			; Loop if a mul by 2 is not needed
	jz	short exit66		; Are we done squaring?
	add	rem1lo, rem1lo		; Multiply remainder by 2
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Multiply remainder by 2
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Multiply remainder by 2
	adc	rem3hi, rem3hi
	jmp	sqlp66			; Do next squaring

;
; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1
;

exit66:	add	rem1lo, rem1lo		; Double the remainder
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Double the remainder
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Double the remainder
	adc	rem3hi, rem3hi
	mov	rax, fac1		; Load factor #1
	mov	rdx, fac1hi
sub66:	sub	rem1lo, rax		; Subtract factor
	sbb	rem1hi, rdx
	jns	short sub66		; Subtract until result is negative
	add	rem1lo, rax		; Make it positive
	adc	rem1hi, rdx
	jnz	short fail66
	dec	rem1lo			; If one, its a factor
	jz	short win66
fail66:	mov	rax, fac2		; Load factor #2
	mov	rdx, fac2hi
sub66a:	sub	rem2lo, rax		; Subtract factor
	sbb	rem2hi, rdx
	jns	short sub66a		; Subtract until result is negative
	add	rem2lo, rax		; Make it positive
	adc	rem2hi, rdx
	jnz	short fail66a
	dec	rem2lo			; If one, its a factor
	jz	short win66
fail66a:mov	rax, fac3		; Load factor #3
	mov	rdx, fac3hi
sub66b:	sub	rem3lo, rax		; Subtract factor
	sbb	rem3hi, rdx
	jns	short sub66b		; Subtract until result is negative
	add	rem3lo, rax		; Make it positive
	adc	rem3hi, rdx
	jnz	short next66
	dec	rem3lo			; If one, its a factor
	jz	short win66

next66:	sub	rdi, rdi		; Clear queued factors count
	mov	r14, SAVED_REG6		; Restore sieve testing register
	mov	rbp, SAVED_REG5
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf66			; Test next factor from sieve

win66:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	FACHSW, edx
	mov	rax, 1			; Return TRUE
	jmp	done

;***************************************************************************
; For up to 74-bit factors using SSE2, may not be faster than the code above
;***************************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp74:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
svlp74:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf74:	bsf	rdx, rax		; Look for a set bit
	jnz	test74			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp74		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem74a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow74:and	rdi, rdi		; Are there untested factors?
	jnz	short rem74		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem74a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
	sbb	rbx, 0			; it will be re-added when we branch back to bsf74
rem74:	mov	r8, QWORD PTR XMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR XMM_F2
	mov	rdx, QWORD PTR XMM_F3
	mov	QWORD PTR XMM_F1[rdi*8], r8
	mov	QWORD PTR XMM_F2[rdi*8], r9
	mov	QWORD PTR XMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_INVFAC
	mov	QWORD PTR XMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	short rem74		; No, go copy another
	jmp	do74			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test74:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	oflow74			; Jump if overflow

; Compute the factor to test and 63 most significant bits of 1 / factor
;; OPT...  old 32-bit code....  convert to divpd???

	mov	r12, r8			; Save the factor to test
	mov	r13, r9
	shld	r13, r12, 34
	mov	temp, r13
	fild	temp
	fmul	TWO_TO_30
	and	r12, 3FFFFFFFh
	mov	temp, r12
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR XMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_F2[rdi*8], r8d
	mov	XMM_F1[rdi*8], r9d

; Check to see if we've accumulated enough factors to test

	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	bsf74			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and sse2_fac_initval code)
do74:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the loop74 code except that we avoid the initial squaring.

	sse2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
loop74:	sse2_fac 74
	dec	edi			; Decrement loop counter
	jnz	loop74

; If result = factor + 1, then we found a divisor of 2**p - 1

	sse2_compare
	pcmpeqq xmm2, XMMWORD PTR XMM_F3 ; See if any remainder is factor + 1
	pcmpeqq xmm1, XMMWORD PTR XMM_F2
	pcmpeqq xmm0, XMMWORD PTR XMM_F1
	pand	xmm2, xmm1
	ptest	xmm2, xmm0
	jnz	short win74_1		; Jump if a factor found
	pcmpeqq xmm8, XMMWORD PTR XMM_F3a ; See if any remainder is factor + 1
	pcmpeqq xmm7, XMMWORD PTR XMM_F2a
	pcmpeqq xmm6, XMMWORD PTR XMM_F1a
	pand	xmm8, xmm7
	ptest	xmm8, xmm6
	jnz	short win74_2		; Jump if a factor found

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf74			; Test next factor from sieve

win74_1:
	pand	xmm2, xmm0
	pmovmskb rcx, xmm2
	sub	rdx, rdx		; See if first SSE2 word was the factor
	shr	rcx, 1
	jc	short win74		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last SSE2 word must have been the factor
	jmp	short win74		; Yes! Factor found

win74_2:
	pand	xmm8, xmm6
	pmovmskb rcx, xmm8
	mov	edx, 16			; See if first SSE2 word was the factor
	shr	rcx, 1
	jc	short win74		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last SSE2 word must have been the factor
;;	jmp	short win74		; Yes! Factor found

win74:	mov	eax, XMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, XMM_F2[rdx]
	mov	ecx, XMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

;***************************************************************************
; For 75 to 86-bit factors using SSE2, may not be faster than the code above
;***************************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp86:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
svlp86:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf86:	bsf	rdx, rax		; Look for a set bit
	jnz	test86			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp86		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short rem86a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow86:and	rdi, rdi		; Are there untested factors?
	jnz	short rem86		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

rem86a:	sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
	sbb	rbx, 0			; it will be re-added when we branch back to bsf86
rem86:	mov	r8, QWORD PTR XMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR XMM_F2
	mov	rdx, QWORD PTR XMM_F3
	mov	QWORD PTR XMM_F1[rdi*8], r8
	mov	QWORD PTR XMM_F2[rdi*8], r9
	mov	QWORD PTR XMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_INVFAC
	mov	QWORD PTR XMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	short rem86		; No, go copy another
	jmp	do86			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test86:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	oflow86			; Jump if overflow

; Compute the factor to test and 63 most significant bits of 1 / factor
;; OPT...  old 32-bit code....  convert to divpd???

	mov	r12, r8		; Save the factor to test
	mov	r13, r9
	shld	r13, r12, 34
	mov	temp, r13
	fild	temp
	fmul	TWO_TO_30
	and	r12, 3FFFFFFFh
	mov	temp, r12
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR XMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_F2[rdi*8], r8d
	mov	XMM_F1[rdi*8], r9d

; Check to see if we've accumulated enough factors to test

	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	bsf86			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and sse2_fac_initval code)
do86:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the loop86 code except that we avoid the initial squaring.

	sse2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
loop86:	sse2_fac 86
	dec	edi			; Decrement loop counter
	jnz	loop86

; If result = factor + 1, then we found a divisor of 2**p - 1

	sse2_compare
	pcmpeqq xmm2, XMMWORD PTR XMM_F3 ; See if any remainder is factor + 1
	pcmpeqq xmm1, XMMWORD PTR XMM_F2
	pcmpeqq xmm0, XMMWORD PTR XMM_F1
	pand	xmm2, xmm1
	ptest	xmm2, xmm0
	jnz	short win86_1		; Jump if a factor found
	pcmpeqq xmm8, XMMWORD PTR XMM_F3a ; See if any remainder is factor + 1
	pcmpeqq xmm7, XMMWORD PTR XMM_F2a
	pcmpeqq xmm6, XMMWORD PTR XMM_F1a
	pand	xmm8, xmm7
	ptest	xmm8, xmm6
	jnz	short win86_2		; Jump if a factor found

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf86			; Test next factor from sieve

win86_1:
	pand	xmm2, xmm0
	pmovmskb rcx, xmm2
	sub	rdx, rdx		; See if first SSE2 word was the factor
	shr	rcx, 1
	jc	short win86		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last SSE2 word must have been the factor
	jmp	short win86		; Yes! Factor found

win86_2:
	pand	xmm8, xmm6
	pmovmskb rcx, xmm8
	mov	edx, 16			; See if first SSE2 word was the factor
	shr	rcx, 1
	jc	short win86		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last SSE2 word must have been the factor
;;	jmp	short win86		; Yes! Factor found

win86:	mov	eax, XMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, XMM_F2[rdx]
	mov	ecx, XMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done


;************************************
; For up to 74-bit factors using AVX2
;************************************

;
; Check all the bits in the sieve looking for a factor to test
;

atlp74:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
	dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
asvlp74:mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
absf74:	bsf	rdx, rax		; Look for a set bit
	jnz	atest74			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rsi, rbp		; End of sieve?
	jl	short asvlp74		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short arem74a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

aoflow74:and	rdi, rdi		; Are there untested factors?
	jnz	short arem74		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

arem74a:sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
	sbb	rbx, 0			; it will be re-added when we branch back to bsf74
arem74:	mov	r8, QWORD PTR YMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR YMM_F2
	mov	rdx, QWORD PTR YMM_F3
	mov	QWORD PTR YMM_F1[rdi*8], r8
	mov	QWORD PTR YMM_F2[rdi*8], r9
	mov	QWORD PTR YMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_INVFAC
	mov	QWORD PTR YMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 8			; Have enough been queued up?
	jne	short arem74		; No, go copy another
	jmp	ado74			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

atest74:btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	aoflow74		; Jump if overflow

; Compute the factor to test and 63 most significant bits of 1 / factor
;; OPT...  old 32-bit code....  convert to divpd???

	mov	r12, r8		; Save the factor to test
	mov	r13, r9
	shld	r13, r12, 34
	mov	temp, r13
	fild	temp
	fmul	TWO_TO_30
	and	r12, 3FFFFFFFh
	mov	temp, r12
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR YMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_F2[rdi*8], r8d
	mov	YMM_F1[rdi*8], r9d

; Check to see if we've accumulated enough factors to test

	inc	rdi			; One more factor queued up
	cmp	rdi, 8			; Have enough been queued up?
	jne	absf74			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and avx2_fac_initval code)
ado74:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aloop74 code except that we avoid the initial squaring.

	avx2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
aloop74:avx2_fac 74
	dec	edi			; Decrement loop counter
	jnz	aloop74

; If result = factor + 1, then we found a divisor of 2**p - 1

	avx2_compare
	vpcmpeqq ymm2, ymm2, YMMWORD PTR YMM_F3	; See if any remainder is factor + 1
	vpcmpeqq ymm1, ymm1, YMMWORD PTR YMM_F2
	vpcmpeqq ymm0, ymm0, YMMWORD PTR YMM_F1
	vpand	ymm2, ymm2, ymm1
	vptest	ymm2, ymm0
	jnz	short awin74_1		; Jump if a factor found
	vpcmpeqq ymm8, ymm8, YMMWORD PTR YMM_F3a ; See if any remainder is factor + 1
	vpcmpeqq ymm7, ymm7, YMMWORD PTR YMM_F2a
	vpcmpeqq ymm6, ymm6, YMMWORD PTR YMM_F1a
	vpand	ymm8, ymm8, ymm7
	vptest	ymm8, ymm6
	jnz	short awin74_2		; Jump if a factor found

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	absf74			; Test next factor from sieve

awin74_1:
	vpand	ymm2, ymm2, ymm0
	vpmovmskb rcx, ymm2
	sub	rdx, rdx		; See if first AVX word was the factor
	shr	rcx, 1
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last AVX word must have been the factor
	jmp	short awin74		; Yes! Factor found

awin74_2:
	vpand	ymm8, ymm8, ymm6
	vpmovmskb rcx, ymm8
	mov	edx, 32			; See if first AVX word was the factor
	shr	rcx, 1
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin74		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last AVX word must have been the factor
;;	jmp	short awin74		; Yes! Factor found

awin74:	mov	eax, YMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, YMM_F2[rdx]
	mov	ecx, YMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

;************************************
; For 75 to 86-bit factors using AVX2
;************************************

;
; Check all the bits in the sieve looking for a factor to test
;

atlp86:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	xor	rdi, rdi		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
	dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
asvlp86:mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
absf86:	bsf	rdx, rax		; Look for a set bit
	jnz	atest86			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rsi, rbp		; End of sieve?
	jl	short asvlp86		; Loop to test next sieve qword

; Check queued counter

	and	rdi, rdi		; Are there untested factors?
	jnz	short arem86a		; Yes, test them

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

aoflow86:and	rdi, rdi		; Are there untested factors?
	jnz	short arem86		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done

; Test less-than-full queue by copying first trial factor in the queue

arem86a:sub	rcx, facdist64      	; Undo the add of facdist * 64 to rcx
	sbb	rbx, 0			; it will be re-added when we branch back to bsf86
arem86:	mov	r8, QWORD PTR YMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR YMM_F2
	mov	rdx, QWORD PTR YMM_F3
	mov	QWORD PTR YMM_F1[rdi*8], r8
	mov	QWORD PTR YMM_F2[rdi*8], r9
	mov	QWORD PTR YMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_INVFAC
	mov	QWORD PTR YMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 8			; Have enough been queued up?
	jne	short arem86		; No, go copy another
	jmp	ado86			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

atest86:btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	aoflow86		; Jump if overflow

; Compute the factor to test and 63 most significant bits of 1 / factor
;; OPT...  old 32-bit code....  convert to divpd???

	mov	r12, r8			; Copy the factor to test
	mov	r13, r9
	shld	r13, r12, 34
	mov	temp, r13
	fild	temp
	fmul	TWO_TO_30
	and	r12, 3FFFFFFFh
	mov	temp, r12
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR YMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_F2[rdi*8], r8d
	mov	YMM_F1[rdi*8], r9d

; Check to see if we've accumulated enough factors to test

	inc	rdi			; One more factor queued up
	cmp	rdi, 8			; Have enough been queued up?
	jne	absf86			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and avx2_fac_initval code)
ado86:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aloop86 code except that we avoid the initial squaring.

	avx2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
aloop86:avx2_fac 86
	dec	edi			; Decrement loop counter
	jnz	aloop86

; If result = factor + 1, then we found a divisor of 2**p - 1

	avx2_compare
	vpcmpeqq ymm2, ymm2, YMMWORD PTR YMM_F3	; See if any remainder is factor + 1
	vpcmpeqq ymm1, ymm1, YMMWORD PTR YMM_F2
	vpcmpeqq ymm0, ymm0, YMMWORD PTR YMM_F1
	vpand	ymm2, ymm2, ymm1
	vptest	ymm2, ymm0
	jnz	short awin86_1		; Jump if a factor found
	vpcmpeqq ymm8, ymm8, YMMWORD PTR YMM_F3a ; See if any remainder is factor + 1
	vpcmpeqq ymm7, ymm7, YMMWORD PTR YMM_F2a
	vpcmpeqq ymm6, ymm6, YMMWORD PTR YMM_F1a
	vpand	ymm8, ymm8, ymm7
	vptest	ymm8, ymm6
	jnz	short awin86_2		; Jump if a factor found

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	absf86			; Test next factor from sieve

awin86_1:
	vpand	ymm2, ymm2, ymm0
	vpmovmskb rcx, ymm2
	sub	rdx, rdx		; See if first AVX word was the factor
	shr	rcx, 1
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last AVX word must have been the factor
	jmp	short awin86		; Yes! Factor found

awin86_2:
	vpand	ymm8, ymm8, ymm6
	vpmovmskb rcx, ymm8
	mov	edx, 32			; See if first AVX word was the factor
	shr	rcx, 1
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; See if next AVX word was the factor
	shr	rcx, 8
	jc	short awin86		; Yes! Factor found
	lea	rdx, [rdx+8]		; Last AVX word must have been the factor
;;	jmp	short awin86		; Yes! Factor found

awin86:	mov	eax, YMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, YMM_F2[rdx]
	mov	ecx, YMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

; Pop registers and return

done:	ad_epilog 0,0,rbx,rbp,rsi,rdi,r12,r13,r14,r15,xmm6,xmm7,xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15

factor64_tf ENDP

_TEXT	ENDS
END
