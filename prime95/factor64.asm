; Copyright 1995-2015 Mersenne Research, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; This routine implements fast trial factoring of Mersenne numbers
;
; This only runs on 64-bit CPUs.  For 32-bit CPUs see factor32.asm
;

; IDEAS:
; test where primearray loses effectiveness 

TITLE   factor64

INCLUDE	unravel.mac
INCLUDE	factor64.mac

; In 32-bit mode we are so starved for registers that we are forced to
; use the stack pointer to access the asm_data.  In 64-bit mode we
; use one of the extra 8 registers.  We can't use the rsp trick because
; that violates the Window's exception handling stack unwind mechanism.

AD_BASE		EQU	<r11>

;
; Define the offsets into the C / assembly communication structure
;

EXPONENT		EQU	DWORD PTR [AD_BASE+0*SZPTR+0*4]
FACPASS			EQU	DWORD PTR [AD_BASE+0*SZPTR+1*4]
FACHSW			EQU	DWORD PTR [AD_BASE+0*SZPTR+2*4]
FACMSW			EQU	DWORD PTR [AD_BASE+0*SZPTR+3*4]
FACLSW			EQU	DWORD PTR [AD_BASE+0*SZPTR+4*4]
CPU_FLAGS		EQU	DWORD PTR [AD_BASE+0*SZPTR+5*4]
firstcall		EQU	DWORD PTR [AD_BASE+0*SZPTR+6*4]

;;pad to match facasm_data structure defined in commonb.c
XMM_INITVAL		EQU	DWORD PTR [AD_BASE+0*SZPTR+12*4]
XMM_INVFAC		EQU	DWORD PTR [AD_BASE+0*SZPTR+16*4]
XMM_I1			EQU	DWORD PTR [AD_BASE+0*SZPTR+20*4]
XMM_I2			EQU	DWORD PTR [AD_BASE+0*SZPTR+24*4]
XMM_F1			EQU	DWORD PTR [AD_BASE+0*SZPTR+28*4]
XMM_F2			EQU	DWORD PTR [AD_BASE+0*SZPTR+32*4]
XMM_F3			EQU	DWORD PTR [AD_BASE+0*SZPTR+36*4]
XMM_TWO_120_MODF1	EQU	DWORD PTR [AD_BASE+0*SZPTR+40*4]
XMM_TWO_120_MODF2	EQU	DWORD PTR [AD_BASE+0*SZPTR+44*4]
XMM_TWO_120_MODF3	EQU	DWORD PTR [AD_BASE+0*SZPTR+48*4]
XMM_INIT120BS		EQU	DWORD PTR [AD_BASE+0*SZPTR+52*4]
XMM_INITBS		EQU	DWORD PTR [AD_BASE+0*SZPTR+54*4]
XMM_BS			EQU	DWORD PTR [AD_BASE+0*SZPTR+56*4]
XMM_SHIFTER		EQU	DWORD PTR [AD_BASE+0*SZPTR+58*4]
TWO_TO_FACSIZE_PLUS_62	EQU	QWORD PTR [AD_BASE+0*SZPTR+122*4]
SSE2_LOOP_COUNTER	EQU	DWORD PTR [AD_BASE+0*SZPTR+124*4]

;; AVX2 supports 256-bit operations on integers
;; Use the YMM registers and the memory area below to do
;; four trial factors simultaneouly.

;;pad to match facasm_data structure defined in commonb.c
YMM_INITVAL		EQU	DWORD PTR [AD_BASE+0*SZPTR+200*4]
YMM_INVFAC		EQU	DWORD PTR [AD_BASE+0*SZPTR+208*4]
YMM_I1			EQU	DWORD PTR [AD_BASE+0*SZPTR+216*4]
YMM_I2			EQU	DWORD PTR [AD_BASE+0*SZPTR+224*4]
YMM_F1			EQU	DWORD PTR [AD_BASE+0*SZPTR+232*4]
YMM_F2			EQU	DWORD PTR [AD_BASE+0*SZPTR+240*4]
YMM_F3			EQU	DWORD PTR [AD_BASE+0*SZPTR+248*4]
YMM_TWO_120_MODF1	EQU	DWORD PTR [AD_BASE+0*SZPTR+256*4]
YMM_TWO_120_MODF2	EQU	DWORD PTR [AD_BASE+0*SZPTR+264*4]
YMM_TWO_120_MODF3	EQU	DWORD PTR [AD_BASE+0*SZPTR+272*4]

;XMM_COMPARE_VAL1 DD	0,0,0,0
XMM_COMPARE_VAL1	EQU	DWORD PTR [AD_BASE+0*SZPTR+440*4]
;XMM_COMPARE_VAL2 DD	0,0,0,0
XMM_COMPARE_VAL2	EQU	DWORD PTR [AD_BASE+0*SZPTR+444*4]
;XMM_COMPARE_VAL3 DD	0,0,0,0
XMM_COMPARE_VAL3	EQU	DWORD PTR [AD_BASE+0*SZPTR+448*4]
;YMM_COMPARE_VAL1 DD	0,0,0,0,0,0,0,0
YMM_COMPARE_VAL1	EQU	DWORD PTR [AD_BASE+0*SZPTR+460*4]
;YMM_COMPARE_VAL2 DD	0,0,0,0,0,0,0,0
YMM_COMPARE_VAL2	EQU	DWORD PTR [AD_BASE+0*SZPTR+468*4]
;YMM_COMPARE_VAL3 DD	0,0,0,0,0,0,0,0
YMM_COMPARE_VAL3	EQU	DWORD PTR [AD_BASE+0*SZPTR+476*4]

;p		DQ	0	; Mersenne prime being tested
p			EQU	QWORD PTR [AD_BASE+0*SZPTR+510*4]
;twop		DQ	0	; Multiples of p + p
twop			EQU	QWORD PTR [AD_BASE+0*SZPTR+512*4]
;savefac1	DQ	0	; The LSW of the 96-bit factor being tested
savefac1		EQU	QWORD PTR [AD_BASE+0*SZPTR+514*4]
;savefac0	DQ	0	; The MSW of the 96-bit factor being tested
savefac0		EQU	QWORD PTR [AD_BASE+0*SZPTR+516*4]
;facdists	DQ	64 DUP(0) ; 64 distances between sieve factors
facdists		EQU	QWORD PTR [AD_BASE+0*SZPTR+518*4]
;facdist64	DQ	0	; 64 * facdist
facdist64		EQU	QWORD PTR [AD_BASE+0*SZPTR+646*4]
;primearray	DPTR	0	; Array of primes and offsets
primearray		EQU	[AD_BASE+0*SZPTR+648*4]
;primearray12	DPTR	0
primearray12		EQU	[AD_BASE+1*SZPTR+648*4]
;initsieve	DPTR	0	; Array used to init sieve
initsieve		EQU	[AD_BASE+2*SZPTR+648*4]
;initlookup	DPTR	0	; Lookup table into initsieve
initlookup		EQU	[AD_BASE+3*SZPTR+648*4]
;sieve		DPTR	0	; Array of sieve bits
sieve			EQU	[AD_BASE+4*SZPTR+648*4]
;shifter	DQ	0
shifter			EQU	QWORD PTR [AD_BASE+8*SZPTR+648*4]
;shift66	DQ	0	; Two shift counts used in 66-bit factoring
shift66			EQU	QWORD PTR [AD_BASE+8*SZPTR+650*4]
;initval1	DQ	0	; Lower 64 bits of initial value for squarer
initval1		EQU	QWORD PTR [AD_BASE+8*SZPTR+652*4]
;initval0	DQ	0	; Upper 64 bits of initial value for squarer
initval0		EQU	QWORD PTR [AD_BASE+8*SZPTR+654*4]
;initshift	DQ	0	; Initial shift count to make first quotient
initshift		EQU	QWORD PTR [AD_BASE+8*SZPTR+656*4]
;initshift2	DQ	0	; Initial shift count to make first quotient
initshift2		EQU	QWORD PTR [AD_BASE+8*SZPTR+658*4]
;initdiv0	DQ	0	; Value to compute 1 / factor
initdiv0		EQU	QWORD PTR [AD_BASE+8*SZPTR+660*4]
;shift_count	DQ	0	; Shift count used in squaring loop
shift_count		EQU	QWORD PTR [AD_BASE+8*SZPTR+662*4]
;doubleflags	DB	64 DUP (0) ; Should-we-double flags
doubleflags		EQU	BYTE PTR [AD_BASE+8*SZPTR+664*4]
;sqloop_counter	DQ	0	; Number of times to loop squaring
sqloop_counter		EQU	QWORD PTR [AD_BASE+8*SZPTR+680*4]

;temp		DQ	0
temp			EQU	QWORD PTR [AD_BASE+8*SZPTR+682*4]
;memshifter	DQ	0	; tlp66 case doesn't have a free register
				; to store shifter - use memory
memshifter		EQU	QWORD PTR [AD_BASE+8*SZPTR+684*4]

;fac1		DQ	0	; Queued factors to test
fac1			EQU	QWORD PTR [AD_BASE+8*SZPTR+686*4]
;fac2		DQ	0
fac2			EQU	QWORD PTR [AD_BASE+8*SZPTR+688*4]
;fac3		DQ	0
fac3			EQU	QWORD PTR [AD_BASE+8*SZPTR+690*4]
;fac4		DQ	0
fac4			EQU	QWORD PTR [AD_BASE+8*SZPTR+692*4]
;fac1hi		DQ	0	; High word of queued factors to test
fac1hi			EQU	QWORD PTR [AD_BASE+8*SZPTR+694*4]
;fac2hi		DQ	0
fac2hi			EQU	QWORD PTR [AD_BASE+8*SZPTR+696*4]
;fac3hi		DQ	0
fac3hi			EQU	QWORD PTR [AD_BASE+8*SZPTR+698*4]
;fac4hi		DQ	0
fac4hi			EQU	QWORD PTR [AD_BASE+8*SZPTR+700*4]
;queuedcnt	DD	0	; Saved count of queued factors
queuedcnt		EQU	DWORD PTR [AD_BASE+8*SZPTR+702*4]
;reps		DD	0
reps			EQU	DWORD PTR [AD_BASE+8*SZPTR+703*4]

;initstart	DD	0	; First dword in initsieve to copy
initstart		EQU	DWORD PTR [AD_BASE+8*SZPTR+704*4]

SAVED_REG1		EQU	[AD_BASE+8*SZPTR+708*4]
SAVED_REG2		EQU	[AD_BASE+9*SZPTR+708*4]
SAVED_REG3		EQU	[AD_BASE+10*SZPTR+708*4]
SAVED_REG4		EQU	[AD_BASE+11*SZPTR+708*4]
SAVED_REG5		EQU	[AD_BASE+12*SZPTR+708*4]
SAVED_REG6		EQU	[AD_BASE+13*SZPTR+708*4]

facinv2_in_memory	EQU	QWORD PTR [AD_BASE+14*SZPTR+708*4]

last_global		EQU	[AD_BASE+14*SZPTR+710*4]

;
; Global variables
;

_GWDATA SEGMENT PAGE
rems		DQ	1,7,17,23,31,41,47,49,71,73,79,89,97,103,113,119
fac32endpt	DQ	100000000000h; Limit for brute force factoring code
	align 16
XMM_LOWONE		DD	1,0,0,0
XMM_HIGHONE		DD	0,0,1,0
XMM_BITS28		DD	0FFFFFFFh,0,0FFFFFFFh,0
XMM_BITS30		DD	3FFFFFFFh,0,3FFFFFFFh,0
TWO_TO_30		DQ	1073741824.0				;; 2^30
	align 32
YMM_BITS28		DD	0FFFFFFFh,0,0FFFFFFFh,0,0FFFFFFFh,0,0FFFFFFFh,0
YMM_BITS30		DD	3FFFFFFFh,0,3FFFFFFFh,0,3FFFFFFFh,0,3FFFFFFFh,0
YMM_28TH_BIT		DD	08000000h,0,08000000h,0,08000000h,0,08000000h,0

;
; Prime data
;

sivinfo	DB	1, 2, 1, 2, 1, 2, 3, 1, 3, 2, 1, 2, 3
	DB	3, 1, 3, 2, 1, 3, 2, 3, 4, 2, 1, 2, 1, 2, 7
	DB	2, 3, 1, 5, 1, 3, 3, 2, 3, 3, 1, 5, 1, 2, 1
	DB	6, 6, 2, 1, 2, 3, 1, 5, 3, 3, 3, 1, 3, 2, 1
	DB	5, 7, 2, 1, 2, 7, 3, 5, 1, 2, 3, 4, 3, 3, 2
	DB	3, 4, 2, 4, 5, 1, 5, 1, 3, 2, 3, 4, 2, 1, 2
	DB	6, 4, 2, 4, 2, 3, 6, 1, 9, 3, 5, 3, 3, 1, 3
	DB	5, 3, 3, 1, 3, 3, 2, 1, 6, 5, 1, 2, 3, 3, 1
	DB	6, 2, 3, 4, 5, 4, 5, 4, 3, 3, 2, 4, 3, 2, 4
	DB	2, 7, 5, 6, 1, 5, 1, 2, 1, 5, 7, 2, 1, 2, 7
	DB	2, 1, 2, 10, 2, 4, 5, 4, 2, 3, 3, 7, 2, 3, 3
	DB	4, 3, 6, 2, 3, 1, 5, 1, 3, 5, 1, 5, 1, 3, 9
	DB	2, 1, 2, 3, 3, 4, 3, 3, 11, 1, 5, 4, 5, 3, 3
	DB	4, 6, 2, 3, 3, 1, 3, 6, 5, 9, 1, 2, 3, 1, 3
	DB	2, 1, 2, 6, 1, 3, 17, 3, 3, 4, 9, 5, 7, 2, 1
	DB	2, 3, 4, 2, 1, 3, 6, 5, 1, 2, 1, 2, 3, 6, 6
	DB	4, 6, 3, 2, 3, 4, 2, 4, 2, 7, 2, 3, 1, 2, 3
	DB	1, 3, 5, 10, 3, 2, 1, 12, 2, 1, 5, 6, 1, 5, 4
	DB	3, 3, 3, 9, 3, 2, 1, 6, 5, 6, 4, 8, 7, 3, 2
	DB	1, 2, 1, 5, 6, 3, 3, 9, 1, 8, 1, 11, 3, 4, 3
	DB	2, 1, 2, 4, 3, 5, 1, 5, 7, 5, 3, 6, 1, 2, 1
	DB	5, 6, 1, 8, 1, 3, 2, 1, 5, 4, 9, 12, 2, 3, 4
	DB	8, 1, 2, 4, 8, 1, 2, 4, 3, 3, 2, 6, 1, 11, 3
	DB	1, 3, 2, 3, 7, 3, 2, 1, 3, 2, 3, 6, 3, 3, 7
	DB	2, 3, 6, 4, 3, 2, 13, 9, 5, 4, 2, 3, 1, 3, 11
	DB	6, 1, 8, 4, 2, 6, 7, 5, 1, 2, 4, 3, 3, 2, 1
	DB	2, 3, 4, 2, 1, 3, 5, 1, 5, 4, 2, 7, 5, 6, 1
	DB	3, 2, 1, 8, 7, 2, 3, 4, 3, 2, 9, 4, 5, 3, 3
	DB	4, 5, 6, 7, 2, 3, 3, 1, 14, 1, 5, 4, 2, 7, 2
	DB	4, 6, 3, 6, 2, 3, 10, 5, 1, 8, 13, 2, 1, 6, 3
	DB	2, 6, 3, 4, 2, 4, 11, 1, 2, 1, 6, 14, 1, 3, 3
	DB	3, 2, 3, 1, 6, 2, 6, 1, 5, 1, 8, 1, 8, 3, 10
	DB	8, 4, 2, 1, 2, 1, 11, 4, 6, 3, 5, 1, 2, 3, 1
	DB	3, 5, 1, 6, 5, 1, 5, 7, 3, 2, 3, 4, 3, 3, 8
	DB	6, 1, 2, 7, 3, 2, 4, 5, 4, 3, 3, 11, 3, 1, 5
	DB	7, 2, 3, 9, 1, 5, 7, 2, 1, 5, 7, 2, 4, 9, 2
	DB	3, 1, 2, 3, 1, 6, 2, 10, 11, 6, 1, 2, 3, 3, 1
	DB	3, 11, 1, 3, 8, 3, 6, 1, 3, 6, 8, 1, 2, 3, 7
	DB	2, 1, 9, 12, 5, 3, 1, 5, 1, 5, 1, 5, 3, 1, 5
	DB	1, 5, 3, 4, 15, 5, 1, 5, 4, 3, 5, 9, 3, 6, 6
	DB	1, 9, 3, 2, 3, 3, 9, 1, 5, 7, 3, 2, 1, 2, 12
	DB	1, 6, 3, 8, 4, 3, 3, 9, 8, 1, 2, 3, 1, 3, 3
	DB	5, 3, 6, 6, 9, 1, 3, 2, 9, 4, 12, 2, 1, 2, 3
	DB	1, 6, 2, 7, 15, 5, 3, 6, 7, 3, 5, 6, 1, 2, 3
	DB	4, 3, 5, 1, 2, 7, 3, 3, 2, 3, 1, 5, 1, 8, 6
	DB	4, 9, 2, 3, 6, 1, 3, 3, 3, 14, 3, 7, 2, 4, 5
	DB	4, 6, 9, 2, 1, 2, 12, 6, 3, 1, 8, 3, 3, 7, 5
	DB	7, 2, 15, 3, 3, 3, 4, 3, 2, 1, 6, 3, 2, 1, 3
	DB	11, 3, 1, 2, 9, 1, 2, 6, 1, 3, 2, 13, 3, 3, 2
	DB	4, 5, 16, 8, 1, 3, 2, 1, 2, 1, 5, 7, 3, 2, 4
	DB	5, 3, 10, 2, 1, 3, 15, 2, 4, 5, 3, 3, 4, 3, 6
	DB	2, 3, 1, 3, 2, 3, 1, 5, 1, 8, 3, 10, 2, 6, 7
	DB	14, 3, 10, 2, 9, 4, 3, 2, 3, 7, 3, 3, 5, 1, 5
	DB	6, 4, 5, 1, 5, 4, 6, 5, 12, 1, 2, 4, 3, 2, 4
	DB	9, 5, 3, 3, 1, 3, 5, 6, 1, 5, 3, 3, 3, 4, 3
	DB	5, 3, 1, 3, 3, 3, 5, 4, 12, 3, 11, 1, 9, 2, 4
	DB	5, 15, 4, 9, 2, 1, 5, 3, 1, 3, 2, 9, 4, 6, 9
	DB	8, 3, 1, 6, 3, 5, 1, 5, 1, 3, 5, 7, 2, 12, 1
	DB	8, 1, 5, 1, 5, 10, 2, 1, 2, 4, 8, 3, 3, 1, 6
	DB	8, 4, 2, 3, 15, 1, 5, 1, 3, 2, 3, 3, 4, 3, 2
	DB	6, 3, 4, 6, 2, 7, 6, 5, 12, 3, 6, 3, 1, 11, 4
	DB	9, 5, 3, 7, 2, 1, 3, 5, 4, 3, 2, 3, 15, 7, 5
	DB	1, 6, 5, 1, 8, 1, 9, 12, 9, 3, 8, 9, 3, 1, 9
	DB	2, 3, 1, 5, 4, 5, 3, 3, 4, 2, 3, 1, 5, 1, 6
	DB	2, 3, 3, 1, 6, 2, 7, 9, 2, 3, 10, 2, 4, 3, 2
	DB	4, 2, 7, 3, 2, 7, 6, 2, 1, 15, 2, 12, 3, 3, 6
	DB	6, 7, 3, 2, 1, 2, 9, 3, 6, 4, 3, 2, 6, 1, 6
	DB	15, 8, 1, 3, 11, 7, 3, 5, 6, 3, 1, 2, 4, 5, 3
	DB	3, 12, 7, 3, 2, 4, 6, 9, 5, 1, 5, 1, 2, 3, 10
	DB	3, 2, 7, 2, 1, 2, 7, 3, 6, 12, 5, 3, 4, 5, 1
	DB	15, 2, 3, 1, 6, 2, 7, 3, 17, 6, 4, 3, 5, 1, 2
	DB	10, 5, 4, 8, 1, 5, 7, 2, 1, 6, 3, 8, 3, 4, 2
	DB	4, 2, 3, 4, 3, 3, 6, 3, 2, 3, 3, 4, 9, 2, 10
	DB	2, 6, 1, 5, 3, 1, 5, 6, 1, 2, 10, 3, 15, 3, 2
	DB	4, 5, 6, 3, 1, 14, 1, 3, 2, 1, 8, 6, 1, 3, 5
	DB	4, 12, 6, 3, 9, 3, 2, 7, 3, 2, 6, 4, 3, 6, 2
	DB	3, 6, 3, 6, 1, 8, 10, 2, 1, 5, 9, 4, 2, 7, 2
	DB	1, 3, 11, 3, 7, 3, 3, 5, 3, 1, 5, 1, 2, 1, 11
	DB	1, 2, 3, 3, 6, 3, 7, 5, 6, 3, 4, 2, 18, 7, 6
	DB	3, 2, 3, 1, 6, 3, 6, 8, 1, 5, 4, 11, 1, 6, 3
	DB	2, 3, 9, 1, 6, 3, 2, 6, 4, 3, 6, 2, 3, 6, 3
	DB	1, 6, 6, 2, 7, 3, 8, 3, 1, 5, 4, 9, 3, 17, 1
	DB	14, 1, 11, 3, 1, 5, 6, 1, 3, 2, 4, 11, 3, 1, 5
	DB	4, 2, 3, 4, 2, 6, 9, 6, 10, 2, 3, 3, 4, 2, 1
	DB	8, 6, 1, 5, 4, 5, 1, 2, 3, 7, 6, 11, 4, 14, 1
	DB	2, 10, 2, 1, 2, 7, 5, 6, 1, 6, 8, 1, 14, 4, 11
	DB	4, 2, 3, 3, 7, 2, 4, 6, 3, 3, 2, 10, 2, 9, 1
	DB	6, 3, 2, 3, 7, 9, 5, 4, 5, 16, 3, 5, 3, 3, 1
	DB	3, 8, 3, 1, 6, 3, 14, 1, 5, 4, 8, 3, 4, 3, 5
	DB	12, 10, 5, 1, 5, 1, 6, 2, 3, 10, 2, 1, 6, 9, 5
	DB	1, 5, 1, 2, 10, 8, 13, 2, 4, 3, 2, 6, 3, 4, 6
	DB	6, 3, 2, 4, 11, 1, 8, 7, 5, 3, 6, 6, 7, 3, 2
	DB	10, 2, 6, 3, 1, 3, 3, 8, 4, 11, 1, 14, 4, 3, 2
	DB	10, 2, 6, 12, 10, 2, 4, 5, 1, 8, 1, 6, 6, 17, 1
	DB	2, 3, 6, 3, 3, 4, 3, 2, 1, 3, 12, 2, 10, 5, 3
	DB	3, 7, 2, 3, 3, 1, 6, 3, 5, 1, 5, 3, 10, 2, 13
	DB	2, 1, 3, 11, 1, 12, 2, 3, 1, 2, 3, 12, 3, 4, 2
	DB	1, 17, 3, 4, 8, 6, 1, 5, 1, 5, 3, 4, 2, 4, 6
	DB	11, 3, 7, 2, 13, 2, 1, 6, 5, 4, 2, 4, 6, 2, 7
	DB	3, 8, 3, 4, 2, 3, 3, 4, 3, 5, 6, 1, 3, 3, 8
	DB	4, 3, 3, 6, 5, 1, 3, 9, 2, 3, 3, 3, 6, 9, 4
	DB	3, 5, 4, 9, 2, 7, 3, 9, 5, 4, 5, 6, 1, 3, 6
	DB	6, 18, 2, 3, 4, 2, 3, 1, 2, 9, 6, 3, 4, 3, 3
	DB	2, 9, 1, 2, 1, 12, 2, 3, 3, 7, 15, 3, 2, 3, 6
	DB	3, 10, 2, 4, 2, 4, 3, 3, 2, 15, 1, 5, 6, 4, 5
	DB	4, 12, 3, 6, 2, 7, 2, 3, 1, 14, 7, 8, 1, 6, 3
	DB	2, 10, 5, 3, 3, 3, 4, 5, 6, 7, 5, 7, 8, 7, 5
	DB	7, 3, 8, 3, 4, 3, 8, 10, 5, 1, 3, 2, 1, 2, 6
	DB	1, 5, 1, 3, 11, 3, 1, 2, 9, 4, 5, 4, 11, 1, 5
	DB	9, 7, 2, 1, 2, 9, 1, 2, 3, 4, 5, 1, 15, 2, 15
	DB	1, 5, 1, 9, 2, 9, 3, 7, 5, 1, 2, 10, 18, 3, 2
	DB	3, 7, 2, 10, 5, 7, 11, 3, 1, 15, 6, 5, 9, 1, 2
	DB	7, 3, 11, 9, 1, 6, 3, 2, 4, 2, 4, 3, 5, 1, 6
	DB	9, 5, 7, 8, 7, 2, 3, 3, 1, 3, 2, 1, 14, 1, 14
	DB	3, 1, 2, 3, 7, 2, 6, 7, 8, 7, 2, 3, 4, 3, 2
	DB	3, 3, 3, 4, 2, 4, 2, 7, 8, 4, 3, 2, 6, 4, 8
	DB	1, 5, 4, 2, 3, 13, 3, 5, 4, 2, 3, 6, 7, 15, 2
	DB	7, 11, 4, 6, 2, 3, 4, 5, 3, 7, 5, 3, 1, 5, 6
	DB	6, 7, 3, 3, 9, 5, 3, 4, 9, 2, 3, 1, 3, 5, 1
	DB	5, 4, 3, 3, 5, 1, 9, 5, 1, 6, 2, 3, 4, 5, 6
	DB	7, 6, 2, 4, 5, 3, 3, 10, 2, 7, 8, 7, 5, 4, 5
	DB	6, 1, 9, 3, 6, 5, 6, 1, 2, 1, 6, 3, 2, 4, 2
	DB	22, 2, 1, 2, 1, 5, 6, 3, 3, 7, 2, 3, 3, 3, 4
	DB	3, 18, 9, 2, 3, 1, 6, 3, 3, 3, 2, 7, 11, 6, 1
	DB	9, 5, 3, 13, 12, 2, 1, 2, 1, 2, 7, 2, 3, 3, 4
	DB	8, 6, 1, 21, 2, 1, 2, 12, 3, 3, 1, 9, 2, 7, 3
	DB	14, 9, 7, 3, 5, 6, 1, 3, 6, 15, 3, 2, 3, 3, 7
	DB	2, 1, 12, 2, 3, 3, 13, 5, 9, 3, 4, 3, 3, 15, 2
	DB	6, 6, 1, 8, 1, 3, 2, 6, 9, 1, 3, 2, 13, 6, 3
	DB	6, 2, 12, 12, 6, 3, 1, 6, 14, 4, 2, 3, 6, 1, 9
	DB	3, 2, 3, 3, 10, 8, 1, 3, 3, 9, 5, 3, 1, 2, 4
	DB	3, 3, 12, 8, 3, 4, 5, 3, 7, 11, 4, 8, 3, 1, 6
	DB	2, 1, 11, 4, 9, 17, 1, 3, 9, 2, 3, 3, 4, 5, 4
	DB	9, 3, 2, 1, 2, 4, 8, 1, 6, 6, 3, 9, 2, 3, 3
	DB	3, 1, 3, 6, 5, 10, 6, 9, 2, 3, 1, 8, 1, 5, 7
	DB	2, 15, 1, 5, 6, 1, 12, 3, 8, 4, 5, 1, 6, 11, 3
	DB	1, 8, 10, 5, 1, 6, 6, 9, 5, 6, 3, 1, 5, 1, 3
	DB	5, 9, 1, 6, 3, 2, 3, 1, 12, 14, 1, 2, 1, 5, 1
	DB	8, 6, 4, 11, 1, 3, 2, 1, 5, 3, 10, 6, 5, 4, 6
	DB	3, 3, 3, 2, 9, 1, 2, 6, 9, 1, 6, 3, 2, 1, 8
	DB	6, 6, 7, 2, 4, 9, 2, 6, 7, 3, 3, 2, 4, 3, 2
	DB	10, 6, 5, 7, 2, 1, 8, 1, 6, 15, 2, 3, 12, 10, 12
	DB	5, 4, 6, 5, 6, 3, 6, 6, 3, 4, 8, 7, 3, 2, 3
	DB	18, 10, 5, 15, 6, 1, 2, 1, 14, 6, 7, 3, 11, 4, 2
	DB	9, 3, 7, 9, 2, 3, 1, 3, 17, 9, 1, 8, 3, 9, 1
	DB	12, 2, 1, 3, 6, 3, 6, 5, 4, 3, 8, 6, 4, 5, 7
	DB	20, 3, 1, 3, 2, 6, 7, 2, 1, 2, 1, 2, 4, 3, 5
	DB	3, 3, 1, 3, 3, 3, 6, 3, 12, 5, 1, 5, 3, 6, 3
	DB	3, 7, 3, 3, 26, 10, 3, 5, 1, 5, 4, 5, 6, 6, 1
	DB	3, 2, 7, 8, 4, 6, 3, 11, 1, 5, 4, 3, 11, 1, 11
	DB	3, 4, 5, 6, 6, 1, 5, 3, 6, 1, 2, 7, 5, 1, 3
	DB	9, 2, 6, 4, 9, 6, 3, 3, 2, 3, 3, 7, 2, 1, 6
	DB	6, 2, 3, 9, 9, 6, 1, 8, 6, 4, 9, 5, 13, 2, 3
	DB	4, 3, 3, 2, 1, 5, 10, 2, 3, 4, 2, 10, 5, 1, 17
	DB	1, 2, 12, 1, 6, 6, 5, 3, 1, 6, 15, 3, 6, 8, 6
	DB	1, 11, 9, 6, 7, 5, 1, 6, 6, 2, 1, 2, 3, 6, 1
	DB	8, 9, 1, 20, 4, 8, 3, 4, 5, 1, 2, 9, 4, 5, 4
	DB	6, 2, 9, 1, 9, 5, 1, 2, 1, 2, 4, 14, 1, 3, 11
	DB	6, 3, 7, 9, 2, 3, 4, 3, 3, 5, 4, 2, 1, 9, 5
	DB	3, 10, 11, 4, 3, 15, 2, 1, 2, 9, 3, 15, 1, 2, 4
	DB	3, 2, 3, 6, 7, 17, 7, 3, 2, 1, 3, 2, 7, 2, 1
	DB	3, 14, 1, 2, 3, 4, 5, 1, 5, 1, 5, 1, 2, 15, 1
	DB	6, 6, 5, 9, 6, 7, 5, 1, 6, 3, 5, 3, 7, 6, 2
	DB	7, 2, 9, 1, 5, 4, 2, 4, 5, 6, 9, 9, 4, 3, 9
	DB	8, 7, 3, 3, 5, 7, 2, 3, 1, 6, 6, 2, 3, 3, 6
	DB	1, 8, 1, 6, 3, 2, 7, 3, 2, 1, 6, 9, 2, 18, 9
	DB	6, 6, 1, 2, 1, 2, 4, 6, 2, 18, 3, 9, 1, 6, 5
	DB	3, 6, 12, 4, 3, 3, 8, 6, 1, 9, 5, 10, 5, 1, 3
	DB	9, 2, 1, 20, 3, 1, 8, 1, 2, 4, 9, 5, 6, 3, 1
	DB	5, 4, 2, 3, 6, 1, 5, 9, 4, 3, 2, 10, 2, 3, 18
	DB	3, 1, 5, 3, 12, 3, 7, 8, 3, 9, 1, 5, 10, 5, 4
	DB	3, 2, 3, 1, 5, 1, 6, 2, 1, 2, 4, 5, 3, 6, 9
	DB	7, 6, 8, 4, 3, 8, 4, 2, 1, 3, 9, 12, 9, 5, 6
	DB	1, 2, 7, 5, 3, 3, 3, 9, 6, 1, 14, 9, 7, 8, 6
	DB	7, 12, 6, 11, 3, 1, 5, 4, 2, 1, 2, 7, 6, 3, 2
	DB	3, 7, 2, 1, 2, 15, 3, 1, 3, 5, 1, 15, 11, 1, 2
	DB	3, 4, 3, 3, 8, 6, 6, 3, 4, 2, 1, 12, 6, 2, 3
	DB	4, 3, 3, 5, 1, 3, 6, 14, 7, 3, 2, 6, 4, 3, 6
	DB	2, 3, 7, 3, 6, 5, 3, 3, 4, 3, 3, 2, 1, 2, 4
	DB	6, 2, 7, 9, 5, 1, 8, 3, 10, 3, 5, 4, 2, 15, 18
	DB	6, 4, 11, 6, 1, 3, 6, 8, 3, 3, 1, 9, 2, 13, 2
	DB	4, 9, 5, 4, 5, 3, 7, 2, 10, 11, 9, 6, 4, 14, 6
	DB	3, 3, 4, 3, 6, 12, 8, 7, 2, 7, 6, 3, 5, 6, 10
	DB	3, 2, 4, 9, 6, 9, 5, 1, 2, 10, 5, 7, 2, 3, 1
	DB	5, 12, 9, 1, 2, 10, 8, 7, 5, 7, 3, 2, 3, 10, 3
	DB	5, 3, 1, 6, 3, 15, 5, 4, 3, 2, 3, 4, 20, 1, 2
	DB	1, 6, 9, 2, 3, 4, 5, 3, 9, 9, 1, 6, 8, 4, 3
	DB	2, 3, 3, 1, 26, 7, 2, 10, 8, 1, 2, 3, 6, 1, 3
	DB	6, 6, 3, 2, 7, 5, 3, 3, 7, 5, 7, 8, 4, 3, 6
	DB	2, 4, 11, 3, 1, 9, 11, 3, 1, 9, 3, 8, 7, 5, 3
	DB	6, 1, 3, 2, 4, 9, 6, 8, 1, 2, 7, 2, 4, 6, 6
	DB	15, 8, 4, 2, 1, 3, 11, 6, 4, 5, 3, 3, 3, 7, 3
	DB	9, 5, 6, 1, 5, 1, 2, 13, 2, 6, 4, 2, 9, 4, 5
	DB	7, 8, 3, 3, 4, 5, 3, 4, 3, 6, 5, 10, 5, 4, 2
	DB	6, 13, 9, 2, 6, 9, 3, 15, 3, 4, 3, 11, 6, 1, 2
	DB	3, 3, 1, 5, 1, 2, 3, 3, 1, 3, 11, 9, 3, 9, 6
	DB	4, 6, 3, 5, 6, 1, 8, 1, 5, 1, 5, 9, 3, 10, 2
	DB	1, 3, 11, 3, 3, 9, 3, 7, 6, 8, 1, 3, 3, 2, 7
	DB	6, 2, 1, 9, 8, 18, 6, 3, 7, 14, 1, 6, 3, 6, 3
	DB	2, 1, 8, 15, 4, 12, 3, 15, 5, 1, 9, 2, 3, 6, 4
	DB	11, 1, 3, 11, 9, 1, 5, 1, 5, 15, 1, 14, 3, 7, 8
	DB	3, 10, 8, 1, 3, 2, 16, 2, 1, 2, 3, 1, 6, 2, 3
	DB	3, 6, 1, 3, 2, 3, 4, 3, 2, 10, 2, 16, 5, 4, 8
	DB	1, 11, 1, 2, 3, 4, 3, 8, 7, 2, 9, 4, 2, 10, 3
	DB	6, 6, 3, 5, 1, 5, 1, 6, 14, 6, 9, 1, 9, 5, 4
	DB	5, 24, 1, 2, 3, 4, 5, 1, 5, 15, 1, 18, 3, 5, 3
	DB	1, 9, 2, 3, 4, 8, 7, 8, 3, 7, 2, 10, 2, 3, 1
	DB	5, 6, 1, 3, 6, 3, 3, 2, 6, 1, 3, 2, 6, 3, 4
	DB	2, 1, 3, 9, 5, 3, 4, 6, 3, 11, 1, 3, 6, 9, 2
	DB	7, 3, 2, 10, 3, 8, 4, 2, 4, 11, 4, 6, 3, 3, 8
	DB	6, 9, 15, 4, 2, 1, 2, 3, 13, 2, 7, 12, 11, 3, 1
	DB	3, 5, 3, 7, 3, 3, 6, 5, 3, 1, 6, 5, 6, 4, 9
	DB	9, 5, 3, 4, 8, 3, 3, 4, 8, 10, 2, 1, 5, 1, 5
	DB	6, 3, 4, 3, 5, 10, 5, 9, 13, 2, 3, 15, 1, 2, 4
	DB	3, 6, 6, 9, 2, 4, 11, 3, 1, 6, 17, 3, 9, 6, 3
	DB	1, 14, 7, 8, 7, 2, 7, 6, 2, 3, 3, 1, 18, 2, 3
	DB	10, 6, 12, 3, 11, 1, 8, 9, 6, 6, 9, 1, 3, 3, 3
	DB	2, 3, 7, 2, 1, 11, 4, 6, 3, 5, 3, 4, 6, 9, 6
	DB	3, 5, 1, 11, 7, 3, 3, 2, 9, 3, 10, 11, 1, 6, 12
	DB	2, 9, 9, 1, 11, 1, 2, 6, 4, 6, 5, 7, 2, 1, 9
	DB	8, 19, 3, 3, 3, 6, 5, 3, 6, 4, 3, 2, 3, 7, 15
	DB	3, 5, 4, 11, 3, 4, 6, 5, 1, 5, 1, 3, 5, 1, 5
	DB	6, 9, 10, 3, 2, 4, 11, 3, 3, 15, 3, 7, 3, 6, 6
	DB	3, 5, 1, 5, 15, 1, 8, 4, 2, 1, 3, 9, 2, 1, 3
	DB	2, 13, 2, 4, 3, 5, 1, 2, 3, 4, 2, 3, 15, 6, 1
	DB	3, 3, 2, 10, 11, 4, 2, 1, 2, 36, 4, 2, 4, 11, 1
	DB	2, 7, 5, 1, 2, 10, 3, 5, 9, 3, 10, 8, 3, 4, 3
	DB	2, 10, 6, 11, 1, 2, 1, 6, 5, 9, 1, 11, 3, 9, 15
	DB	1, 5, 7, 5, 4, 8, 25, 3, 5, 4, 5, 6, 3, 9, 1
	DB	11, 3, 1, 2, 3, 4, 3, 3, 5, 9, 1, 11, 1, 8, 7
	DB	5, 3, 1, 6, 5, 10, 2, 7, 3, 2, 18, 1, 2, 3, 6
	DB	1, 2, 7, 6, 3, 2, 3, 1, 3, 2, 10, 5, 1, 5, 3
	DB	6, 1, 12, 6, 6, 3, 3, 2, 12, 1, 2, 12, 1, 3, 2
	DB	3, 4, 8, 3, 1, 5, 6, 7, 3, 17, 3, 7, 3, 2, 1
	DB	15, 11, 4, 2, 3, 4, 2, 1, 14, 1, 3, 2, 13, 9, 11
	DB	1, 3, 8, 3, 1, 8, 6, 1, 6, 2, 3, 3, 7, 5, 3
	DB	4, 6, 2, 9, 1, 5, 4, 8, 3, 3, 15, 1, 5, 9, 1
	DB	5, 4, 2, 4, 6, 12, 20, 1, 6, 5, 3, 6, 1, 6, 2
	DB	1, 2, 3, 9, 7, 6, 3, 2, 7, 15, 2, 4, 5, 4, 3
	DB	5, 9, 4, 2, 7, 8, 3, 4, 2, 3, 1, 5, 1, 6, 2
	DB	1, 2, 3, 4, 2, 3, 16, 12, 5, 4, 9, 5, 1, 3, 5
	DB	1, 2, 9, 3, 6, 1, 8, 1, 11, 3, 3, 4, 9, 2, 9
	DB	6, 4, 3, 2, 10, 3, 15, 11, 6, 1, 3, 9, 2, 31, 2
	DB	1, 6, 3, 5, 1, 6, 6, 14, 1, 2, 7, 11, 3, 1, 3
	DB	3, 5, 7, 2, 1, 5, 3, 4, 5, 7, 5, 3, 1, 6, 11
	DB	9, 4, 5, 9, 6, 1, 6, 2, 6, 1, 5, 1, 3, 9, 3
	DB	3, 17, 3, 1, 6, 2, 3, 9, 9, 1, 8, 3, 3, 4, 3
	DB	5, 9, 4, 5, 4, 5, 1, 2, 9, 13, 6, 11, 1, 2, 1
	DB	11, 3, 3, 7, 8, 3, 10, 5, 6, 1, 9, 21, 2, 12, 1
	DB	3, 5, 6, 1, 3, 5, 4, 2, 3, 6, 6, 4, 2, 3, 6
	DB	15, 10, 3, 12, 3, 5, 6, 1, 5, 10, 3, 3, 2, 6, 7
	DB	5, 9, 6, 4, 3, 6, 2, 7, 5, 1, 6, 15, 8, 1, 6
	DB	3, 2, 1, 2, 3, 13, 2, 9, 1, 2, 3, 7, 27, 3, 26
	DB	1, 8, 3, 3, 6, 13, 2, 1, 3, 11, 3, 1, 6, 6, 3
	DB	5, 9, 1, 6, 6, 5, 9, 6, 3, 4, 3, 5, 3, 4, 2
	DB	1, 2, 10, 12, 3, 3, 5, 7, 5, 1, 11, 3, 7, 5, 13
	DB	2, 9, 4, 6, 6, 5, 6, 3, 4, 8, 3, 4, 3, 3, 11
	DB	1, 5, 10, 5, 3, 22, 9, 3, 5, 1, 2, 3, 7, 2, 13
	DB	2, 1, 6, 5, 4, 2, 4, 6, 2, 6, 4, 11, 4, 3, 5
	DB	9, 3, 3, 4, 3, 6, 2, 4, 9, 5, 6, 3, 6, 1, 3
	DB	2, 1, 8, 6, 6, 7, 5, 7, 3, 5, 6, 1, 6, 3, 2
	DB	3, 1, 6, 2, 13, 3, 9, 3, 5, 3, 1, 9, 5, 4, 2
	DB	13, 5, 10, 3, 8, 10, 6, 5, 4, 5, 1, 8, 3, 10, 5
	DB	10, 2, 15, 1, 2, 4, 8, 1, 9, 2, 1, 3, 5, 9, 6
	DB	7, 9, 3, 8, 10, 3, 2, 4, 3, 2, 3, 6, 4, 5, 1
	DB	6, 3, 2, 1, 3, 5, 1, 8, 6, 7, 5, 3, 4, 3, 14
	DB	1, 3, 9, 15, 17, 1, 8, 6, 1, 9, 8, 3, 4, 5, 4
	DB	5, 4, 5, 22, 3, 3, 2, 10, 2, 1, 2, 7, 14, 4, 3
	DB	8, 7, 15, 3, 15, 2, 7, 5, 3, 3, 4, 2, 9, 6, 3
	DB	1, 11, 6, 4, 3, 6, 2, 7, 2, 3, 1, 2, 9, 10, 3
	DB	8, 19, 8, 1, 2, 3, 1, 20, 21, 7, 2, 3, 1, 12, 5
	DB	3, 1, 9, 5, 6, 1, 8, 1, 3, 8, 3, 4, 2, 1, 5
	DB	3, 4, 5, 1, 9, 8, 4, 6, 9, 6, 3, 6, 5, 3, 3
	DB	9, 6, 7, 2, 1, 5, 10, 3, 6, 3, 8, 13, 2, 9, 1
	DB	2, 16, 5, 4, 3, 2, 3, 3, 7, 3, 9, 2, 1, 9, 5
	DB	4, 5, 4, 5, 1, 2, 3, 1, 5, 21, 4, 6, 2, 3, 9
	DB	1, 8, 4, 2, 1, 5, 7, 6, 5, 10, 2, 4, 5, 19, 2
	DB	3, 1, 5, 10, 5, 6, 3, 6, 13, 6, 2, 4, 14, 4, 2
	DB	4, 12, 3, 5, 4, 3, 8, 6, 4, 5, 6, 4, 11, 3, 1
	DB	5, 1, 3, 5, 3, 3, 4, 3, 2, 7, 14, 4, 8, 9, 4
	DB	2, 3, 10, 2, 9, 3, 1, 12, 12, 3, 3, 6, 6, 2, 1
	DB	11, 1, 5, 3, 4, 6, 2, 10, 9, 3, 2, 6, 12, 3, 3
	DB	27, 4, 3, 2, 13, 18, 2, 1, 2, 13, 6, 6, 2, 3, 3
	DB	4, 6, 5, 1, 6, 8, 9, 3, 4, 3, 6, 9, 5, 1, 27
	DB	2, 1, 5, 15, 6, 4, 2, 4, 8, 7, 6, 3, 2, 3, 6
	DB	3, 1, 2, 7, 6, 2, 7, 3, 12, 3, 3, 5, 6, 6, 10
	DB	9, 3, 3, 8, 4, 2, 3, 10, 2, 16, 2, 7, 5, 1, 3
	DB	6, 8, 1, 2, 3, 6, 1, 5, 4, 3, 2, 1, 5, 7, 3
	DB	3, 6, 9, 17, 4, 5, 3, 12, 3, 1, 5, 6, 1, 15, 5
	DB	7, 6, 6, 8, 3, 3, 1, 9, 2, 3, 15, 7, 2, 3, 3
	DB	1, 3, 2, 3, 7, 3, 2, 4, 5, 6, 3, 16, 5, 4, 11
	DB	1, 5, 3, 12, 4, 2, 15, 3, 1, 6, 8, 4, 3, 2, 3
	DB	4, 8, 7, 3, 3, 2, 1, 5, 6, 1, 8, 7, 2, 1, 2
	DB	10, 9, 5, 1, 5, 3, 6, 15, 4, 9, 6, 5, 1, 3, 3
	DB	2, 6, 6, 1, 2, 6, 9, 12, 1, 5, 3, 4, 8, 4, 3
	DB	6, 5, 7, 3, 6, 3, 3, 2, 1, 12, 2, 3, 4, 3, 2
	DB	1, 2, 3, 7, 2, 4, 5, 12, 12, 6, 1, 3, 6, 11, 15
	DB	1, 3, 9, 5, 3, 3, 4, 2, 1, 3, 5, 4, 5, 3, 4
	DB	8, 3, 7, 3, 2, 12, 4, 5, 1, 6, 3, 2, 18, 1, 11
	DB	3, 4, 3, 5, 4, 3, 6, 5, 7, 5, 3, 9, 6, 1, 6
	DB	2, 13, 5, 7, 8, 9, 4, 9, 6, 6, 3, 8, 7, 12, 5
	DB	6, 4, 11, 3, 1, 5, 30, 3, 1, 2, 4, 8, 7, 5, 3
	DB	12, 3, 6, 9, 12, 1, 15, 2, 1, 6, 3, 5, 1, 2, 7
	DB	3, 8, 1, 5, 4, 11, 10, 3, 2, 16, 3, 9, 2, 1, 2
	DB	1, 2, 4, 26, 7, 11, 1, 11, 10, 5, 4, 5, 1, 3, 2
	DB	7, 2, 3, 10, 2, 3, 1, 6, 6, 3, 6, 8, 1, 6, 5
	DB	4, 2, 3, 1, 14, 6, 4, 5, 6, 1, 2, 7, 14, 4, 3
	DB	2, 1, 2, 3, 1, 6, 29, 3, 7, 5, 1, 3, 14, 16, 2
	DB	15, 4, 3, 2, 3, 6, 6, 1, 2, 3, 3, 7, 8, 4, 15
	DB	2, 1, 5, 4, 3, 2, 3, 13, 2, 6, 1, 5, 9, 6, 6
	DB	9, 1, 2, 6, 4, 6, 5, 10, 2, 4, 8, 6, 4, 3, 8
	DB	4, 5, 6, 7, 3, 2, 4, 6, 2, 10, 3, 20, 4, 8, 3
	DB	18, 1, 3, 2, 3, 1, 11, 9, 1, 5, 3, 18, 7, 6, 2
	DB	9, 4, 2, 7, 5, 1, 5, 4, 2, 1, 9, 8, 6, 7, 5
	DB	7, 3, 3, 21, 5, 3, 3, 10, 5, 4, 6, 2, 6, 9, 1
	DB	5, 7, 9, 5, 9, 4, 3, 2, 7, 3, 5, 15, 7, 3, 3
	DB	2, 6, 19, 2, 1, 2, 3, 4, 6, 5, 3, 9, 3, 25, 3
	DB	2, 3, 6, 4, 5, 16, 3, 11, 1, 5, 6, 9, 1, 3, 2
	DB	15, 4, 3, 3, 9, 5, 1, 2, 6, 10, 5, 4, 12, 5, 1
	DB	3, 11, 3, 1, 9, 5, 6, 1, 15, 9, 6, 14, 1, 3, 2
	DB	3, 7, 3, 6, 5, 4, 2, 6, 13, 5, 4, 3, 8, 1, 5
	DB	9, 7, 3, 2, 3, 7, 8, 1, 3, 2, 6, 10, 2, 10, 2
	DB	3, 6, 1, 18, 2, 3, 1, 5, 1, 11, 4, 3, 5, 6, 6
	DB	9, 7, 12, 18, 2, 10, 12, 5, 3, 1, 14, 3, 9, 4, 2
	DB	3, 4, 3, 2, 1, 6, 14, 9, 7, 8, 7, 9, 5, 4, 3
	DB	2, 3, 3, 4, 11, 6, 1, 5, 9, 3, 1, 9, 5, 1, 6
	DB	5, 9, 16, 3, 2, 3, 3, 4, 3, 3, 5, 10, 3, 6, 5
	DB	4, 5, 7, 3, 5, 7, 2, 1, 11, 9, 1, 5, 1, 2, 10
	DB	2, 1, 17, 1, 6, 3, 5, 1, 5, 9, 3, 7, 6, 6, 11
	DB	4, 3, 8, 3, 4, 2, 6, 3, 4, 2, 18, 3, 3, 10, 12
	DB	3, 6, 9, 5, 1, 5, 13, 3, 8, 4, 3, 2, 12, 9, 4
	DB	6, 6, 5, 9, 6, 1, 12, 2, 6, 9, 6, 7, 5, 1, 2
	DB	12, 6, 7, 5, 3, 1, 3, 2, 3, 13, 2, 3, 3, 1, 11
	DB	4, 9, 2, 9, 4, 2, 12, 1, 6, 6, 2, 1, 26, 1, 9
	DB	3, 2, 3, 6, 1, 3, 6, 5, 4, 2, 1, 12, 5, 1, 5
	DB	1, 6, 3, 9, 20, 3, 10, 8, 1, 6, 3, 5, 6, 1, 2
	DB	3, 7, 6, 6, 11, 3, 4, 2, 1, 8, 9, 6, 1, 3, 8
	DB	3, 1, 3, 2, 6, 15, 4, 8, 1, 9, 5, 12, 1, 3, 12
	DB	2, 1, 11, 1, 8, 1, 3, 6, 2, 9, 4, 2, 7, 2, 9
	DB	12, 3, 1, 3, 5, 1, 5, 19, 3, 5, 7, 3, 3, 12, 2
	DB	1, 6, 8, 7, 8, 6, 1, 3, 5, 13, 2, 1, 6, 3, 2
	DB	6, 4, 6, 5, 9, 3, 7, 14, 1, 3, 5, 1, 2, 7, 17
	DB	1, 3, 11, 1, 5, 7, 2, 1, 8, 4, 5, 3, 4, 5, 4
	DB	2, 3, 1, 8, 3, 3, 9, 15, 7, 3, 2, 15, 1, 5, 7
	DB	2, 10, 5, 4, 2, 4, 9, 2, 7, 3, 2, 12, 3, 3, 9
	DB	9, 1, 18, 3, 5, 7, 6, 2, 3, 1, 15, 3, 2, 1, 3
	DB	14, 10, 2, 10, 6, 12, 8, 9, 6, 7, 3, 2, 6, 16, 6
	DB	3, 5, 4, 5, 3, 9, 1, 8, 7, 3, 11, 3, 6, 1, 9
	DB	2, 4, 15, 6, 2, 6, 1, 5, 19, 11, 1, 2, 7, 3, 6
	DB	12, 2, 1, 2, 7, 6, 5, 1, 8, 3, 10, 2, 10, 11, 6
	DB	1, 2, 1, 6, 11, 12, 3, 3, 1, 3, 2, 3, 1, 5, 6
	DB	6, 3, 1, 3, 8, 4, 3, 2, 9, 6, 6, 7, 2, 6, 3
	DB	4, 3, 9, 3, 5, 6, 7, 3, 2, 4, 11, 3, 1, 14, 9
	DB	1, 9, 5, 3, 7, 5, 1, 5, 7, 3, 5, 1, 11, 3, 4
	DB	3, 8, 6, 4, 11, 1, 2, 7, 9, 6, 3, 12, 3, 5, 1
	DB	6, 11, 9, 3, 10, 3, 5, 7, 2, 1, 3, 6, 11, 7, 6
	DB	2, 3, 4, 11, 1, 5, 6, 4, 20, 1, 3, 5, 4, 2, 21
	DB	10, 2, 16, 6, 5, 3, 6, 6, 1, 5, 4, 3, 2, 4, 2
	DB	13, 9, 2, 4, 14, 3, 9, 3, 6, 1, 5, 3, 3, 7, 5
	DB	6, 7, 12, 3, 2, 10, 11, 1, 9, 2, 3, 6, 1, 8, 9
	DB	7, 3, 3, 2, 3, 4, 9, 2, 7, 15, 2, 9, 4, 5, 1
	DB	2, 4, 6, 2, 6, 9, 1, 6, 5, 1, 8, 4, 2, 15, 1
	DB	3, 14, 1, 5, 1, 9, 5, 7, 2, 13, 3, 9, 2, 10, 3
	DB	2, 4, 9, 2, 6, 13, 12, 2, 10, 11, 1, 9, 11, 1, 2
	DB	6, 1, 3, 3, 3, 2, 3, 7, 2, 12, 6, 3, 9, 1, 6
	DB	14, 7, 2, 3, 4, 11, 3, 6, 9, 4, 2, 10, 3, 2, 3
	DB	1, 9, 3, 2, 6, 6, 4, 14, 3, 4, 5, 1, 12, 6, 5
	DB	12, 4, 5, 10, 6, 3, 6, 6, 2, 7, 6, 12, 17, 9, 4
	DB	5, 3, 9, 4, 2, 4, 8, 7, 3, 2, 3, 12, 1, 3, 2
	DB	3, 1, 8, 3, 3, 10, 12, 2, 1, 2, 7, 2, 9, 1, 3
	DB	6, 2, 7, 2, 1, 9, 8, 3, 3, 1, 8, 10, 3, 3, 15
	DB	2, 4, 3, 12, 8, 3, 3, 4, 6, 15, 2, 9, 9, 4, 2
	DB	13, 5, 1, 11, 4, 5, 7, 3, 2, 9, 4, 6, 14, 1, 3
	DB	2, 6, 3, 12, 3, 4, 5, 10, 8, 4, 15, 3, 3, 2, 1
	DB	5, 7, 3, 5, 16, 11, 9, 1, 2, 1, 2, 4, 11, 4, 9
	DB	6, 14, 1, 8, 6, 9, 7, 5, 9, 6, 3, 16, 5, 7, 3
	DB	5, 1, 5, 1, 3, 11, 1, 2, 3, 4, 5, 3, 7, 3, 2
	DB	6, 15, 12, 3, 3, 4, 3, 2, 1, 2, 3, 4, 3, 3, 11
	DB	9, 4, 2, 1, 9, 3, 2, 1, 8, 9, 10, 5, 3, 3, 15
	DB	1, 6, 14, 3, 3, 3, 1, 6, 5, 4, 9, 9, 2, 4, 9
	DB	5, 1, 14, 1, 5, 7, 2, 1, 15, 6, 11, 13, 5, 4, 3
	DB	5, 4, 8, 7, 3, 3, 5, 7, 3, 2, 1, 5, 6, 1, 3
	DB	5, 4, 2, 1, 5, 13, 11, 3, 1, 6, 9, 2, 13, 2, 4
	DB	5, 3, 7, 5, 1, 9, 3, 5, 10, 3, 3, 2, 12, 1, 2
	DB	4, 3, 8, 7, 8, 9, 1, 2, 6, 1, 5, 1, 3, 6, 5
	DB	3, 3, 10, 3, 2, 3, 19, 2, 3, 6, 7, 2, 6, 4, 5
	DB	6, 6, 4, 2, 3, 7, 5, 3, 6, 1, 5, 9, 1, 9, 5
	DB	4, 5, 1, 6, 2, 7, 14, 1, 8, 1, 9, 3, 5, 3, 4
	DB	8, 7, 15, 5, 10, 3, 5, 12, 1, 14, 1, 6, 8, 3, 4
	DB	18, 2, 4, 2, 7, 6, 5, 4, 6, 2, 3, 4, 2, 3, 7
	DB	11, 4, 3, 2, 1, 5, 3, 10, 5, 4, 3, 3, 11, 9, 1
	DB	8, 3, 10, 2, 13, 2, 7, 11, 7, 2, 6, 3, 4, 2, 3
	DB	3, 13, 5, 1, 9, 9, 2, 1, 8, 1, 9, 2, 3, 4, 2
	DB	3, 6, 1, 3, 3, 14, 19, 2, 4, 8, 13, 2, 1, 5, 6
	DB	1, 5, 4, 3, 5, 6, 1, 5, 1, 12, 2, 15, 13, 3, 3
	DB	9, 3, 3, 11, 1, 5, 9, 13, 2, 9, 4, 3, 3, 6, 8
	DB	3, 4, 8, 3, 4, 8, 1, 21, 29, 4, 2, 3, 1, 2, 4
	DB	8, 3, 10, 2, 6, 6, 3, 6, 1, 5, 1, 3, 11, 1, 5
	DB	3, 4, 3, 5, 7, 3, 3, 2, 9, 4, 5, 4, 8, 7, 5
	DB	1, 5, 1, 6, 3, 2, 10, 5, 4, 26, 4, 5, 3, 1, 5
	DB	4, 5, 3, 3, 4, 5, 1, 11, 1, 2, 3, 7, 2, 1, 12
	DB	6, 2, 13, 9, 2, 3, 7, 15, 3, 2, 3, 1, 11, 4, 2
	DB	3, 1, 11, 3, 4, 8, 3, 7, 2, 3, 9, 4, 6, 3, 6
	DB	12, 15, 8, 4, 17, 4, 11, 3, 7, 5, 9, 7, 2, 6, 4
	DB	2, 18, 3, 3, 1, 5, 1, 2, 10, 3, 3, 5, 6, 3, 1
	DB	20, 4, 3, 14, 3, 1, 6, 9, 2, 12, 7, 3, 3, 5, 10
	DB	5, 7, 8, 7, 8, 3, 4, 18, 2, 6, 6, 3, 6, 25, 6
	DB	3, 2, 3, 3, 4, 3, 5, 1, 5, 1, 9, 5, 7, 8, 4
	DB	3, 2, 10, 2, 1, 5, 3, 7, 9, 5, 19, 5, 9, 1, 5
	DB	1, 6, 2, 1, 2, 7, 3, 5, 4, 20, 3, 10, 2, 6, 4
	DB	3, 17, 4, 11, 4, 6, 5, 1, 8, 21, 6, 4, 11, 4, 11
	DB	4, 3, 17, 1, 3, 2, 7, 3, 8, 1, 11, 3, 4, 12, 11
	DB	3, 1, 6, 2, 3, 7, 2, 4, 12, 2, 3, 3, 1, 11, 10
	DB	3, 2, 7, 2, 3, 3, 4, 3, 5, 3, 4, 3, 8, 7, 3
	DB	3, 11, 3, 12, 16, 3, 9, 3, 9, 5, 4, 15, 9, 3, 8
	DB	6, 3, 6, 1, 3, 2, 6, 4, 3, 11, 4, 3, 2, 7, 5
	DB	9, 10, 5, 1, 3, 2, 1, 14, 9, 1, 5, 3, 3, 3, 7
	DB	20, 12, 1, 2, 4, 6, 2, 10, 2, 16, 9, 8, 3, 18, 4
	DB	3, 2, 3, 7, 2, 3, 13, 3, 5, 7, 9, 5, 3, 3, 7
	DB	5, 3, 3, 7, 3, 12, 2, 7, 11, 4, 6, 5, 4, 6, 9
	DB	5, 9, 4, 12, 5, 4, 2, 12, 3, 9, 3, 1, 5, 15, 1
	DB	5, 1, 2, 1, 20, 1, 14, 4, 3, 3, 9, 3, 5, 7, 2
	DB	9, 15, 9, 1, 6, 15, 3, 15, 2, 9, 6, 1, 2, 7, 3
	DB	5, 3, 4, 3, 5, 6, 1, 3, 6, 5, 1, 9, 2, 10, 2
	DB	3, 7, 3, 3, 11, 3, 3, 4, 9, 9, 5, 1, 5, 1, 3
	DB	2, 3, 6, 9, 1, 5, 4, 2, 9, 1, 3, 3, 3, 5, 4
	DB	5, 3, 9, 6, 4, 6, 3, 2, 3, 7, 8, 1, 6, 2, 3
	DB	19, 3, 3, 8, 10, 14, 10, 5, 3, 3, 7, 2, 13, 2, 7
	DB	5, 9, 7, 14, 1, 2, 7, 8, 1, 14, 3, 4, 3, 17, 4
	DB	2, 9, 1, 8, 4, 3, 20, 4, 9, 2, 15, 3, 6, 1, 15
	DB	3, 5, 7, 20, 7, 5, 1, 6, 5, 4, 2, 4, 3, 3, 14
	DB	1, 2, 6, 7, 8, 4, 15, 8, 9, 1, 5, 9, 3, 16, 2
	DB	9, 3, 1, 6, 5, 9, 1, 3, 5, 7, 9, 14, 3, 4, 8
	DB	1, 2, 10, 5, 4, 9, 5, 1, 5, 4, 2, 3, 6, 3, 10
	DB	2, 1, 3, 2, 10, 5, 13, 9, 5, 1, 9, 3, 8, 7, 2
	DB	13, 2, 7, 5, 6, 7, 3, 3, 2, 7, 5, 1, 15, 9, 11
	DB	1, 8, 1, 2, 4, 3, 3, 8, 1, 3, 6, 5, 4, 6, 2
	DB	7, 2, 3, 10, 5, 6, 1, 3, 3, 2, 1, 5, 1, 15, 8
	DB	6, 10, 9, 2, 3, 1, 2, 4, 8, 7, 9, 11, 3, 1, 11
	DB	3, 3, 9, 1, 5, 18, 4, 2, 3, 10, 2, 6, 3, 7, 2
	DB	1, 14, 12, 4, 2, 3, 6, 15, 9, 16, 11, 4, 18, 3, 2
	DB	6, 1, 6, 2, 3, 10, 5, 9, 9, 4, 3, 2, 12, 4, 5
	DB	7, 3, 2, 4, 6, 8, 1, 8, 3, 4, 8, 6, 7, 5, 15
	DB	7, 2, 6, 4, 6, 3, 5, 1, 6, 14, 3, 6, 6, 10, 5
	DB	1, 5, 7, 3, 3, 15, 2, 4, 6, 2, 1, 5, 7, 2, 13
	DB	9, 6, 5, 3, 4, 2, 6, 3, 12, 9, 4, 5, 1, 6, 2
	DB	6, 6, 3, 1, 11, 1, 2, 1, 6, 8, 7, 5, 1, 8, 9
	DB	16, 2, 3, 10, 11, 4, 5, 1, 5, 3, 1, 2, 7, 3, 12
	DB	2, 4, 2, 3, 6, 6, 4, 3, 5, 6, 4, 5, 1, 5, 6
	DB	3, 6, 6, 10, 14, 10, 5, 7, 5, 4, 5, 3, 1, 2, 7
	DB	3, 3, 6, 3, 6, 5, 7, 5, 7, 8, 4, 5, 13, 2, 1
	DB	3, 2, 7, 2, 3, 6, 4, 3, 15, 9, 6, 3, 6, 8, 6
	DB	6, 1, 14, 3, 7, 5, 18, 1, 2, 3, 4, 6, 11, 9, 1
	DB	15, 9, 11, 10, 9, 5, 19, 3, 2, 1, 12, 2, 3, 3, 1
	DB	5, 3, 7, 5, 4, 2, 12, 7, 8, 7, 11, 3, 10, 5, 7
	DB	2, 6, 6, 1, 8, 4, 3, 3, 9, 2, 3, 7, 11, 3, 1
	DB	21, 8, 1, 5, 3, 1, 2, 3, 4, 5, 10, 8, 15, 4, 5
	DB	4, 5, 1, 15, 3, 3, 18, 5, 4, 8, 3, 1, 6, 14, 1
	DB	2, 3, 9, 6, 3, 4, 5, 1, 2, 25, 2, 10, 2, 15, 4
	DB	2, 3, 6, 1, 12, 2, 4, 9, 3, 2, 3, 4, 5, 1, 2
	DB	1, 20, 9, 18, 15, 15, 4, 8, 7, 3, 6, 14, 1, 11, 1
	DB	2, 6, 15, 6, 3, 1, 2, 7, 5, 1, 9, 11, 6, 9, 1
	DB	5, 9, 16, 3, 2, 1, 3, 5, 10, 6, 5, 3, 6, 10, 6
	DB	3, 2, 1, 8, 1, 8, 3, 7, 2, 1, 8, 1, 3, 8, 3
	DB	4, 2, 4, 11, 9, 4, 6, 2, 4, 3, 12, 11, 3, 1, 6
	DB	15, 3, 5, 6, 3, 1, 11, 3, 1, 6, 3, 11, 4, 6, 11
	DB	1, 5, 3, 9, 6, 1, 3, 6, 9, 3, 2, 10, 11, 4, 6
	DB	12, 8, 7, 5, 15, 9, 1, 3, 2, 7, 5, 1, 6, 5, 6
	DB	3, 1, 8, 6, 1, 3, 6, 5, 1, 5, 3, 1, 6, 6, 8
	DB	10, 5, 6, 4, 15, 5, 7, 2, 3, 4, 3, 2, 10, 9, 12
	DB	2, 6, 4, 2, 1, 12, 3, 12, 5, 1, 2, 3, 1, 3, 3
	DB	3, 2, 12, 1, 5, 6, 1, 3, 5, 4, 3, 5, 9, 1, 3
	DB	2, 10, 12, 5, 6, 1, 6, 3, 12, 2, 18, 7, 8, 4, 11
	DB	3, 4, 2, 1, 3, 11, 10, 8, 6, 9, 1, 6, 8, 3, 3
	DB	6, 3, 6, 1, 3, 6, 5, 4, 8, 4, 3, 8, 4, 6, 2
	DB	3, 3, 10, 6, 6, 2, 3, 10, 2, 6, 1, 5, 1, 3, 15
	DB	11, 3, 1, 2, 19, 5, 1, 2, 1, 11, 1, 8, 1, 3, 5
	DB	10, 3, 12, 2, 6, 7, 6, 2, 19, 5, 15, 3, 1, 6, 6
	DB	2, 3, 15, 7, 2, 4, 9, 18, 2, 3, 10, 2, 1, 6, 5
	DB	1, 3, 5, 6, 3, 6, 4, 3, 3, 12, 2, 15, 10, 3, 18
	DB	5, 1, 6, 3, 2, 4, 3, 2, 6, 4, 3, 6, 2, 3, 7
	DB	2, 10, 6, 2, 3, 9, 1, 2, 9, 1, 8, 6, 15, 3, 3
	DB	4, 20, 4, 24, 3, 8, 9, 7, 6, 3, 9, 2, 10, 5, 1
	DB	3, 5, 4, 15, 2, 6, 10, 3, 6, 3, 3, 17, 3, 3, 9
	DB	3, 4, 5, 6, 3, 4, 5, 1, 2, 12, 3, 4, 11, 3, 1
	DB	6, 3, 5, 6, 3, 12, 3, 7, 6, 18, 2, 12, 1, 5, 4
	DB	5, 3, 7, 5, 16, 2, 4, 5, 6, 13, 9, 2, 3, 10, 2
	DB	10, 3, 8, 3, 1, 15, 6, 3, 5, 1, 3, 5, 6, 4, 2
	DB	1, 3, 5, 6, 13, 11, 4, 3, 2, 7, 3, 3, 15, 2, 3
	DB	7, 2, 1, 14, 1, 3, 11, 4, 2, 9, 9, 9, 1, 6, 3
	DB	2, 10, 5, 3, 3, 7, 5, 6, 1, 6, 15, 17, 6, 4, 3
	DB	2, 1, 5, 1, 8, 6, 1, 5, 4, 9, 12, 3, 2, 6, 7
	DB	2, 4, 2, 7, 2, 3, 3, 10, 3, 2, 4, 9, 26, 1, 2
	DB	6, 4, 2, 19, 2, 13, 12, 8, 6, 3, 1, 6, 6, 8, 1
	DB	3, 3, 2, 6, 7, 8, 4, 6, 9, 8, 3, 4, 5, 3, 7
	DB	5, 6, 1, 5, 1, 2, 12, 3, 21, 12, 4, 5, 3, 3, 3
	DB	1, 6, 2, 7, 3, 3, 14, 3, 1, 5, 6, 6, 3, 10, 2
	DB	3, 7, 2, 1, 6, 5, 6, 12, 3, 4, 3, 3, 2, 12, 6
	DB	10, 8, 7, 15, 9, 3, 2, 13, 6, 2, 3, 1, 3, 2, 1
	DB	14, 4, 20, 1, 5, 4, 2, 10, 3, 9, 5, 1, 2, 22, 3
	DB	9, 6, 3, 2, 3, 1, 11, 3, 7, 15, 5, 12, 1, 5, 4
	DB	8, 9, 1, 9, 11, 4, 5, 3, 3, 7, 2, 4, 9, 2, 1
	DB	9, 9, 9, 3, 2, 12, 9, 1, 8, 3, 3, 9, 10, 8, 10
	DB	2, 7, 3, 2, 10, 9, 5, 1, 3, 5, 12, 1, 5, 12, 3
	DB	3, 12, 3, 6, 1, 14, 6, 7, 3, 3, 6, 3, 11, 6, 6
	DB	4, 18, 2, 6, 7, 2, 10, 5, 6, 12, 1, 2, 3, 6, 1
	DB	2, 1, 5, 6, 13, 3, 8, 4, 2, 4, 5, 4, 3, 17, 1
	DB	6, 8, 12, 3, 1, 5, 1, 9, 2, 4, 3, 8, 3, 1, 3
	DB	3, 3, 2, 7, 2, 10, 3, 2, 10, 3, 6, 11, 3, 1, 5
	DB	6, 1, 3, 2, 4, 6, 2, 7, 6, 5, 7, 2, 6, 13, 5
	DB	7, 2, 13, 3, 15, 2, 9, 9, 4, 3, 8, 4, 5, 7, 5
	DB	4, 5, 10, 11, 10, 8, 1, 9, 3, 2, 3, 3, 6, 1, 5
	DB	13, 2, 4, 9, 9, 3, 9, 3, 2, 3, 12, 3, 10, 17, 13
	DB	5, 1, 14, 6, 4, 5, 6, 1, 3, 11, 1, 6, 8, 1, 3
	DB	3, 5, 7, 8, 10, 3, 2, 19, 3, 5, 3, 4, 8, 21, 1
	DB	3, 2, 3, 3, 3, 7, 8, 7, 2, 10, 5, 1, 2, 4, 9
	DB	5, 6, 18, 1, 5, 21, 4, 2, 10, 12, 8, 4, 11, 3, 4
	DB	2, 1, 3, 11, 3, 3, 4, 14, 1, 5, 9, 7, 3, 2, 9
	DB	4, 5, 7, 2, 6, 4, 5, 6, 7, 2, 1, 6, 6, 2, 3
	DB	9, 15, 6, 19, 3, 6, 5, 1, 9, 5, 6, 4, 2, 4, 3
	DB	2, 1, 12, 6, 9, 2, 1, 2, 1, 29, 6, 4, 12, 5, 1
	DB	2, 3, 3, 6, 1, 2, 7, 3, 3, 8, 6, 1, 2, 16, 2
	DB	12, 3, 3, 4, 5, 1, 11, 9, 6, 10, 3, 15, 2, 15, 3
	DB	1, 2, 7, 3, 2, 7, 8, 1, 6, 5, 1, 3, 6, 6, 5
	DB	3, 4, 11, 4, 6, 6, 3, 8, 3, 9, 10, 11, 9, 1, 11
	DB	1, 8, 1, 11, 7, 5, 10, 5, 16, 2, 4, 5, 3, 1, 11
	DB	3, 6, 1, 3, 2, 1, 2, 7, 6, 12, 5, 1, 6, 8, 1
	DB	2, 3, 7, 3, 5, 6, 1, 8, 7, 17, 6, 1, 3, 3, 3
	DB	2, 10, 5, 13, 6, 6, 2, 1, 2, 4, 5, 1, 2, 1, 11
	DB	3, 3, 7, 2, 9, 6, 13, 3, 5, 4, 8, 1, 2, 10, 5
	DB	3, 21, 1, 5, 3, 4, 12, 6, 3, 2, 3, 6, 1, 14, 4
	DB	6, 9, 9, 3, 23, 4, 5, 3, 7, 2, 1, 3, 2, 3, 21
	DB	4, 5, 4, 5, 1, 9, 2, 3, 6, 6, 1, 2, 10, 5, 6
	DB	6, 4, 2, 13, 9, 11, 4, 3, 8, 7, 8, 1, 9, 5, 1
	DB	3, 3, 5, 7, 2, 1, 15, 2, 1, 2, 4, 5, 3, 1, 6
	DB	8, 3, 28, 5, 1, 6, 5, 4, 6, 3, 2, 7, 5, 1, 2
	DB	4, 3, 2, 10, 3, 6, 11, 3, 16, 5, 1, 5, 6, 7, 3
	DB	14, 18, 3, 3, 1, 6, 2, 3, 3, 4, 11, 1, 9, 5, 1
	DB	3, 2, 10, 5, 4, 2, 3, 7, 9, 3, 21, 11, 1, 2, 1
	DB	14, 1, 2, 9, 3, 3, 3, 6, 1, 12, 5, 18, 3, 1, 6
	DB	5, 13, 12, 9, 8, 3, 3, 7, 12, 6, 2, 4, 3, 6, 2
	DB	4, 8, 10, 20, 13, 2, 6, 1, 3, 2, 1, 5, 7, 5, 1
	DB	2, 13, 6, 14, 1, 8, 13, 3, 5, 1, 3, 5, 3, 4, 3
	DB	3, 3, 5, 6, 3, 10, 20, 10, 2, 1, 8, 6, 3, 6, 4
	DB	2, 9, 1, 6, 5, 13, 6, 8, 1, 9, 12, 6, 2, 7, 11
	DB	10, 5, 7, 6, 2, 9, 6, 4, 5, 6, 3, 15, 7, 2, 12
	DB	3, 15, 3, 3, 1, 3, 11, 16, 3, 2, 3, 3, 10, 8, 1
	DB	5, 4, 6, 5, 1, 3, 5, 4, 8, 18, 4, 3, 2, 1, 14
	DB	1, 14, 6, 1, 5, 3, 7, 5, 3, 3, 3, 4, 3, 2, 7
	DB	9, 2, 3, 6, 1, 5, 9, 4, 15, 20, 1, 9, 2, 3, 7
	DB	9, 3, 2, 6, 3, 6, 3, 7, 5, 13, 3, 8, 1, 8, 15
	DB	1, 5, 1, 21, 3, 14, 7, 3, 5, 1, 6, 9, 6, 3, 5
	DB	6, 6, 10, 3, 2, 1, 5, 3, 6, 6, 7, 6, 17, 3, 1
	DB	6, 5, 3, 4, 3, 2, 6, 19, 3, 5, 9, 1, 14, 1, 3
	DB	6, 15, 8, 1, 5, 4, 2, 1, 8, 9, 13, 2, 3, 4, 9
	DB	11, 3, 10, 2, 3, 6, 1, 3, 6, 2, 9, 3, 1, 11, 6
	DB	4, 3, 8, 9, 15, 6, 12, 1, 5, 1, 3, 3, 2, 3, 18
	DB	7, 3, 11, 1, 29, 4, 6, 3, 5, 1, 20, 4, 3, 14, 1
	DB	2, 7, 3, 3, 9, 5, 4, 2, 7, 2, 4, 15, 2, 3, 4
	DB	3, 3, 9, 2, 1, 2, 7, 6, 9, 5, 1, 2, 6, 1, 5
	DB	4, 5, 7, 5, 9, 6, 4, 3, 5, 7, 5, 4, 11, 1, 3
	DB	11, 6, 3, 4, 6, 14, 1, 24, 6, 2, 9, 4, 5, 7, 5
	DB	7, 2, 6, 15, 12, 3, 4, 3, 2, 4, 27, 2, 1, 5, 6
	DB	4, 5, 6, 6, 9, 1, 12, 2, 4, 11, 6, 10, 2, 6, 1
	DB	6, 8, 1, 14, 1, 3, 12, 5, 1, 14, 1, 2, 10, 2, 6
	DB	3, 7, 2, 3, 7, 11, 12, 10, 2, 7, 3, 3, 5, 15, 4
	DB	5, 9, 1, 3, 3, 8, 1, 3, 3, 2, 1, 12, 2, 1, 12
	DB	5, 3, 1, 5, 1, 3, 11, 4, 2, 4, 3, 2, 9, 1, 9
	DB	2, 4, 8, 13, 2, 3, 4, 11, 10, 8, 4, 2, 3, 12, 3
	DB	7, 6, 8, 1, 6, 2, 7, 5, 1, 2, 6, 9, 16, 5, 7
	DB	12, 6, 20, 4, 17, 6, 7, 2, 9, 1, 14, 6, 10, 3, 5
	DB	1, 20, 9, 7, 6, 2, 18, 3, 1, 11, 3, 7, 5, 12, 21
	DB	1, 8, 1, 17, 4, 3, 2, 1, 2, 7, 20, 4, 6, 3, 12
	DB	9, 2, 3, 1, 3, 2, 1, 2, 1, 12, 5, 4, 3, 3, 5
	DB	7, 3, 8, 9, 7, 9, 12, 2, 3, 3, 4, 2, 10, 5, 3
	DB	6, 1, 6, 2, 7, 3, 3, 3, 2, 7, 8, 18, 7, 3, 2
	DB	7, 2, 3, 12, 4, 2, 10, 5, 7, 6, 17, 4, 5, 3, 3
	DB	3, 7, 2, 7, 6, 3, 5, 9, 7, 5, 6, 3, 1, 3, 3
	DB	14, 1, 2, 12, 3, 1, 2, 4, 8, 3, 10, 2, 1, 5, 1
	DB	5, 4, 32, 3, 4, 6, 2, 7, 6, 5, 1, 6, 3, 5, 9
	DB	12, 3, 1, 5, 4, 3, 8, 10, 2, 7, 3, 3, 6, 3, 2
	DB	3, 1, 2, 4, 11, 3, 4, 2, 1, 8, 9, 7, 3, 11, 7
	DB	5, 7, 2, 3, 1, 2, 7, 5, 6, 4, 8, 4, 5, 4, 12
	DB	20, 3, 6, 1, 3, 9, 2, 1, 2, 15, 1, 15, 2, 4, 9
	DB	6, 6, 2, 1, 2, 7, 18, 8, 9, 1, 6, 5, 3, 6, 9
	DB	1, 9, 3, 3, 11, 9, 19, 3, 5, 9, 1, 5, 4, 3, 8
	DB	12, 7, 3, 2, 3, 7, 8, 12, 3, 6, 4, 6, 5, 7, 23
	DB	1, 8, 1, 11, 3, 1, 5, 1, 5, 1, 3, 2, 10, 5, 3
	DB	15, 4, 3, 3, 2, 15, 4, 3, 3, 3, 11, 18, 1, 2, 4
	DB	3, 3, 2, 7, 6, 5, 10, 2, 1, 2, 15, 3, 7, 8, 6
	DB	15, 1, 2, 3, 4, 15, 5, 4, 17, 9, 6, 4, 11, 10, 2
	DB	7, 5, 10, 3, 2, 1, 5, 7, 2, 13, 3, 18, 6, 9, 2
	DB	4, 3, 2, 3, 1, 14, 3, 3, 12, 4, 5, 13, 3, 12, 2
	DB	4, 12, 5, 10, 2, 1, 5, 7, 8, 1, 3, 3, 2, 3, 4
	DB	9, 14, 7, 3, 8, 7, 3, 2, 3, 3, 4, 2, 1, 2, 6
	DB	1, 6, 3, 6, 14, 1, 3, 6, 5, 7, 2, 22, 3, 5, 1
	DB	6, 6, 15, 2, 6, 1, 3, 5, 6, 1, 5, 1, 5, 3, 4
	DB	5, 3, 7, 8, 4, 3, 6, 5, 1, 5, 4, 6, 5, 9, 4
	DB	2, 1, 2, 13, 3, 11, 3, 7, 5, 3, 1, 14, 3, 4, 23
	DB	3, 3, 9, 3, 3, 4, 3, 5, 9, 1, 3, 6, 9, 5, 4
	DB	6, 15, 5, 1, 5, 1, 2, 3, 9, 1, 2, 10, 6, 2, 3
	DB	4, 17, 3, 3, 12, 6, 4, 18, 8, 1, 3, 2, 1, 2, 3
	DB	10, 3, 12, 2, 1, 2, 9, 10, 3, 11, 4, 23, 9, 1, 8
	DB	10, 11, 1, 12, 11, 1, 8, 12, 10, 8, 1, 2, 4, 5, 1
	DB	5, 7, 2, 4, 9, 2, 4, 2, 7, 5, 1, 12, 8, 4, 3
	DB	8, 10, 5, 1, 3, 2, 15, 1, 8, 16, 3, 6, 5, 12, 4
	DB	6, 9, 8, 1, 6, 3, 2, 6, 3, 1, 14, 9, 1, 11, 3
	DB	3, 3, 1, 3, 8, 7, 3, 15, 8, 1, 5, 1, 2, 6, 1
	DB	6, 5, 7, 3, 5, 4, 14, 1, 18, 3, 8, 7, 2, 10, 12
	DB	3, 2, 4, 2, 9, 4, 2, 7, 2, 3, 1, 12, 8, 7, 2
	DB	13, 8, 1, 5, 16, 3, 2, 3, 6, 3, 18, 4, 6, 2, 1
	DB	2, 4, 3, 2, 10, 6, 5, 12, 6, 1, 6, 5, 3, 6, 1
	DB	3, 9, 2, 3, 3, 3, 4, 12, 3, 5, 6, 15, 7, 5, 4
	DB	6, 3, 5, 6, 1, 9, 3, 2, 4, 2, 12, 10, 2, 4, 5
; .415 sec
DB 0
IFDEF FOO
	DB	6, 4, 6, 8, 3, 7, 2, 4, 2, 9, 25, 3, 3, 2, 3
	DB	4, 3, 5, 13, 5, 3, 1, 5, 1, 5, 3, 19, 6, 2, 4
	DB	5, 10, 3, 3, 3, 9, 5, 1, 6, 8, 1, 6, 6, 2, 13
	DB	5, 3, 10, 9, 20, 6, 4, 5, 6, 1, 9, 6, 5, 1, 5
	DB	13, 2, 3, 6, 4, 2, 15, 3, 1, 3, 8, 12, 12, 9, 6
	DB	6, 4, 3, 2, 4, 5, 4, 3, 2, 10, 5, 13, 2, 12, 3
	DB	1, 6, 21, 9, 3, 2, 13, 3, 14, 3, 1, 5, 4, 3, 3
	DB	5, 4, 5, 1, 11, 1, 2, 10, 2, 3, 18, 7, 2, 10, 11
	DB	3, 7, 3, 5, 4, 2, 1, 2, 7, 9, 17, 4, 11, 7, 5
	DB	12, 3, 1, 5, 1, 3, 5, 13, 9, 5, 9, 12, 9, 1, 12
	DB	20, 1, 2, 3, 1, 3, 5, 13, 3, 6, 6, 3, 2, 18, 1
	DB	5, 6, 12, 1, 2, 4, 5, 3, 1, 2, 12, 1, 2, 18, 1
	DB	11, 7, 12, 9, 21, 3, 5, 1, 12, 8, 6, 1, 2, 1, 5
	DB	1, 5, 4, 2, 18, 4, 2, 6, 9, 3, 3, 7, 11, 1, 3
	DB	12, 3, 5, 12, 10, 11, 3, 7, 18, 14, 3, 4, 3, 12, 3
	DB	6, 14, 1, 9, 2, 1, 2, 10, 11, 4, 5, 1, 9, 2, 4
	DB	5, 7, 5, 3, 4, 3, 3, 6, 8, 6, 7, 5, 9, 1, 5
	DB	12, 12, 3, 6, 1, 11, 3, 10, 11, 1, 2, 6, 1, 3, 18
	DB	3, 11, 3, 1, 14, 6, 9, 1, 2, 7, 3, 2, 1, 5, 1
	DB	8, 1, 5, 4, 3, 5, 9, 6, 3, 7, 2, 3, 9, 6, 13
	DB	2, 3, 7, 3, 5, 6, 1, 2, 1, 5, 12, 4, 5, 16, 5
	DB	4, 5, 3, 1, 9, 6, 14, 15, 1, 9, 2, 3, 7, 3, 2
	DB	4, 11, 4, 15, 9, 5, 13, 2, 1, 11, 4, 2, 4, 3, 2
	DB	13, 2, 6, 10, 9, 3, 6, 5, 9, 1, 2, 3, 1, 6, 14
	DB	3, 10, 3, 8, 4, 3, 3, 2, 3, 10, 6, 3, 2, 10, 3
	DB	8, 3, 16, 5, 9, 1, 6, 8, 12, 3, 4, 6, 17, 3, 10
	DB	11, 1, 8, 7, 3, 2, 7, 3, 12, 15, 2, 4, 6, 3, 8
	DB	10, 5, 7, 2, 1, 8, 6, 1, 5, 4, 3, 15, 6, 5, 7
	DB	5, 4, 5, 3, 1, 2, 7, 5, 1, 5, 16, 9, 2, 4, 14
	DB	10, 2, 10, 3, 2, 15, 4, 3, 11, 9, 6, 1, 5, 6, 3
	DB	9, 3, 27, 3, 7, 2, 3, 3, 7, 12, 3, 6, 5, 6, 3
	DB	12, 6, 9, 4, 9, 2, 1, 2, 1, 11, 4, 5, 1, 6, 5
	DB	7, 3, 2, 1, 6, 23, 3, 3, 1, 3, 3, 15, 5, 4, 3
	DB	6, 2, 7, 3, 8, 6, 4, 5, 10, 9, 5, 3, 3, 6, 1
	DB	5, 7, 2, 1, 2, 12, 6, 4, 9, 2, 4, 8, 7, 6, 5
	DB	9, 6, 4, 9, 2, 7, 2, 3, 1, 11, 9, 4, 5, 13, 2
	DB	1, 12, 3, 2, 3, 6, 13, 2, 4, 5, 9, 3, 7, 5, 6
	DB	1, 6, 3, 2, 4, 6, 8, 1, 5, 3, 1, 11, 1, 2, 7
	DB	9, 5, 6, 10, 5, 3, 1, 2, 7, 6, 2, 4, 5, 1, 3
	DB	17, 3, 1, 8, 6, 4, 11, 4, 15, 5, 1, 12, 2, 7, 5
	DB	10, 8, 1, 2, 10, 5, 3, 4, 2, 4, 2, 12, 3, 7, 2
	DB	16, 2, 3, 7, 3, 2, 1, 11, 30, 1, 3, 12, 2, 7, 9
	DB	6, 9, 6, 3, 2, 15, 1, 8, 1, 11, 7, 8, 9, 3, 18
	DB	3, 9, 1, 5, 4, 2, 1, 3, 12, 9, 15, 3, 3, 17, 7
	DB	3, 26, 1, 8, 6, 7, 8, 4, 15, 2, 1, 3, 5, 6, 1
	DB	14, 3, 7, 6, 14, 9, 10, 2, 4, 3, 3, 2, 3, 4, 11
	DB	3, 12, 4, 3, 6, 6, 3, 6, 2, 10, 23, 9, 7, 5, 1
	DB	12, 2, 1, 12, 11, 7, 5, 3, 16, 6, 2, 1, 5, 1, 5
	DB	1, 2, 3, 3, 6, 6, 7, 3, 3, 14, 1, 9, 3, 3, 2
	DB	12, 1, 6, 6, 3, 2, 12, 12, 1, 3, 2, 19, 3, 5, 6
	DB	1, 6, 2, 10, 11, 6, 1, 5, 3, 9, 21, 6, 1, 3, 6
	DB	11, 7, 5, 3, 3, 1, 5, 9, 7, 2, 13, 8, 6, 4, 9
	DB	2, 1, 5, 4, 3, 2, 3, 3, 3, 7, 8, 1, 6, 3, 5
	DB	6, 1, 12, 2, 9, 1, 9, 5, 6, 10, 3, 8, 7, 3, 3
	DB	6, 8, 6, 10, 2, 4, 3, 17, 13, 5, 15, 3, 12, 3, 13
	DB	6, 8, 1, 5, 6, 1, 5, 3, 4, 21, 2, 4, 3, 2, 9
	DB	1, 3, 3, 3, 5, 4, 2, 3, 15, 6, 9, 12, 4, 2, 3
	DB	4, 5, 1, 2, 4, 8, 3, 19, 3, 3, 3, 15, 2, 7, 3
	DB	5, 4, 5, 13, 3, 9, 5, 3, 1, 24, 6, 17, 4, 6, 8
	DB	4, 3, 8, 7, 5, 7, 2, 3, 3, 7, 8, 3, 6, 1, 27
	DB	8, 3, 6, 1, 3, 17, 9, 3, 1, 9, 3, 2, 1, 12, 9
	DB	6, 2, 1, 6, 3, 3, 2, 6, 1, 5, 9, 4, 3, 2, 3
	DB	9, 3, 7, 3, 5, 3, 4, 5, 1, 17, 7, 15, 3, 2, 1
	DB	24, 14, 1, 3, 5, 6, 4, 2, 1, 3, 6, 6, 3, 2, 9
	DB	3, 6, 4, 2, 1, 3, 11, 1, 2, 7, 11, 15, 3, 1, 3
	DB	2, 3, 13, 2, 7, 8, 6, 4, 2, 1, 8, 7, 14, 6, 10
	DB	2, 6, 1, 3, 6, 5, 1, 9, 2, 7, 17, 6, 7, 2, 4
	DB	9, 8, 4, 9, 2, 3, 15, 7, 8, 4, 2, 3, 10, 32, 4
	DB	2, 7, 3, 17, 1, 27, 9, 9, 2, 3, 6, 10, 3, 12, 8
	DB	3, 3, 7, 2, 1, 11, 3, 7, 6, 2, 7, 18, 5, 1, 2
	DB	7, 5, 3, 4, 8, 3, 10, 2, 7, 5, 10, 5, 9, 4, 2
	DB	1, 5, 7, 2, 10, 9, 5, 9, 1, 9, 2, 4, 11, 9, 4
	DB	2, 1, 5, 4, 3, 3, 5, 7, 8, 4, 8, 1, 2, 4, 21
	DB	2, 6, 9, 1, 11, 6, 4, 9, 9, 2, 1, 17, 1, 2, 7
	DB	6, 2, 4, 6, 2, 7, 8, 22, 3, 3, 3, 14, 15, 1, 9
	DB	6, 6, 5, 4, 11, 1, 3, 2, 9, 3, 18, 3, 4, 2, 1
	DB	2, 3, 7, 5, 3, 3, 7, 2, 1, 5, 1, 3, 2, 10, 5
	DB	6, 12, 6, 7, 5, 12, 3, 4, 5, 6, 3, 1, 3, 6, 5
	DB	1, 14, 1, 5, 9, 12, 7, 6, 9, 3, 5, 4, 5, 13, 3
	DB	2, 6, 4, 2, 3, 13, 5, 4, 5, 1, 8, 1, 5, 13, 5
	DB	1, 9, 2, 3, 10, 6, 2, 3, 4, 6, 5, 1, 9, 11, 1
	DB	5, 22, 2, 10, 5, 19, 2, 7, 6, 5, 1, 5, 1, 2, 1
	DB	5, 7, 5, 4, 3, 3, 5, 3, 9, 3, 9, 13, 15, 3, 8
	DB	6, 4, 2, 3, 7, 18, 5, 16, 11, 19, 6, 2, 7, 5, 4
	DB	2, 4, 5, 10, 5, 1, 8, 10, 30, 6, 3, 2, 9, 9, 1
	DB	6, 5, 1, 12, 3, 5, 7, 3, 2, 1, 2, 4, 3, 5, 3
	DB	3, 7, 3, 6, 3, 2, 15, 15, 9, 1, 9, 2, 9, 3, 15
	DB	3, 3, 1, 14, 7, 8, 1, 9, 5, 4, 2, 1, 2, 3, 3
	DB	4, 2, 9, 4, 6, 20, 1, 6, 3, 2, 19, 6, 3, 5, 1
	DB	3, 8, 3, 19, 2, 10, 3, 5, 1, 12, 5, 3, 1, 15, 8
	DB	3, 7, 2, 3, 13, 18, 9, 2, 4, 2, 12, 10, 2, 1, 2
	DB	6, 6, 6, 3, 19, 2, 6, 3, 6, 6, 7, 2, 6, 3, 4
	DB	15, 12, 5, 1, 9, 8, 3, 3, 1, 5, 4, 11, 3, 1, 2
	DB	7, 5, 3, 3, 1, 11, 10, 3, 15, 2, 3, 7, 2, 10, 11
	DB	6, 15, 3, 1, 9, 5, 3, 4, 5, 4, 5, 7, 5, 9, 9
	DB	4, 3, 5, 7, 2, 3, 1, 2, 4, 9, 5, 1, 3, 3, 12
	DB	2, 3, 1, 5, 6, 1, 17, 3, 13, 15, 11, 10, 3, 18, 8
	DB	6, 1, 2, 3, 3, 6, 1, 9, 11, 7, 3, 12, 2, 25, 8
	DB	1, 6, 8, 6, 4, 12, 6, 8, 9, 12, 4, 2, 3, 1, 3
	DB	6, 6, 8, 6, 9, 7, 3, 2, 1, 2, 6, 1, 5, 6, 9
	DB	1, 3, 2, 9, 3, 3, 4, 6, 2, 1, 2, 3, 1, 3, 2
	DB	1, 2, 6, 10, 2, 7, 3, 23, 4, 20, 1, 6, 8, 1, 2
	DB	4, 5, 1, 17, 10, 8, 7, 11, 4, 2, 6, 12, 1, 9, 5
	DB	12, 15, 1, 12, 5, 13, 17, 1, 2, 4, 9, 5, 1, 8, 1
	DB	2, 7, 6, 5, 9, 3, 24, 4, 2, 3, 6, 6, 7, 5, 3
	DB	3, 7, 3, 6, 6, 9, 5, 1, 12, 3, 2, 3, 3, 12, 15
	DB	7, 2, 3, 13, 2, 1, 2, 7, 2, 4, 15, 5, 4, 2, 9
	DB	6, 4, 5, 7, 14, 3, 15, 6, 16, 8, 3, 3, 4, 3, 27
	DB	3, 9, 3, 8, 3, 1, 6, 2, 12, 1, 3, 5, 1, 5, 4
	DB	5, 1, 11, 15, 3, 4, 2, 4, 2, 4, 8, 1, 5, 9, 3
	DB	7, 6, 12, 3, 6, 6, 14, 13, 3, 12, 2, 6, 3, 1, 18
	DB	2, 3, 6, 10, 9, 3, 2, 3, 9, 1, 5, 10, 9, 5, 6
	DB	7, 6, 5, 10, 11, 1, 3, 5, 1, 3, 2, 3, 3, 9, 1
	DB	18, 11, 4, 15, 5, 1, 14, 7, 5, 12, 3, 4, 5, 9, 4
	DB	2, 1, 5, 9, 3, 10, 3, 8, 7, 17, 3, 4, 5, 3, 3
	DB	3, 1, 3, 2, 1, 5, 7, 2, 6, 4, 3, 6, 2, 3, 1
	DB	6, 2, 1, 2, 4, 5, 1, 14, 1, 15, 8, 1, 3, 11, 9
	DB	7, 3, 21, 5, 1, 3, 3, 9, 5, 9, 4, 5, 6, 1, 5
	DB	19, 2, 7, 6, 2, 3, 7, 18, 6, 5, 4, 6, 5, 3, 12
	DB	6, 7, 3, 2, 7, 5, 6, 4, 8, 12, 1, 2, 1, 5, 15
	DB	7, 23, 9, 3, 9, 3, 1, 9, 6, 6, 5, 3, 21, 1, 3
	DB	3, 8, 4, 3, 8, 9, 7, 11, 4, 6, 2, 1, 2, 10, 3
	DB	5, 6, 4, 2, 12, 3, 7, 2, 1, 5, 9, 15, 4, 5, 4
	DB	3, 15, 2, 12, 1, 5, 3, 7, 8, 1, 5, 4, 5, 6, 13
	DB	6, 5, 1, 11, 4, 5, 1, 8, 12, 7, 2, 3, 3, 27, 1
	DB	2, 4, 3, 6, 5, 1, 11, 4, 3, 20, 1, 12, 8, 6, 1
	DB	3, 11, 1, 3, 6, 3, 2, 10, 3, 3, 5, 3, 4, 5, 6
	DB	1, 11, 3, 1, 5, 13, 2, 1, 3, 5, 6, 3, 10, 11, 7
	DB	2, 1, 5, 1, 21, 2, 3, 4, 3, 2, 10, 6, 17, 10, 8
	DB	3, 1, 9, 11, 1, 3, 14, 1, 2, 3, 7, 2, 10, 23, 9
	DB	4, 2, 7, 6, 5, 1, 6, 3, 12, 2, 3, 4, 11, 18, 7
	DB	3, 11, 6, 3, 7, 8, 1, 6, 14, 4, 2, 4, 3, 2, 9
	DB	4, 11, 4, 2, 3, 15, 6, 1, 9, 6, 6, 9, 6, 9, 3
	DB	2, 1, 2, 3, 7, 2, 18, 3, 27, 3, 3, 4, 5, 6, 7
	DB	2, 1, 5, 1, 3, 11, 1, 14, 7, 3, 2, 4, 18, 3, 2
	DB	3, 12, 12, 1, 2, 1, 6, 5, 19, 2, 13, 14, 1, 5, 9
	DB	21, 7, 5, 10, 8, 1, 3, 3, 3, 11, 10, 3, 5, 3, 10
	DB	2, 1, 6, 3, 5, 1, 5, 1, 11, 7, 5, 6, 6, 1, 5
	DB	7, 6, 2, 7, 2, 4, 5, 1, 9, 6, 5, 15, 1, 3, 12
	DB	5, 4, 5, 1, 5, 9, 3, 12, 3, 1, 9, 5, 1, 6, 3
	DB	3, 9, 18, 3, 2, 7, 6, 3, 5, 7, 5, 7, 15, 3, 5
	DB	3, 10, 6, 9, 11, 6, 4, 3, 2, 6, 7, 2, 21, 15, 4
	DB	14, 6, 3, 3, 3, 4, 5, 10, 6, 2, 9, 3, 7, 5, 3
	DB	6, 1, 9, 2, 4, 8, 1, 5, 7, 2, 6, 16, 3, 3, 3
	DB	2, 7, 2, 6, 4, 3, 6, 5, 4, 5, 1, 5, 4, 2, 1
	DB	2, 15, 10, 2, 3, 3, 3, 1, 9, 11, 1, 2, 7, 21, 8
	DB	6, 3, 6, 1, 5, 4, 20, 15, 4, 2, 6, 4, 9, 2, 4
	DB	3, 3, 5, 3, 1, 3, 5, 1, 5, 12, 9, 9, 1, 3, 3
	DB	8, 9, 3, 4, 3, 8, 4, 8, 3, 3, 6, 3, 1, 6, 8
	DB	1, 6, 5, 1, 2, 12, 13, 5, 7, 5, 3, 18, 12, 1, 27
	DB	5, 7, 8, 3, 10, 6, 5, 3, 6, 1, 6, 2, 13, 2, 7
	DB	5, 3, 1, 2, 3, 1, 5, 1, 8, 6, 9, 9, 7, 8, 1
	DB	9, 3, 14, 1, 2, 1, 5, 6, 10, 6, 2, 3, 3, 10, 11
	DB	1, 2, 10, 8, 12, 1, 2, 3, 1, 21, 3, 2, 9, 3, 6
	DB	4, 2, 1, 3, 9, 3, 12, 2, 9, 9, 1, 5, 1, 20, 1
	DB	5, 15, 4, 9, 11, 1, 5, 4, 8, 6, 15, 4, 3, 3, 5
	DB	6, 3, 1, 9, 2, 15, 4, 5, 7, 2, 3, 4, 15, 3, 5
	DB	7, 9, 5, 9, 3, 4, 11, 4, 3, 8, 13, 11, 6, 3, 4
	DB	6, 5, 10, 5, 10, 9, 2, 6, 9, 16, 2, 1, 9, 2, 3
	DB	6, 4, 3, 3, 5, 4, 11, 6, 1, 3, 2, 7, 5, 10, 2
	DB	1, 14, 1, 5, 4, 9, 6, 3, 8, 4, 3, 5, 12, 3, 6
	DB	4, 2, 1, 2, 10, 15, 2, 6, 7, 2, 4, 2, 10, 5, 12
	DB	12, 6, 4, 5, 6, 10, 3, 2, 3, 4, 2, 10, 23, 10, 5
	DB	12, 1, 5, 3, 4, 3, 9, 5, 1, 5, 3, 7, 9, 8, 1
	DB	14, 7, 3, 2, 1, 3, 14, 1, 2, 3, 1, 6, 2, 30, 1
	DB	2, 7, 6, 6, 3, 6, 2, 10, 8, 6, 1, 9, 3, 5, 12
	DB	16, 5, 13, 2, 3, 7, 3, 2, 7, 2, 9, 7, 3, 5, 1
	DB	3, 2, 1, 5, 3, 10, 2, 12, 3, 22, 5, 1, 5, 16, 14
	DB	1, 3, 2, 6, 7, 6, 12, 5, 15, 4, 3, 3, 2, 1, 6
	DB	5, 4, 17, 7, 2, 3, 6, 1, 5, 6, 9, 4, 9, 6, 2
	DB	4, 9, 5, 7, 9, 6, 2, 6, 4, 8, 3, 6, 6, 9, 13
	DB	5, 1, 9, 6, 6, 20, 3, 10, 2, 3, 6, 1, 5, 4, 5
	DB	7, 2, 3, 7, 2, 3, 7, 3, 3, 5, 12, 6, 1, 6, 5
	DB	4, 21, 12, 5, 1, 11, 3, 1, 2, 4, 9, 2, 19, 5, 1
	DB	3, 2, 4, 3, 2, 3, 10, 6, 9, 5, 10, 2, 6, 4, 11
	DB	13, 6, 6, 2, 1, 2, 4, 8, 7, 18, 2, 3, 3, 7, 2
	DB	4, 5, 19, 12, 6, 5, 7, 2, 6, 4, 3, 2, 1, 3, 9
	DB	12, 3, 2, 16, 9, 5, 1, 9, 5, 6, 15, 4, 6, 5, 3
	DB	7, 3, 2, 4, 3, 2, 10, 21, 2, 6, 6, 3, 1, 27, 5
	DB	10, 3, 6, 3, 11, 21, 1, 2, 7, 14, 1, 11, 10, 5, 3
	DB	9, 3, 13, 9, 5, 1, 11, 3, 1, 6, 5, 3, 6, 1, 3
	DB	2, 10, 5, 6, 10, 5, 13, 2, 10, 12, 3, 14, 3, 3, 7
	DB	11, 6, 4, 15, 2, 4, 3, 2, 3, 1, 14, 3, 3, 4, 3
	DB	3, 5, 1, 5, 6, 3, 1, 3, 5, 3, 3, 4, 8, 9, 13
	DB	5, 1, 9, 3, 3, 5, 4, 3, 2, 18, 4, 5, 10, 11, 3
	DB	9, 12, 6, 7, 3, 23, 6, 1, 3, 14, 3, 3, 7, 8, 6
	DB	1, 5, 4, 8, 1, 9, 8, 7, 2, 10, 5, 3, 6, 1, 3
	DB	2, 13, 6, 2, 3, 6, 1, 9, 3, 6, 6, 3, 3, 2, 3
	DB	3, 10, 5, 1, 14, 1, 6, 14, 4, 2, 9, 4, 14, 1, 2
	DB	3, 4, 3, 5, 12, 15, 1, 6, 3, 23, 3, 6, 1, 2, 10
	DB	2, 6, 3, 12, 10, 8, 1, 5, 4, 5, 1, 5, 1, 2, 3
	DB	4, 5, 6, 7, 6, 6, 11, 3, 4, 8, 3, 1, 3, 21, 9
	DB	3, 2, 6, 6, 1, 3, 17, 7, 2, 3, 1, 2, 10, 14, 3
	DB	7, 9, 11, 1, 8, 10, 2, 3, 4, 2, 4, 11, 3, 1, 5
	DB	4, 5, 1, 2, 3, 7, 14, 3, 1, 2, 7, 11, 1, 5, 1
	DB	14, 18, 6, 7, 2, 6, 4, 3, 3, 12, 5, 19, 6, 17, 3
	DB	4, 8, 1, 9, 8, 3, 4, 2, 16, 9, 3, 8, 4, 3, 6
	DB	2, 3, 4, 6, 11, 3, 10, 12, 6, 8, 1, 5, 6, 9, 6
	DB	3, 1, 3, 6, 12, 2, 15, 3, 3, 7, 2, 1, 5, 10, 5
	DB	1, 6, 8, 4, 5, 6, 4, 3, 3, 12, 2, 3, 4, 8, 3
	DB	13, 5, 15, 1, 5, 1, 3, 2, 3, 1, 3, 12, 3, 3, 3
	DB	15, 20, 7, 2, 10, 2, 3, 6, 6, 1, 8, 7, 27, 15, 6
	DB	2, 4, 3, 11, 1, 6, 9, 9, 2, 4, 0
ENDIF

	;; Align so that other GWDATA areas are aligned on a cache line
	align 128
_GWDATA ENDS


initsize	EQU	7*11*13*17	; First 4 primes cleared in initsieve
initcount	EQU	4		; Count of primes cleared in initsieve
sievesize	EQU	00003000h	; 12KB sieve
repcnt		EQU	4		; How many reps before returning

;; Debugging macros

debug	MACRO ops:vararg
	IFDEF GDEBUG
	&ops
	ENDIF
	ENDM

assert	MACRO jcond
	LOCAL	ok
	IFDEF GDEBUG
	jcond	short ok
	sub	rsp, rsp
	pop	rax
ok:
	ENDIF
	ENDM


_TEXT	SEGMENT

; setupf (struct facasm_data *)
;	Initialize 64-bit factoring code
; Windows 64-bit (setupf)
;	Parameter ptr = rcx
; Linux 64-bit (setupf)
;	Parameter ptr = rdi

PROCF	setupf
	ad_prolog 0,0,rbx,rbp,rsi,rdi

; Save p (passed in FACLSW), compute various constants and addresses

	mov	eax, EXPONENT		; Load and save p
	mov	p, rax
	add	rax, rax		; Two times p
	mov	twop, rax
	lea	rax, last_global	; Addr of allocated memory
	mov	edx, 0FFFFh		; Align area on a 64K boundary
	add	rax, rdx
	not	rdx
	and	rax, rdx
	mov	primearray, rax		; Array of primes and offsets
	add	rax, 30000h
	mov	initsieve, rax		; Array used to init sieve
	add	rax, 40000h
	mov	initlookup, rax		; Lookup table into initsieve
	add	rax, 20000h
	mov	sieve, rax		; Array of sieve bits
	mov	rax, primearray
	add	rax, initcount*12
	mov	primearray12, rax

; Create table of trial factor distances (multiples of 120*p)

	mov	rax, 120		; Compute 120 (8 * 3 * 5) * p
	mul	p
	sub	rbx, rbx		; LSW of multiple of facdist
	lea	rdi, facdists
	mov	rcx, 64			; Loop 64 times
fdlp:	mov	[rdi], rbx
	lea	rdi, [rdi+8]		; Bump pointers
	add	rbx, rax		; Next distance
	dec	rcx			; Test loop counter
	jnz	short fdlp
	mov	facdist64, rbx		; Save 64 * facdist

; Copy byte based prime array to double word based array

	mov	rsi, OFFSET sivinfo	; Source - array of bytes
	mov	rdi, primearray		; Destination - array of double words
	mov	rbx, 5			; Sivinfo contains primes larger than 5
	sub	rcx, rcx
initlp:	mov	cl, [rsi]
	and	cl, cl			; Test for end of table
	jz	short tabend
	add	rbx, rcx
	add	rbx, rcx
	cmp	rbx, sievesize*8	; Past maximum prime?
	jge	short tabend
	mov	[rdi], ebx		; Save the small prime
	xor	rdx, rdx		; Compute minimum number of bits in
	mov	eax, sievesize*8	; sieve that will be cleared
	div	rbx
	mov	[rdi+4], eax
	inc	rsi			; Next table entry
	lea	rdi, [rdi+12]		; Next primearray entry
	jmp	short initlp
tabend:	sub	rcx, rcx
	mov	[rdi], ecx		; Zero marks last entry

; Fill initsieve array with ones.  We make the table bigger than "necessary"
; so that filling the sieve can be done in one blast.

	mov	rax, -1
	mov	rcx, initsize + sievesize / 8
	mov	rdi, initsieve
	rep	stosq

; Clear the bits associated with the first 4 primes

	mov	rsi, primearray		; Ptr to first small prime
	mov	rdi, initsieve		; Address of initial sieve
	mov	rbx, sieve		; Used for temporary storage
ilp1:	mov	ecx, [rsi]		; Load small prime
	sub	rax, rax
ilp2:	btr	[rdi], rax		; Clear the bit
	add	rax, rcx		; Next bit #
	cmp	rax, initsize*64+sievesize*8; Past end of the init area?
	jb	short ilp2
	sub	rax, rax		; Save bit# (zero because the first
	mov	[rbx], eax		; in initsieve was cleared for all
					; small primes)
	mov	rax, 64			; Compute p - 64 mod p.  This value
ilp3:	sub	rax, rcx		; represents the bit# in the next
	jns	short ilp3		; word that was cleared for the
	neg	rax	    		; given small prime.  For example,
	mov	[rbx+4], eax		; 3 - 64 mod 3 = 2.  Thus, the 2nd
	add	rbx, 8			; bit in the second initsieve qword was
					; cleared by small prime 3.
	lea	rsi, [rsi+12]		; Next primearray entry
	cmp	rsi, primearray12	; Another small prime?
	jnz	short ilp1

; Fill lookup table into initsieve

	sub	rdi, rdi		; The first lookup points to the
	sub	rax, rax		; first entry in initsieve
ilp4:	mov	rsi, initlookup		; Set lookup table entry
	mov	[rsi][rax*4], edi	; Set lookup table entry
	inc	rdi			; Point to next initsieve dword
	mov	rsi, sieve		; Array of 64 mod p info
	mov	rbx, primearray		; Ptr to first small prime
	sub	rax, rax		; Build the index in eax
ilp5:	mov	ecx, [rbx]		; Load the small prime
	mul	rcx			; Multiply index by the small prime
	mov	edx, [rsi]		; Load bit#
	add	edx, [rsi+4]		; Compute bit# in next dword
ilp6:	sub	rdx, rcx		; Compute bit# mod smallp
	jns	short ilp6
	add	rdx, rcx
	mov	[rsi], edx		; Save bit# for next pass
	add	rax, rdx		; Add the bit# to the index
	lea	rsi, [rsi+8]
	lea	rbx, [rbx+12]		; Next primearray entry
	cmp	rbx, primearray12	; Last small prime?
	jne	short ilp5
	test	rax, rax		; Is lookup table completely built?
	jnz	short ilp4

; Set firstcall

	sub	rax, rax
	mov	firstcall, eax

; Return

	ad_epilog 0,0,rbx,rbp,rsi,rdi
setupf	ENDP

; factor64 (struct facasm_data *)
;	Do a few sieving runs and test potential factors
; Windows 64-bit (factor64)
;	Parameter ptr = rcx
; Linux 64-bit (factor64)
;	Parameter ptr = rdi

PROCF	factor64
	ad_prolog 0,0,rbx,rbp,rsi,rdi,r12,r13,r14,r15,xmm6,xmm7,xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15

; Is this a request to test 48-bit factors?  If so, go to special code.

	cmp	FACHSW, 0
	jne	big
	mov	eax, FACMSW
	shl	rax, 32
	cmp	rax, fac32endpt
	jae	big

;
; Brute force code to find small factors of 2**p - 1.  It works
; for trial factors of 63-bits or less.  However, the sieving algorithm
; is better if you are planning on testing a lot of trial factors.  So we
; only use this for 44-bit factors.
;

	mov	rcx, p
	mov	rdi, fac32endpt
	cmp	FACPASS, 0		; Only do this on pass 0
	jne	lv32
s32lp:	add	rcx, rcx		; Shift until top bit on
	jns	short s32lp
	mov	rax, rcx
	shl	rax, 6
	mov	shifter, rax
	shr	rcx, 58
	mov	rax, 1
	shl	rax, cl
	mov	temp, rax

; First trial factor is 2p + 1

	mov	rcx, twop
	inc	rcx

; If factor = 3 or 5 mod 8, then it can't be a factor of 2**p - 1

testf:	mov	rax, rcx
	and	al, 6
	jz	short test32
	cmp	al, 6
	jnz	short nextf

; Square the number until we computed 2**p MOD factor

test32:	mov	rbx, shifter
	mov	rax, temp
	sub	rdx, rdx
	div	rcx
loop32:	mov	rax, rdx		; Square remainder
	mul	rax
	div	rcx			; Divide squared rem by trial factor
	add	rbx, rbx
	jnc	short loop32
	jz	short exit32
	add	rdx, rdx		; Double remainder
	jmp	short loop32

; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1

exit32:	add	rdx, rdx
	dec	rdx
	cmp	rdx, rcx
	jz	short win32

; Try next possible factor

nextf:	add	rcx, twop
	cmp	rcx, rdi
	jl	short testf

; No 32-bit factor found - return for ESC check

lv32:	mov	rax, 2			; Return for ESC check
	shr	rdi, 32
	mov	FACMSW, edi		; Restart after endpt
	jmp	done

; Divisor found, return TRUE

win32:	mov	rax, 1
	mov	FACLSW, ecx
	shr	rcx, 32
	mov	FACMSW, ecx
	jmp	done

; We are looking for bigger factors (above 2^44).  Use a sieve.

big:

; Set number of repetitions

	mov	reps, repcnt

; Check/Set firstcall.  Second calls can skip some initialization.

	cmp	firstcall, 0
	jne	initsv
	inc	firstcall

; Clear counts of queued factors

	mov	queuedcnt, 0

; First trial factor is first number of the form 2kp + 1
; greater than FACMSW * 2^32

	mov	edi, FACHSW		; Start point * 2^64
	mov	ebx, FACMSW		; Start point * 2^32
	shl	rbx, 32

	mov	rcx, twop		; Load twop for dividing
	mov	rax, rdi		; Do a mod on the start point
	xor	rdx, rdx
	div	rcx
	mov	rax, rbx
	div	rcx			
	sub	rcx, rdx		; Subtract remainder from twop
	inc	rcx			; and add 1 to find first test factor
	add	rbx, rcx
	adc	rdi, 0

; Make sure we have a factor with the right modulo for this pass

	mov	esi, FACPASS		; Get the pass number (0 to 15)
	mov	rbp, 120
flp1:	mov	rax, rdi		; Do a mod 120 in two parts
	xor	rdx, rdx
	div	rbp
	mov	rax, rbx		; Do a mod 120
	div	rbp
	mov	rax, OFFSET rems
	cmp	rdx, [rax+rsi*8]	; Is this the desired remainder
	jz	short flp2		; Yes, jump to flp2
	add	rbx, twop		; No, try next factor
	adc	rdi, 0
	jmp	short flp1		; Loop
flp2:	mov	savefac0, rdi
	mov	savefac1, rbx

; Loop through all the small primes determining sieve bit to clear

testp	EQU	rbp
prev	EQU	rbx
cur	EQU	rcx
bigrem	EQU	rdi
litrem	EQU	r8

	mov	rsi, primearray
smlp:	mov	ebp, [rsi]
	and	testp, testp
	jz	smdn
	cmp	testp, p
	jne	short smok
	mov	DWORD PTR [rsi], 0
	jmp	short smdn
smok:

;
; Let testp = an entry from our small primes array
; Let y = facdist mod testp
; Use Euclid's greatest common denominator algorithm to compute the number
; x such that x * y = -1 MOD testp
; We can then use x to compute the first bit in the sieve array that needs
; clearing.
;

	sub	prev, prev		; Set up: set bigrem = testp,
	mov	cur, 1			; litrem = facdist mod testp
	mov	bigrem, testp
	sub	rdx, rdx
	mov	rax, facdists+8
	div	bigrem
	mov	litrem, rdx
euclp:	cmp	litrem, 1		; Loop ends when litrem equals 1
	je	short eucdn
	sub	rdx, rdx		; Compute bigrem mod litrem
	mov	rax, bigrem
	div	litrem
	mov	bigrem, litrem
	mov	litrem, rdx
	imul	cur
	sub	prev, rax
	xchg	prev, cur
	jmp	short euclp
eucdn:	neg	cur			; set x = -cur if cur was negative
	jns	short eucdn2
	add	cur, testp		; else set x = testp - cur
eucdn2:	sub	rdx, rdx		; Divide first factor by testp
	mov	rax, savefac0
	div	testp
	mov	rax, savefac1
	div	testp
	mov	rax, rdx		; Multiply remainder by x
	mul	cur
	div	testp			; rdx now contains the bit number!
	mov	[rsi+8], edx		; Save that bit number!
	lea	rsi, [rsi+12]		; Next primearray entry
	jmp	smlp
smdn:

; Use the initlookup table to determine the first dword in initsieve to copy

	mov	rsi, primearray		; Ptr to first small prime
	sub	rax, rax		; Build the index in rax
lk1:	mul	DWORD PTR [rsi]		; Multiply index by the small prime
	add	eax, [rsi+8]		; Add the bit# to the index
	lea	rsi, [rsi+12]
	cmp	rsi, primearray12	; Last small prime?
	jne	short lk1
	mov	rsi, initlookup		; Load the lookup table address
	mov	eax, [rsi][rax*4]	; Load the initsieve start offset
	mov	initstart, eax		; Save the initsieve start offset

; Pre-square the number as much as possible.  We have separate code
; paths for single-word and double-word trial factors.

	mov	rbx, savefac0		; Load factor
	mov	rcx, savefac1
	and	rbx, rbx		; Test MSW
	jz	short psq64		; If zero, presquaring 64-bits or less

; This is the 65-bits and above presquare code.
; Calculate number of bits in the trial factor

	bsr	rax, rbx		; Look for highest set bit
	mov	rdx, 63			; Create shift count
	sub	rdx, rax
	mov	shift_count, rdx	; Save shift count for squaring loop

; Compute the two shift counts used in 66-bit factoring.  The counts for
; 66-bits is (33-1)*256+1, for 67-bits is (33-2)*256+2, etc.

	mov	rbx, 33
	sub	rbx, rax
	shl	rbx, 8
	add	rbx, rax
	mov	shift66, rbx

; Pre-square the number as much as possible.  We could push this a little
; further because the tlp65 and tlp66 code doesn't really care that the
; first remainder is larger than the trial factor.

	add	rax, 147		; Compute maximum size of initval
	mov	rcx, p			; Load p
	sub	rbx, rbx		; This will be the shifter
setlp:	shrd	rbx, rcx, 1		; Move bits from p to shifter
	shr	rcx, 1			; Remove bit from p
	cmp	rcx, rax		; Is p > max initval
	jg	short setlp		; Yes, keep shifting
	mov	shifter, rbx		; Save shifter
	sub	rcx, 64			; Compute initval = 2^(rcx-64)
	jmp	short psqdn		; Join common presquare code

; Same code as above, but for 64-bit factors
; Calculate number of bits in the trial factor

psq64:	bsr	rax, rcx		; Look for highest set bit
	mov	rdx, 63			; Create shift count
	sub	rdx, rax
	mov	shift_count, rdx	; Save shift count for squaring loop

; Pre-square the number as much as possible.  That is, make sure initval
; divided by trail factor will not result in a 65-bit quotient.  The 64-bit
; factoring code can handle one more bit than 63-bit and less code.

	add	rax, 63			; Compute maximum size of initval
	sub	rbx, rbx		; Set rbx to 1 if 64-bit factors
	shld	rbx, rcx, 1
	add	rax, rbx		; Inc max initval size if 64-bit factor
	mov	rcx, p			; Load p
	sub	rbx, rbx		; This will be the shifter
setlp64:shrd	rbx, rcx, 1		; Move bits from p to shifter
	shr	rcx, 1			; Remove bit from p
	cmp	rcx, rax		; Is p > max initval
	jg	short setlp64		; Yes, keep shifting
	mov	shifter, rbx		; Save shifter

; Common pre-square cleanup code

psqdn:	mov	rax, 127		; Compute initial shift count
	sub	rax, rcx
	sub	rax, shift_count
	mov	initshift, rax		; Save initial shift count
	mov	rdx, shift66		; Compute alternate initial shift count
	shr	rdx, 8
	add	rax, rdx
	mov	initshift2, rax		; Save alternate initial shift count
	mov	rax, 1			; Compute initval = 2^rcx
	xor	rdx, rdx
	and	rcx, rcx
	jz	short shfdn
shflp:	shld	rdx, rax, 1
	shl	rax, 1
	dec	rcx
	jnz	short shflp
shfdn:	mov	initval0, rdx		; Save initval
	mov	initval1, rax
	mov	rcx, shift_count	; Compute initdiv = 2^(63-shift_count)
	mov	rbx, 1
	shl	rbx, 63
	shr	rbx, cl
	mov	initdiv0, rbx		; Save initdiv
	inc	rcx			; Increase shift_count because only
	mov	shift_count, rcx	; 2^63 / factor fits in 64 bits.  This
					; extra shift will give us the right
					; number of bits in a quotient

; Turn shifter into an array of flags and a count.  The idea here is to replace
; the optional doubling of the remainder by a shl of zero or one bits.  This
; lets us replace the highly unpredictable test of shifter with a very
; predictable loop counter.  I tried this on an Opteron but it was a little
; bit slower.  I've left the code in to test on 64-bit Pentium someday.

	mov	rax, shifter		; Load shifter
	sub	rbx, rbx		; Clear count of bits in shifter
shf1lp:	add	rax, rax		; Shift the shifter
	inc	rbx
	or	rax, rax		; Shifter empty?
	jnz	short shf1lp		; No, loop
	mov	sqloop_counter, rbx	; Save count of bits in shifter

	mov	rax, shifter		; Load shifter
shf2lp:	sub	rcx, rcx
	add	rax, rax		; Shift the shifter
	adc	rcx, rcx		; Put shifter bit in rcx
	mov	doubleflags[rbx], cl	; Save shifter bit
	dec	rbx			; Shifter empty?
	jnz	short shf2lp		; No, loop

;
; Init the sieve
;

initsv:	mov	rdi, sieve		; Load sieve address
	mov	rsi, initsieve		; Load sieve initialization bits addr
	mov	edx, initstart		; Load qword offset into initsieve
	lea	rsi, [rsi][rdx*8]	; Compute copy address
	mov	rcx, sievesize / 8	; Count of qwords to copy
	rep	movsq			; Copy the qwords
	add	rdx, sievesize / 8	; Compute next initsieve start offset
	cmp	rdx, initsize		; Compare to table's end address
	jle	short startok		; Jump if still within table
	sub	rdx, initsize		; Get address back in line
startok:mov	initstart, edx		; Save start position for next time

;
; Loop through the small prime array, clearing sieve bits.
;

	mov	rdi, sieve		; Load address of sieve bits
	mov	rbp, primearray12	; Ptr to first prime in array
sievelp:mov	ebx, [rbp]		; Load small prime
	and	rbx, rbx		; See if primearray fully processed
	jz	short sievedn		; Yes, break out of loop
	mov	ecx, [rbp+4]		; Load count of bits to clear
	mov	eax, [rbp+8]		; Load bit offset to clear
clrlp:	btr	[rdi], rax		; Clear the sieve bit
	add	rax, rbx		; Next bit to clear
	dec	rcx			; Test count of bits to clear
	jnz	short clrlp
	cmp	rax, sievesize*8	; Past the end of the sieve?
	jae	short noclr		; Yes, skip one last clear
	btr	[rdi], rax		; Clear one final sieve bit
	add	rax, rbx		; Next bit to clear
noclr:	sub	rax, sievesize*8	; Calculate next sieve's bit to clear
	mov	[rbp+8], eax		; Save bit clear offset for next time
	lea	rbp, [rbp+12]		; Next primearray address
	jmp	short sievelp		; Work on next small prime
sievedn:mov	rbx, savefac0		; Load trial factor corresponding
	mov	rcx, savefac1		; to first sieve bit
	and	rbx, rbx		; Are we testing 65+ bit factors?
	jz	short oneword		; No, go do 64 bits or less
	test	CPU_FLAGS, 20000h	; Is this an AVX2 machine?
	jz	short notavx2		; No, use non-AVX2 code
	cmp	rbx, 400h		; Are we testing 75+ bit numbers?
	jge	atlp86			; Yes, use 75-86 bit AVX2 code
	jmp	atlp74			; No, use 65-74 bit AVX2 code
notavx2:
	test	CPU_FLAGS, 200h		; Is this an SSE2 machine?
	jz	short notsse2		; No, use non-SSE2 code
	cmp	rbx, 400h		; Are we testing 75+ bit numbers?
	jge	tlp86			; Yes, use 75-86 bit SSE2 code
	jmp	tlp74			; No, use 65-74 bit SSE2 code
notsse2:
	cmp	rbx, 1			; Are we testing 66+ bit factors?
	jg	tlp66			; Yes, go do it
	je	tlp65			; Jump if testing 65 bit factors?
oneword:
	mov	rax, rcx
	shr	rax, 58			; Testing 58 bit or less factors?
	jz	tlp58			; Yes, go test 58-bit factors
	shr	rax, 2			; Testing 60 bit or less factors?
	jz	tlp60			; Yes, go test 60-bit factors
	shr	rax, 1			; Testing 61 bit or less factors?
	jz	tlp61			; Yes, go test 61-bit factors
	shr	rax, 1			; Testing 62 bit or less factors?
	jz	tlp62			; Yes, go test 62-bit factors
	shr	rax, 1			; Testing 63 bit or less factors?
	jz	tlp63			; Yes, go test 63-bit factors
	jmp	tlp64			; No, go test 64-bit factors

;
; Make register assignments for one word remainders
;

facinv1	EQU	r13
facinv2	EQU	facinv2_in_memory	;; Formerly r11
facinv3	EQU	r15
temp3	EQU	rdi
rem3	EQU	r8
fac3reg	EQU	r9
temp2	EQU	r10
rem2	EQU	r14
fac2reg	EQU	r12
temp1	EQU	rbp
rem1	EQU	rbx
fac1reg	EQU	rsi

;
; Make different register assignments for two word remainders
;

rem3hi	EQU	rem3
rem3lo	EQU	fac3reg
rem2hi	EQU	rem2
rem2lo	EQU	fac2reg
rem1hi	EQU	rem1
rem1lo	EQU	fac1reg

;***********************************************************************
; Test up to 58 bit factors (actually handles most 59 bit factors too)
;***********************************************************************

tlp58:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
svlp58:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf58:	bsf	rdx, rax		; Look for a set bit
	jnz	short test58		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp58		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test58:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf58			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; zero and 6 * factor.  The squared remainder is up to 36 * factor^2.  The 
; quotient is up to 36 * factor.  For the shrd value to fit in 64 bits, the
; maximum factor is 2^63 / 36 = 2^57.  However, this estimate is too
; pessimistic.  It can be shown that the quotient is off by 2 only when facinv
; is large.  When facinv is large, the factor is small, and there is one fewer
; bit in the squared remainder, allowing 58 bits to work safely. 
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp58:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

;
; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.   Multiply by two if necessary, making the remainder
; between zero and 6 * factor.  Test for end of squaring loop
;

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp58			; If mul by 2 not needed, jump to loop
	jz	short exit58		; Are we done squaring?
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2		; Multiply remainder by 2
	add	rem3, rem3		; Multiply remainder by 2
	jmp	sqlp58			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit58:	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and 2*fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and 2*fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	sub	rcx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rcx
	sub	rdx, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win58
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win58a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win58b

	sub	rdi, rdi		; Clear queued factors count

	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf58			; Test next factor from sieve

win58:	mov	rax, fac1reg
	jmp	short win58c
win58a:	mov	rax, fac2reg
	jmp	short win58c
win58b:	mov	rax, fac3reg
win58c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test up to 60 bit factors
;***********************************************************************

tlp60:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 60
	mov	edi, queuedcnt		; Count of queued factors to be tested
svlp60:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf60:	bsf	rdx, rax		; Look for a set bit
	jnz	short test60		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rcx, rbx		; Jump if overflow of 60 bits
	jae	short oflow60
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp60		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 60-bit overflow

oflow60:and	rdi, rdi		; Are there untested factors?
	jnz	short rem60		; Yes, go do remaining trial factors
	mov	FACMSW, 10000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done
rem60:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem60		; No, go copy another
	jmp	short do60		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test60:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	cmp	r8, rbx			; Test for 60-bit overflow
	jae	short oflow60		; Jump if 60-bit overflow
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf60			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do60:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -2 * factor and 4 * factor.  The squared remainder is up to 16 * factor^2.
; quotient is up to 16 * factor.  For the shrd value to fit in 64 bits, the
; maximum factor is 2^63 / 16 = 2^59.  However, this estimate is too
; pessimistic.  It can be shown that the quotient is off by 2 only when facinv
; is large.  When facinv is large, the factor is small, there is one fewer
; bit in the squared remainder, allowing 60 bits to work safely. 
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp60:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Test for end of squaring loop.  Loop if doubling is
; not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp60			; Loop if mul by 2 not needed
	jz	short exit60		; Jump if we are done squaring

; Subtract factor so that remainder is between -1 * factor and 2 * factor.
; Multiply by two, making the remainder between -2 * factor and 4 * factor.

	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	jmp	sqlp60			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit60:	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and 2*fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and 2*fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	sub	rcx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rcx
	sub	rdx, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win60
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win60a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win60b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf60			; Test next factor from sieve

win60:	mov	rax, fac1reg
	jmp	short win60c
win60a:	mov	rax, fac2reg
	jmp	short win60c
win60b:	mov	rax, fac3reg
win60c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 61 bit factors
;***********************************************************************

tlp61:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 61
	mov	edi, queuedcnt		; Count of queued factors to be tested
svlp61:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf61:	bsf	rdx, rax		; Look for a set bit
	jnz	short test61		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rcx, rbx		; Jump if overflow of 61 bits
	jae	short oflow61
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp61		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 61-bit overflow

oflow61:and	rdi, rdi		; Are there untested factors?
	jnz	short rem61		; Yes, go do remaining trial factors
	mov	FACMSW, 20000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done
rem61:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem61		; No, go copy another
	jmp	short do61		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test61:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	cmp	r8, rbx			; Test for 61-bit overflow
	jae	short oflow61		; Jump if 61-bit overflow
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf61			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do61:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -2 * factor and 2 * factor.  The squared remainder is up to 4 * factor^2.
; The quotient is up to 4 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 4, or 2^61.
;

	mov	temp1, shifter		; Load shifter
;	mov	rcx, shift_count	; Load squared value shift count
;	inc	rcx			; Compute an extra quotient bit
					; for better branch prediction
mov rcx,64
sub rcx,shift_count
sqlp61:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv1
	imul	rdx, fac1reg		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv2
	imul	rdx, fac2reg		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, cl		; Shift squared_upper
debug	shr	rdx, cl
assert	jz
	mul	facinv3
	imul	rdx, fac3reg		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and 2 * factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp61			; Loop if mul by 2 not needed
	jz	short exit61		; Jump if we are done squaring

; Subtract factor so that remainder is between -1 * factor and 1 * factor.
; Multiply by two, making the remainder between -2 * factor and 2 * factor.

	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	jmp	sqlp61			; Do next iteration

; Make remainder between 0 and factor.  Multiply remainder by two one last
; time (for the last carry out of shifter).  If result = 1 mod factor, then
; we found a divisor of 2^p - 1

exit61:	mov	rax, rem1		; Make rem1 between 0 and fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	mov	rcx, rem2		; Make rem2 between 0 and fac
	sub	rcx, fac2reg
	cmovns	rem2, rcx
	mov	rdx, rem3		; Make rem3 between 0 and fac
	sub	rdx, fac3reg
	cmovns	rem3, rdx

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win61
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win61a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win61b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf61			; Test next factor from sieve

win61:	mov	rax, fac1reg
	jmp	short win61c
win61a:	mov	rax, fac2reg
	jmp	short win61c
win61b:	mov	rax, fac3reg
win61c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 62 bit factors
;***********************************************************************

tlp62:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	rbx, 1			; Compute maximum trial factor
	shl	rbx, 62
	mov	edi, queuedcnt		; Count of queued factors to be tested
svlp62:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf62:	bsf	rdx, rax		; Look for a set bit
	jnz	short test62		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	cmp	rcx, rbx		; Jump if overflow of 62 bits
	jae	short oflow62
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp62		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 62-bit overflow

oflow62:and	rdi, rdi		; Are there untested factors?
	jnz	short rem62		; Yes, go do remaining trial factors
	mov	FACMSW, 40000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done
rem62:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem62		; No, go copy another
	jmp	short do62		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test62:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	cmp	r8, rbx			; Test for 62-bit overflow
	jae	short oflow62		; Jump if 62-bit overflow
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf62			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do62:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -1 * factor and 1 * factor.  The squared remainder is up to 1 * factor^2.
; The quotient is up to 1 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 1, or 2^63.  So that is not a limitation.
; Instead we are limited by the fact that quotient can be off by 2, giving
; us problems fitting the remainder in 64 bits.  The maximum factor is
; 2^64 / 3 = 2^62.
;

	mov	temp1, shifter		; Load shifter
sqlp62:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv1			; Compute quotient
	imul	rdx, fac1reg 		; Compute quotient * factor
	sub	rem1, rdx		; Subtract from squared remainder

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv2			; Compute quotient
	imul	rdx, fac2reg 		; Compute quotient * factor
	sub	rem2, rdx		; Subtract from squared remainder

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	shrd	rax, rdx, 61		; Shift squared_upper
debug	shr	rdx, 61
assert	jz
	mul	facinv3			; Compute quotient
	imul	rdx, fac3reg 		; Compute quotient * factor
	sub	rem3, rdx		; Subtract from squared remainder

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	cmovns	rem1, rax
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	cmovns	rem2, rdx
	sub	rdx, fac2reg		; Make rem2 between 0 and fac
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	cmovns	rem3, rax
	sub	rax, fac3reg		; Make rem3 between 0 and fac
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	temp1, temp1		; One squaring completed, shift
	jnc	sqlp62			; Loop if mul by 2 not needed
	jz	short exit62		; Jump if we are done squaring

; Multiply by two, making the remainder between 0 and 2 * factor.
; Subtract factor so that remainder is between -1 * factor and 1 * factor.

	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	jmp	sqlp62			; Do next iteration

; Multiply remainder by two one last time (for the last carry out of shifter).
; If result = 1 mod factor, then we found a divisor of 2^p - 1

exit62:

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win62
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win62a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win62b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf62			; Test next factor from sieve

win62:	mov	rax, fac1reg
	jmp	short win62c
win62a:	mov	rax, fac2reg
	jmp	short win62c
win62b:	mov	rax, fac3reg
win62c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; Test 63 bit factors
;***********************************************************************

tlp63:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
svlp63:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf63:	bsf	rdx, rax		; Look for a set bit
	jnz	short test63		; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	js	short oflow63		; Jump if overflow of 63 bits
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp63		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 63-bit overflow

oflow63:and	rdi, rdi		; Are there untested factors?
	jnz	short rem63		; Yes, go do remaining trial factors
	mov	FACMSW, 80000000h	; Return end point
	mov	rax, 2			; Return for ESC check
	jmp	done
rem63:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem63		; No, go copy another
	jmp	short do63		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test63:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	mov	fac1[rdi*8], r8		; Save the factor to test
	js	short oflow63		; Jump if 63-bit overflow
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf63			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do63:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute shifted 1 / factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac1reg, fac1
	div	fac1reg			; Compute 1 / trial_factor
	mov	facinv1, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac2reg, fac2
	div	fac2reg			; Compute 1 / trial_factor
	mov	facinv2, rax		; Save 1 / trial_factor

	mov	rdx, initdiv0
	sub	rax, rax
	mov	fac3reg, fac3
	div	fac3reg			; Compute 1 / trial_factor
	mov	facinv3, rax		; Save 1 / trial_factor

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

	mov	rem1, initval1		; Load initial value
	mov	rem2, rem1		; Load initial value
	mov	rem3, rem1		; Load initial value

	mov	rax, facinv1		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac1reg			; Compute quotient * factor
	sub	rem1, rax		; Subtract from initval
debug	mov	temp1, initval0
debug	sbb	temp1, rdx
assert	jz

	mov	rax, facinv2		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac2reg			; Compute quotient * factor
	sub	rem2, rax		; Subtract from initval
debug	mov	temp2, initval0
debug	sbb	temp2, rdx
assert	jz

	mov	rax, facinv3		; Quotient = initmul0 * 1 / factor
	shr	rax, cl
	mul	fac3reg			; Compute quotient * factor
	sub	rem3, rax		; Subtract from initval
debug	mov	temp3, initval0
debug	sbb	temp3, rdx
assert	jz

;
; Square remainder and get new remainder.  Input remainder is between
; -1 * factor and 1 * factor.  The squared remainder is up to 1 * factor^2.
; The quotient is up to 1 * factor.  For the quotient to fit in 63 bits (the
; maximum possible with our multiply by reciprocal approach), the
; maximum factor is 2^63 / 1, or 2^63.  So that is not a limitation.
; Instead we are limited by the fact that quotient can be off by 2, giving
; us problems fitting the remainder in 64 bits.  The maximum factor is
; 2^64 / 3.  So unfortunately we must calculate full double word remainders.
;

	mov	rcx, shifter		; Load shifter
sqlp63:	mov	rax, rem1		; Load remainder
	imul	rax			; Square remainder
	mov	rem1, rax		; Save squared remainder
	mov	temp1, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv1			; Compute quotient
	mov	rax, fac1reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem1, rax		; Subtract from squared remainder
	sbb	temp1, rdx

	mov	rax, rem2		; Load remainder
	imul	rax			; Square remainder
	mov	rem2, rax		; Save squared remainder
	mov	temp2, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv2			; Compute quotient
	mov	rax, fac2reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem2, rax		; Subtract from squared remainder
	sbb	temp2, rdx

	mov	rax, rem3		; Load remainder
	imul	rax			; Square remainder
	mov	rem3, rax		; Save squared remainder
	mov	temp3, rdx
	shrd	rax, rdx, 62		; Shift squared_upper
debug	shr	rdx, 62
assert	jz
	mul	facinv3			; Compute quotient
	mov	rax, fac3reg
	mul	rdx	 		; Compute quotient * factor
	sub	rem3, rax		; Subtract from squared remainder
	sbb	temp3, rdx

; At this point, since quotient can be off by 2, the remainder is between
; zero and 3 * factor.  Make remainder between 0 and factor.

	mov	rax, rem1		; Make rem1 between 0 and 2*fac
	sub	rax, fac1reg
	sbb	temp1, 0
	cmovns	rem1, rax
	sub	rax, fac1reg		; Make rem1 between 0 and fac
	sbb	temp1, 0
	cmovns	rem1, rax
	mov	rdx, rem2		; Make rem2 between 0 and 2*fac
	sub	rdx, fac2reg
	sbb	temp2, 0
	cmovns	rem2, rdx
	sub	rdx, fac2reg		; Make rem2 between 0 and fac
	sbb	temp2, 0
	cmovns	rem2, rdx
	mov	rax, rem3		; Make rem3 between 0 and 2*fac
	sub	rax, fac3reg
	sbb	temp3, 0
	cmovns	rem3, rax
	sub	rax, fac3reg		; Make rem3 between 0 and fac
	sbb	temp3, 0
	cmovns	rem3, rax

; Test for end of squaring loop.  Loop if doubling is not required.

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp63			; Loop if mul by 2 not needed
	jz	short exit63		; Jump if we are done squaring

; Multiply by two, making the remainder between 0 and 2 * factor.
; Subtract factor so that remainder is between -1 * factor and 1 * factor.

	add	rem1, rem1		; Multiply remainder by 2
	add	rem2, rem2
	add	rem3, rem3
	sub	rem1, fac1reg		; Subtract factor
	sub	rem2, fac2reg
	sub	rem3, fac3reg
	jmp	sqlp63			; Do next iteration

; Multiply remainder by two one last time (for the last carry out of shifter).
; If result = 1 mod factor, then we found a divisor of 2^p - 1

exit63:

debug	cmp	rem1, fac1reg		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2reg		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3reg		; Remainder should be < factor
assert	jb

	add	rem1, rem1		; Double the remainder
	add	rem2, rem2		; Double the remainder
	add	rem3, rem3		; Double the remainder

	sub	rem1, fac1reg		; If rem == fac+1, we found a factor!
	dec	rem1
	jz	short win63
	sub	rem2, fac2reg		; If rem == fac+1, we found a factor!
	dec	rem2
	jz	short win63a
	sub	rem3, fac3reg		; If rem == fac+1, we found a factor!
	dec	rem3
	jz	short win63b

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf63			; Test next factor from sieve

win63:	mov	rax, fac1reg
	jmp	short win63c
win63a:	mov	rax, fac2reg
	jmp	short win63c
win63b:	mov	rax, fac3reg
win63c:	mov	FACLSW, eax		; Factor found!!! Return TRUE
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1
	jmp	done

;***********************************************************************
; For 64-bit factors
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp64:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	div	rcx
	mov	facinv3, rax
svlp64:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf64:	bsf	rdx, rax		; Look for a set bit
	jnz	test64			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	jc	short oflow64		; Jump if overflow of 64 bits
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp64		; Loop to test next sieve qword

; Save state, check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 64-bit overflow

oflow64:and	rdi, rdi		; Are there untested factors?
	jnz	short rem64		; Yes, go do remaining trial factors
	mov	FACMSW, 0		; Return end point
	mov	FACHSW, 1
	mov	rax, 2			; Return for ESC check
	jmp	done
rem64:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem64		; No, go copy another
	mov	rcx, -1			; Set rcx so it will oflow again
	jmp	short do64		; Go test queued factors

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test64:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	jc	short oflow64		; Jump if 64-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf64			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do64:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.  Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rax, fac1
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shift count

debug	mov	rem1lo, initval1
debug	and	rem1lo, rem1lo
assert	jz

	sub	rem1lo, rem1lo		; Load initial value
	sub	rem2lo, rem2lo
	sub	rem3lo, rem3lo

; Assuming the inverse factor is accurate to 40 bits, we must jump to
; the code that computes the quotient in two parts if the shift count
; is less than 24.

	cmp	cl, 24			; Will shift count yield < 40-bit quot?
	jge	short fast64		; Yes, do the fast first iteration

; This is the slow code to compute the first quotient and remainder.

	mov	temp1, facinv1		; Quotient = val * 1 / factor
	shr	temp1, cl
	mov	temp2, facinv2		; Quotient = val * 1 / factor
	shr	temp2, cl
	mov	temp3, facinv3		; Quotient = val * 1 / factor
	shr	temp3, cl

	mov	rem1hi, initval0	; Load high part of initval
	mov	rem2hi, rem1hi
	mov	rem3hi, rem1hi

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1			; First iteration does not double
	jmp	slow64			; Jump into middle of squaring loop

; This is the fast code to compute the quotients and remainders

fast64:	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac1			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from initval
debug	mov	rem1hi, initval0
debug	sbb	rem1hi, rdx
assert	jz

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac2			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from initval
debug	mov	rem2hi, initval0
debug	sbb	rem2hi, rdx
assert	jz

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	mul	fac3			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from initval
debug	mov	rem3hi, initval0
debug	sbb	rem3hi, rdx
assert	jz

;
; Square remainders and get new remainders.  Input remainder must be less than
; factor.
;

	mov	rcx, shifter		; Load shifter
sqlp64:	mov	rax, rem1lo		; Load remainder
	mul	rem1lo			; Square remainder
	mov	rem1lo, rax		; Save squared remainder
	mov	rem1hi, rdx

	mov	rax, rem2lo		; Load remainder
	mul	rem2lo			; Square remainder
	mov	rem2lo, rax		; Save squared remainder
	mov	rem2hi, rdx

	mov	rax, rem3lo		; Load remainder
	mul	rem3lo			; Square remainder
	mov	rem3lo, rax		; Save squared remainder
	mov	rem3hi, rdx

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	lea	temp1, [rdx+rdx]	; Save quotient

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	lea	temp2, [rdx+rdx]	; Save quotient

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	lea	temp3, [rdx+rdx]	; Save quotient

slow64:	mov	rax, fac1
	mul	temp1			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	mov	temp1, rem1hi		; Shift for computing accurate quotient
	shld	temp1, rem1lo, 31
	mov	temp2, rem2hi
	shld	temp2, rem2lo, 31
	mov	temp3, rem3hi
	shld	temp3, rem3lo, 31

	mov	rax, temp1		; Quotient = val * 1 / factor
	mul	facinv1
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
	jz	short qok64		; Most of the time branch will be taken
assert	jns
	sub	rem1lo, fac1		; Handle rare quotient too small case
debug	sbb	rem1hi, 0
assert	jz
qok64:

	mov	rax, temp2		; Quotient = val * 1 / factor
	mul	facinv2
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
	jz	short qok64a		; Most of the time branch will be taken
assert	jns
	sub	rem2lo, fac2		; Handle rare quotient too small case
debug	sbb	rem2hi, 0
assert	jz
qok64a:

	mov	rax, temp3		; Quotient = val * 1 / factor
	mul	facinv3
	shr	rdx, 30			; Adjust quotient
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
	jz	short qok64b		; Most of the time branch will be taken
assert	jns
	sub	rem3lo, fac3		; Handle rare quotient too small case
debug	sbb	rem3hi, 0
assert	jz
qok64b:

; Remainder might still be too large due to the rare quotient too small case.
; If so fix the remainder.

	cmp	rem1lo, fac1		; Fix rem1 if necessary
	jb	ok64
	sub	rem1lo, fac1
ok64:	cmp	rem2lo, fac2		; Fix rem2 if necessary
	jb	ok64a
	sub	rem2lo, fac2
ok64a:	cmp	rem3lo, fac3		; Fix rem3 if necessary
	jb	ok64b
	sub	rem3lo, fac3
ok64b:

;
; Multiply by two if necessary, test for end of squaring loop
;

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp64			; Loop if a mul by 2 is not needed
	jz	short exit64		; Are we done squaring?

	lea	temp1, [rem1lo+rem1lo]	; Multiply remainder by 2
	sub	temp1, fac1
	add	rem1lo, rem1lo
	cmovc	rem1lo, temp1		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem1lo, fac1
	cmovae	rem1lo, temp1		; or if rem > fac, use rem*2-fac

	lea	temp2, [rem2lo+rem2lo]	; Multiply remainder by 2
	sub	temp2, fac2
	add	rem2lo, rem2lo	
	cmovc	rem2lo, temp2		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem2lo, fac2
	cmovae	rem2lo, temp2		; or if rem > fac, use rem*2-fac

	lea	temp3, [rem3lo+rem3lo]	; Multiply remainder by 2
	sub	temp3, fac3
	add	rem3lo, rem3lo
	cmovc	rem3lo, temp3		; If mul by 2 overflowed, use rem*2-fac
	cmp	rem3lo, fac3
	cmovae	rem3lo, temp3		; or if rem > fac, use rem*2-fac

	jmp	sqlp64			; Do next squaring

; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1

exit64:

debug	cmp	rem1, fac1		; Remainder should be < factor
assert	jb
debug	cmp	rem2, fac2		; Remainder should be < factor
assert	jb
debug	cmp	rem3, fac3		; Remainder should be < factor
assert	jb

	add	rem1lo, rem1lo		; Double the remainder
	add	rem2lo, rem2lo		; Double the remainder
	add	rem3lo, rem3lo		; Double the remainder

	mov	rax, fac1		; Load factor #1
	sub	rem1lo, rax		; Subtract factor
	dec	rem1lo
	jz	short win64
	mov	rax, fac2		; Load factor #2
	sub	rem2lo, rax		; Subtract factor
	dec	rem2lo
	jz	short win64
	mov	rax, fac3		; Load factor #3
	sub	rem3lo, rax		; Subtract factor
	dec	rem3lo
	jz	short win64

	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf64			; Test next factor from sieve

win64:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	rax, 1			; Return TRUE
	jmp	done

;***********************************************************************
; For 65-bit factors
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp65:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	ror	rcx, 1			; Form high 64-bits of factor
	inc	rcx			; ceiling (high 64-bits of factor)
	div	rcx
	dec	rcx
	rol	rcx, 1			; Restore lower 64-bits of factor
	mov	facinv3, rax
svlp65:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf65:	bsf	rdx, rax		; Look for a set bit
	jnz	test65			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	jc	short oflow65		; Jump if overflow of 65 bits
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp65		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, 1
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle 65-bit overflow

oflow65:and	rdi, rdi		; Are there untested factors?
	jnz	short rem65		; Yes, go do remaining trial factors
	mov	FACMSW, 0		; Return end point
	mov	FACHSW, 2
	mov	rax, 2			; Return for ESC check
	jmp	done
rem65:	mov	r8, fac1		; Copy first trial factor
	mov	fac1[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem65		; No, go copy another
	mov	rcx, -1			; Set rcx so it will oflow again
	jmp	short do65		; Go test queued factors

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test65:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	add	r8, facdists[rdx*8]	; Determine factor to test
	jc	short oflow65		; Jump if 65-bit overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf65			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do65:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rcx
	mov	SAVED_REG4, rbp

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.   Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rax, fac1
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3
	ror	rax, 1			; Form upper 64 bits of factor
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shifted count

	and	rcx, rcx		; If quotient will be small,
	jns	short fast65		; jump to go compute it.

	sub	rem1hi, rem1hi		; Load initial value
	sub	rem1lo, rem1lo
	sub	rem2hi, rem2hi
	sub	rem2lo, rem2lo
	sub	rem3hi, rem3hi
	sub	rem3lo, rem3lo

	mov	rcx, initshift2		; Compute first quotients
	mov	temp1, facinv1
	shr	temp1, cl
	mov	temp2, facinv2
	shr	temp2, cl
	mov	temp3, facinv3
	shr	temp3, cl

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1
	jmp	slow65			; Jump into middle of squaring loop

fast65:	mov	rem1hi, initval1	; Load initial value
	sub	rem1lo, rem1lo
	mov	rem2hi, rem1hi
	sub	rem2lo, rem2lo
	mov	rem3hi, rem1hi
	sub	rem3lo, rem3lo

	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem1hi, rax		; Subtract quotient * factor_hi
	mul	fac1			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from initval
	sbb	rem1hi, rdx
assert	jns

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem2hi, rax		; Subtract quotient * factor_hi
	mul	fac2			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from initval
	sbb	rem2hi, rdx
assert	jns

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	sub	rem3hi, rax		; Subtract quotient * factor_hi
	mul	fac3			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from initval
	sbb	rem3hi, rdx
assert	jns

;
; Square remainders and get new remainders
;

	mov	rcx, shifter		; Load shifter
sqlp65:	mov	temp1, rem1hi		; Load remainder_hi
	imul	temp1, temp1		; Square remainder_hi

	mov	temp2, rem2hi		; Load remainder_hi
	imul	temp2, temp2		; Square remainder_hi

	mov	temp3, rem3hi		; Load remainder_hi
	imul	temp3, temp3		; Square remainder_hi

	add	rem1hi, rem1hi		; Double remainder_hi
	add	rem2hi, rem2hi		; Double remainder_hi
	add	rem3hi, rem3hi		; Double remainder_hi

	mov	rax, rem1lo		; Load remainder_lo
	mul	rem1lo			; Square remainder_lo
	xchg	rem1lo, rax		; Save squared remainder_lo
	xchg	rem1hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem1hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp1, rdx

	mov	rax, rem2lo		; Load remainder_lo
	mul	rem2lo			; Square remainder_lo
	xchg	rem2lo, rax		; Save squared remainder_lo
	xchg	rem2hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem2hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp2, rdx

	mov	rax, rem3lo		; Load remainder_lo
	mul	rem3lo			; Square remainder_lo
	xchg	rem3lo, rax		; Save squared remainder_lo
	xchg	rem3hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem3hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp3, rdx

	shld	temp1, rem1hi, 31	; Shift for computing quotient
	shld	temp2, rem2hi, 31
	shld	temp3, rem3hi, 31

	mov	rax, facinv1		; Quotient = val * 1 / factor
	mul	temp1
	mov	temp1, rdx		; Save quotient

	mov	rax, facinv2		; Quotient = val * 1 / factor
	mul	temp2
	mov	temp2, rdx		; Save quotient

	mov	rax, facinv3		; Quotient = val * 1 / factor
	mul	temp3
	mov	temp3, rdx		; Save quotient

slow65:	mov	rax, fac1
	mul	temp1			; Compute quotient * factor_lo
	add	rdx, temp1		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor_lo
	add	rdx, temp2		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor_lo
	add	rdx, temp3		; Add in quotient * factor_hi
	shld	rdx, rax, 33
	shl	rax, 33
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	sub	rem1hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	sub	rem2hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	sub	rem3hi, rdx		; Subtract quotient * factor_hi
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

;
; Multiply by two if necessary, test for end of squaring loop
;

	add	rcx, rcx		; One squaring completed, shift
	jnc	sqlp65			; Loop if a mul by 2 is not needed
	jz	short exit65		; Are we done squaring?
	add	rem1lo, rem1lo		; Multiply remainder by 2
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Multiply remainder by 2
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Multiply remainder by 2
	adc	rem3hi, rem3hi
	jmp	sqlp65			; Do next squaring

;
; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1
;

exit65:	add	rem1lo, rem1lo		; Double the remainder
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Double the remainder
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Double the remainder
	adc	rem3hi, rem3hi
	mov	rax, fac1		; Load factor #1
sub65:	sub	rem1lo, rax		; Subtract factor
	sbb	rem1hi, 1
	jns	short sub65		; Subtract until result is negative
	add	rem1lo, rax		; Make it positive
	adc	rem1hi, 1
	dec	rem1lo			; If one, its a factor
	jnz	short fail65
	and	rem1hi, rem1hi
	jz	short win65
fail65:	mov	rax, fac2		; Load factor #2
sub65a:	sub	rem2lo, rax		; Subtract factor
	sbb	rem2hi, 1
	jns	short sub65a		; Subtract until result is negative
	add	rem2lo, rax		; Make it positive
	adc	rem2hi, 1
	dec	rem2lo			; If one, its a factor
	jnz	short fail65a
	and	rem2hi, rem2hi
	jz	short win65
fail65a:mov	rax, fac3		; Load factor #3
sub65b:	sub	rem3lo, rax		; Subtract factor
	sbb	rem3hi, 1
	jns	short sub65b		; Subtract until result is negative
	add	rem3lo, rax		; Make it positive
	adc	rem3hi, 1
	dec	rem3lo			; If one, its a factor
	jnz	short next65
	and	rem3hi, rem3hi
	jz	short win65

next65:	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG4		; Restore sieve testing register
	mov	rcx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf65			; Test next factor from sieve

win65:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	FACHSW, 1
	mov	rax, 1			; Return TRUE
	jmp	done


;***********************************************************************
; For 66-bit factors and above (up to 90 bits more or less).
;***********************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp66:	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	rdx, 1			; Compute 1 / factor for initial
	shl	rdx, 63			; estimate in Newton's method
	sub	rax, rax
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	shld	rbx, r8, cl		; Form high 64-bits of factor
	inc	rbx			; ceiling (high 64-bits of factor)
	div	rbx
	dec	rbx
	shr	rbx, cl			; Restore factor
	mov	rcx, r8
	mov	facinv3, rax
svlp66:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf66:	bsf	rdx, rax		; Look for a set bit
	jnz	test66			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rbx, r14		; Jump if overflow
	jae	short oflow66
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp66		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, rbx
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow66:and	rdi, rdi		; Are there untested factors?
	jnz	short rem66		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done
rem66:	mov	r8, fac1		; Copy first trial factor
	mov	r9, fac1hi
	mov	fac1[rdi*8], r8
	mov	fac1hi[rdi*8], r9
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	short rem66		; No, go copy another
	jmp	short do66		; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test66:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	short oflow66		; Jump if overflow
	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9
	inc	rdi			; One more factor queued up
	cmp	rdi, 3			; Have enough been queued up?
	jne	bsf66			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

do66:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp
	mov	SAVED_REG6, r14

; Precompute 1 / factor using Newton's method and the last 1 / factor
; as our initial estimate.  I think this gives us about 50-ish digits
; of precision which is enough for our needs.   Note we round up several
; of the calculations so that the computed 1 / factor is less than the
; actual 1 / factor.

	mov	rax, facinv3		; Load last 1 / factor
	mul	rax
	lea	temp1, [rdx+1]		; Save ceiling (est^2)

	mov	facinv1, facinv3	; Copy last 1 / factor
	mov	facinv2, facinv3

	mov	rcx, shift_count
dec	rcx

	mov	rax, fac1hi		; Form upper 64 bits of factor
	mov	rdx, fac1
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv1, rdx		; est - f * est^2

	mov	rax, fac2hi		; Form upper 64 bits of factor
	mov	rdx, fac2
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv2, rdx		; est - f * est^2

	mov	rax, fac3hi		; Form upper 64 bits of factor
	mov	rdx, fac3
	shld	rax, rdx, cl
	inc	rax			; ceiling (upper 64 bits of factor)
	mul	temp1
	inc	rdx			; ceiling (f * est^2)
	sub	facinv3, rdx		; est - f * est^2

	add	facinv1, facinv1	; 1/f = 2 (est - f * est^2)
	shl	facinv2, 1		; 1/f = 2 (est - f * est^2)
	add	facinv3, facinv3	; 1/f = 2 (est - f * est^2)

;
; Perform a division on the initial value to get started.
;

	mov	rcx, initshift		; Load initial shifted count

	and	rcx, rcx		; If quotient will be small,
	jns	short fast66		; jump to go compute it.

	sub	rem1hi, rem1hi		; Load initial value
	sub	rem1lo, rem1lo
	sub	rem2hi, rem2hi
	sub	rem2lo, rem2lo
	sub	rem3hi, rem3hi
	sub	rem3lo, rem3lo

	mov	rcx, initshift2		; Compute first quotients
	mov	temp1, facinv1
	shr	temp1, cl
	mov	temp2, facinv2
	shr	temp2, cl
	mov	temp3, facinv3
	shr	temp3, cl

	mov	rcx, shifter		; Load shifter
	shr	rcx, 1
	mov	memshifter, rcx		; Save shifter
	mov	rcx, shift66
	jmp	slow66			; Jump into middle of squaring loop

fast66:	mov	rem1hi, initval1	; Load initial value
	sub	rem1lo, rem1lo
	mov	rem2hi, rem1hi
	sub	rem2lo, rem2lo
	mov	rem3hi, rem1hi
	sub	rem3lo, rem3lo

	mov	rax, facinv1		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp1, fac1hi		; Subtract quotient * factor_hi
	imul	temp1, rax
	sub	rem1hi, temp1
	mul	fac1			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from initval
	sbb	rem1hi, rdx
assert	jns

	mov	rax, facinv2		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp2, fac2hi		; Subtract quotient * factor_hi
	imul	temp2, rax
	sub	rem2hi, temp2
	mul	fac2			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from initval
	sbb	rem2hi, rdx
assert	jns

	mov	rax, facinv3		; Quotient = val * 1 / factor
	shr	rax, cl
	mov	temp3, fac3hi		; Subtract quotient * factor_hi
	imul	temp3, rax
	sub	rem3hi, temp3
	mul	fac3			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from initval
	sbb	rem3hi, rdx
assert	jns

;
; Square remainders and get new remainders
;

	mov	rcx, shifter		; Load shifter
	mov	memshifter, rcx		; Save shifter
	mov	rcx, shift66
sqlp66:	mov	temp1, rem1hi		; Load remainder_hi
	imul	temp1, temp1		; Square remainder_hi

	mov	temp2, rem2hi		; Load remainder_hi
	imul	temp2, temp2		; Square remainder_hi

	mov	temp3, rem3hi		; Load remainder_hi
	imul	temp3, temp3		; Square remainder_hi

	add	rem1hi, rem1hi		; Double remainder_hi
	add	rem2hi, rem2hi		; Double remainder_hi
	add	rem3hi, rem3hi		; Double remainder_hi

	mov	rax, rem1lo		; Load remainder_lo
	mul	rem1lo			; Square remainder_lo
	xchg	rem1lo, rax		; Save squared remainder_lo
	xchg	rem1hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem1hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp1, rdx

	mov	rax, rem2lo		; Load remainder_lo
	mul	rem2lo			; Square remainder_lo
	xchg	rem2lo, rax		; Save squared remainder_lo
	xchg	rem2hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem2hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp2, rdx

	mov	rax, rem3lo		; Load remainder_lo
	mul	rem3lo			; Square remainder_lo
	xchg	rem3lo, rax		; Save squared remainder_lo
	xchg	rem3hi, rdx
	mul	rdx			; Calc 2 * remainder_lo * remainder_hi
	add	rem3hi, rax		; Add in dbl'ed mul'ed remainder
	adc	temp3, rdx

	shld	temp1, rem1hi, 31	; Shift for computing quotient
	shld	temp2, rem2hi, 31
	shld	temp3, rem3hi, 31

	mov	rax, facinv1		; Quotient = val * 1 / factor
	mul	temp1
	mov	temp1, rdx		; Save quotient

	mov	rax, facinv2		; Quotient = val * 1 / factor
	mul	temp2
	mov	temp2, rdx		; Save quotient

	mov	rax, facinv3		; Quotient = val * 1 / factor
	mul	temp3
	mov	temp3, rdx		; Save quotient

slow66:	ror	rcx, 8			; Use shift count in ch

	mov	rax, fac1
	mul	temp1			; Compute quotient * factor_lo
	imul	temp1, fac1hi		; Compute quotient * factor_hi
	add	rdx, temp1		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, fac2
	mul	temp2			; Compute quotient * factor_lo
	imul	temp2, fac2hi		; Compute quotient * factor_hi
	add	rdx, temp2		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, fac3
	mul	temp3			; Compute quotient * factor_lo
	imul	temp3, fac3hi		; Compute quotient * factor_hi
	add	rdx, temp3		; Add in quotient * factor_hi
	shld	rdx, rax, cl
	shl	rax, cl
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

	rol	rcx, 8			; Restore shift count

	mov	rax, rem1hi		; Quotient = val * 1 / factor
	mul	facinv1
	shr	rdx, cl
	mov	temp1, fac1hi		; Compute quotient * factor_hi
	imul	temp1, rdx
	sub	rem1hi, temp1		; Subtract quotient * factor_hi
	mov	rax, fac1
	mul	rdx			; Compute quotient * factor_lo
	sub	rem1lo, rax		; Subtract from squared remainder
	sbb	rem1hi, rdx
assert	jns

	mov	rax, rem2hi		; Quotient = val * 1 / factor
	mul	facinv2
	shr	rdx, cl
	mov	temp2, fac2hi		; Compute quotient * factor_hi
	imul	temp2, rdx
	sub	rem2hi, temp2		; Subtract quotient * factor_hi
	mov	rax, fac2
	mul	rdx			; Compute quotient * factor_lo
	sub	rem2lo, rax		; Subtract from squared remainder
	sbb	rem2hi, rdx
assert	jns

	mov	rax, rem3hi		; Quotient = val * 1 / factor
	mul	facinv3
	shr	rdx, cl
	mov	temp3, fac3hi		; Compute quotient * factor_hi
	imul	temp3, rdx
	sub	rem3hi, temp3		; Subtract quotient * factor_hi
	mov	rax, fac3
	mul	rdx			; Compute quotient * factor_lo
	sub	rem3lo, rax		; Subtract from squared remainder
	sbb	rem3hi, rdx
assert	jns

;
; Multiply by two if necessary, test for end of squaring loop
;

	mov	rax, memshifter		; One squaring completed, shift
	add	rax, rax
	mov	memshifter, rax
	jnc	sqlp66			; Loop if a mul by 2 is not needed
	jz	short exit66		; Are we done squaring?
	add	rem1lo, rem1lo		; Multiply remainder by 2
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Multiply remainder by 2
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Multiply remainder by 2
	adc	rem3hi, rem3hi
	jmp	sqlp66			; Do next squaring

;
; Multiply remainder by two one last time (for the last carry out of shifter)
; If result = 1 mod factor, then we found a divisor of 2**p - 1
;

exit66:	add	rem1lo, rem1lo		; Double the remainder
	adc	rem1hi, rem1hi
	add	rem2lo, rem2lo		; Double the remainder
	adc	rem2hi, rem2hi
	add	rem3lo, rem3lo		; Double the remainder
	adc	rem3hi, rem3hi
	mov	rax, fac1		; Load factor #1
	mov	rdx, fac1hi
sub66:	sub	rem1lo, rax		; Subtract factor
	sbb	rem1hi, rdx
	jns	short sub66		; Subtract until result is negative
	add	rem1lo, rax		; Make it positive
	adc	rem1hi, rdx
	jnz	short fail66
	dec	rem1lo			; If one, its a factor
	jz	short win66
fail66:	mov	rax, fac2		; Load factor #2
	mov	rdx, fac2hi
sub66a:	sub	rem2lo, rax		; Subtract factor
	sbb	rem2hi, rdx
	jns	short sub66a		; Subtract until result is negative
	add	rem2lo, rax		; Make it positive
	adc	rem2hi, rdx
	jnz	short fail66a
	dec	rem2lo			; If one, its a factor
	jz	short win66
fail66a:mov	rax, fac3		; Load factor #3
	mov	rdx, fac3hi
sub66b:	sub	rem3lo, rax		; Subtract factor
	sbb	rem3hi, rdx
	jns	short sub66b		; Subtract until result is negative
	add	rem3lo, rax		; Make it positive
	adc	rem3hi, rdx
	jnz	short next66
	dec	rem3lo			; If one, its a factor
	jz	short win66

next66:	sub	rdi, rdi		; Clear queued factors count
	mov	r14, SAVED_REG6		; Restore sieve testing register
	mov	rbp, SAVED_REG5
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf66			; Test next factor from sieve

win66:	mov	FACLSW, eax		; Factor found!
	shr	rax, 32
	mov	FACMSW, eax
	mov	FACHSW, edx
	mov	rax, 1			; Return TRUE
	jmp	done

;***************************************************************************
; For up to 74-bit factors using SSE2, may not be faster than the code above
;***************************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp74:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
svlp74:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf74:	bsf	rdx, rax		; Look for a set bit
	jnz	test74			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rbx, r14		; Jump if overflow
	jae	short oflow74
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp74		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, rbx
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow74:and	rdi, rdi		; Are there untested factors?
	jnz	short rem74		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done
rem74:	mov	r8, QWORD PTR XMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR XMM_F2
	mov	rdx, QWORD PTR XMM_F3
	mov	QWORD PTR XMM_F1[rdi*8], r8
	mov	QWORD PTR XMM_F2[rdi*8], r9
	mov	QWORD PTR XMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_COMPARE_VAL1
	mov	r9, QWORD PTR XMM_COMPARE_VAL2
	mov	rdx, QWORD PTR XMM_COMPARE_VAL3
	mov	QWORD PTR XMM_COMPARE_VAL1[rdi*8], r8
	mov	QWORD PTR XMM_COMPARE_VAL2[rdi*8], r9
	mov	QWORD PTR XMM_COMPARE_VAL3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_INVFAC
	mov	QWORD PTR XMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 2			; Have enough been queued up?
	jne	short rem74		; No, go copy another
	jmp	do74			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test74:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	oflow74			; Jump if overflow

;
; Compute the factor to test and 63 most significant bits of 1 / factor
;

	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9

;; OPT...  old 32-bit code....  convert to divpd(in both)???

; This code didn't work because it only gives us 53-bits of precision.
; Example: 40047031,105253470443645104183 fails with this code
;	shld	r9, r8, 34
;	cvtsi2sd xmm0, r9
;	mulsd	xmm0, TWO_TO_30
;	and	r8, 3FFFFFFFh
;	cvtsi2sd xmm1, r8
;	addsd	xmm0, xmm1
;	movsd	xmm1, TWO_TO_FACSIZE_PLUS_62
;	divsd	xmm1, xmm0
;	cvtsd2si r8, xmm1
;	mov	QWORD PTR XMM_INVFAC[rdi*8], r8

	shld	r9, r8, 34
	mov	temp, r9
	fild	temp
	fmul	TWO_TO_30
	and	r8, 3FFFFFFFh
	mov	temp, r8
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR XMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_F2[rdi*8], r8d
	mov	XMM_F1[rdi*8], r9d

; Compute factor + 1 for comparing against when loop is done

;OPT....	replace this with a subtract 1 at loop's end and compare to XMM_F1/F2/F3???  subtract 1 must propgate carry too.
;OPT....	replace with SSE2 instructions that do the same thing as below
	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	inc	r8
	adc	r9, 0
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_COMPARE_VAL3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_COMPARE_VAL2[rdi*8], r8d
	mov	XMM_COMPARE_VAL1[rdi*8], r9d

	inc	rdi			; One more factor queued up
	cmp	rdi, 2			; Have enough been queued up?
	jne	bsf74			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and sse2_fac_initval code)
do74:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aqloop code except that we avoid the initial squaring.

	sse2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
loop74:	sse2_fac 74
	dec	edi			; Decrement loop counter
	jnz	loop74

; If result = factor + 1, then we found a divisor of 2**p - 1

	pcmpeqd	xmm2, XMM_COMPARE_VAL3	; See if remainder is factor + 1
	pcmpeqd	xmm1, XMM_COMPARE_VAL2
	pcmpeqd	xmm0, XMM_COMPARE_VAL1
	pand	xmm2, xmm1
	pand	xmm2, xmm0
	pmovmskb ecx, xmm2
	cmp	cl, 0FFh		; See if we matched
	je	short win74_1		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short win74_2		; Yes! Factor found
	jmp	short next74		; Test next factor from sieve
win74_1:mov	eax, XMM_F3		; Factor found!!! Return it
	mov	ebx, XMM_F2
	mov	ecx, XMM_F1
	jmp	short win74
win74_2:mov	eax, XMM_F3+8		; Factor found!!! Return it
	mov	ebx, XMM_F2+8
	mov	ecx, XMM_F1+8
win74:	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

next74:	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf74			; Test next factor from sieve

;***************************************************************************
; For 75 to 86-bit factors using SSE2, may not be faster than the code above
;***************************************************************************

;
; Check all the bits in the sieve looking for a factor to test
;

tlp86:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
svlp86:	mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
bsf86:	bsf	rdx, rax		; Look for a set bit
	jnz	test86			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rbx, r14		; Jump if overflow
	jae	short oflow86
	cmp	rsi, rbp		; End of sieve?
	jl	short svlp86		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, rbx
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

oflow86:and	rdi, rdi		; Are there untested factors?
	jnz	short rem86		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done
rem86:	mov	r8, QWORD PTR XMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR XMM_F2
	mov	rdx, QWORD PTR XMM_F3
	mov	QWORD PTR XMM_F1[rdi*8], r8
	mov	QWORD PTR XMM_F2[rdi*8], r9
	mov	QWORD PTR XMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_COMPARE_VAL1
	mov	r9, QWORD PTR XMM_COMPARE_VAL2
	mov	rdx, QWORD PTR XMM_COMPARE_VAL3
	mov	QWORD PTR XMM_COMPARE_VAL1[rdi*8], r8
	mov	QWORD PTR XMM_COMPARE_VAL2[rdi*8], r9
	mov	QWORD PTR XMM_COMPARE_VAL3[rdi*8], rdx
	mov	r8, QWORD PTR XMM_INVFAC
	mov	QWORD PTR XMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 2			; Have enough been queued up?
	jne	short rem86		; No, go copy another
	jmp	do86			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

test86:	btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	oflow86			; Jump if overflow

;
; Compute the factor to test and 63 most significant bits of 1 / factor
;
;; OPT...  old 32-bit code....  convert to divpd(in both)???

	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9

	shld	r9, r8, 34
	mov	temp, r9
	fild	temp
	fmul	TWO_TO_30
	and	r8, 3FFFFFFFh
	mov	temp, r8
	fiadd	DWORD PTR temp		; We now have the factor to test

	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR XMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_F2[rdi*8], r8d
	mov	XMM_F1[rdi*8], r9d

; Compute factor + 1 for comparing against when loop is done

;OPT....	replace this with a subtract 1 at loop's end and compare to XMM_F1/F2/F3???  subtract 1 must propgate carry too.
;OPT....	replace with SSE2 instructions that do the same thing as below
	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	inc	r8
	adc	r9, 0
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	XMM_COMPARE_VAL3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	XMM_COMPARE_VAL2[rdi*8], r8d
	mov	XMM_COMPARE_VAL1[rdi*8], r9d

	inc	rdi			; One more factor queued up
	cmp	rdi, 2			; Have enough been queued up?
	jne	bsf86			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and sse2_fac_initval code)
do86:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aqloop code except that we avoid the initial squaring.

	sse2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
loop86:	sse2_fac 86
	dec	edi			; Decrement loop counter
	jnz	loop86

; If result = factor + 1, then we found a divisor of 2**p - 1

	pcmpeqd	xmm2, XMM_COMPARE_VAL3	; See if remainder is factor + 1
	pcmpeqd	xmm1, XMM_COMPARE_VAL2
	pcmpeqd	xmm0, XMM_COMPARE_VAL1
	pand	xmm2, xmm1
	pand	xmm2, xmm0
	pmovmskb ecx, xmm2
	cmp	cl, 0FFh		; See if we matched
	je	short win86_1		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short win86_2		; Yes! Factor found
	jmp	short next86		; Test next factor from sieve
win86_1:mov	eax, XMM_F3		; Factor found!!! Return it
	mov	ebx, XMM_F2
	mov	ecx, XMM_F1
	jmp	short win86
win86_2:mov	eax, XMM_F3+8		; Factor found!!! Return it
	mov	ebx, XMM_F2+8
	mov	ecx, XMM_F1+8
win86:	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

next86:	sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	bsf86			; Test next factor from sieve


;************************************
; For up to 74-bit factors using AVX2
;************************************

;
; Check all the bits in the sieve looking for a factor to test
;

atlp74:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
	dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
asvlp74:mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
absf74:	bsf	rdx, rax		; Look for a set bit
	jnz	atest74			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rbx, r14		; Jump if overflow
	jae	short aoflow74
	cmp	rsi, rbp		; End of sieve?
	jl	short asvlp74		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, rbx
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

aoflow74:and	rdi, rdi		; Are there untested factors?
	jnz	short arem74		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done
arem74:	mov	r8, QWORD PTR YMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR YMM_F2
	mov	rdx, QWORD PTR YMM_F3
	mov	QWORD PTR YMM_F1[rdi*8], r8
	mov	QWORD PTR YMM_F2[rdi*8], r9
	mov	QWORD PTR YMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_COMPARE_VAL1
	mov	r9, QWORD PTR YMM_COMPARE_VAL2
	mov	rdx, QWORD PTR YMM_COMPARE_VAL3
	mov	QWORD PTR YMM_COMPARE_VAL1[rdi*8], r8
	mov	QWORD PTR YMM_COMPARE_VAL2[rdi*8], r9
	mov	QWORD PTR YMM_COMPARE_VAL3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_INVFAC
	mov	QWORD PTR YMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	short arem74		; No, go copy another
	jmp	ado74			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

atest74:btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	aoflow74		; Jump if overflow

;
; Compute the factor to test and 63 most significant bits of 1 / factor
;
;; OPT...  old 32-bit code....  convert to divpd(in both)???

	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9

	shld	r9, r8, 34
	mov	temp, r9
	fild	temp
	fmul	TWO_TO_30
	and	r8, 3FFFFFFFh
	mov	temp, r8
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR YMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_F2[rdi*8], r8d
	mov	YMM_F1[rdi*8], r9d

; Compute factor + 1 for comparing against when loop is done

;OPT....	replace this with a subtract 1 at loop's end and compare to YMM_F1/F2/F3???  subtract 1 must propgate carry too.
;OPT....	replace with AVX2 instructions that do the same thing as below
	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	inc	r8
	adc	r9, 0
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_COMPARE_VAL3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_COMPARE_VAL2[rdi*8], r8d
	mov	YMM_COMPARE_VAL1[rdi*8], r9d

	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	absf74			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and avx2_fac_initval code)
ado74:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aqloop code except that we avoid the initial squaring.

	avx2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
aloop74:avx2_fac 74
	dec	edi			; Decrement loop counter
	jnz	aloop74

; If result = factor + 1, then we found a divisor of 2**p - 1

	vpcmpeqd ymm2, ymm2, YMM_COMPARE_VAL3	; See if remainder is factor + 1
	vpcmpeqd ymm1, ymm1, YMM_COMPARE_VAL2
	vpcmpeqd ymm0, ymm0, YMM_COMPARE_VAL1
	vpand	ymm2, ymm2, ymm1
	vpand	ymm2, ymm2, ymm0
	vpmovmskb rcx, ymm2
	cmp	cl, 0FFh		; See if we matched
	je	short awin74_1		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short awin74_2		; Yes! Factor found
	shr	ecx, 16
	cmp	cl, 0FFh		; See if we matched
	je	short awin74_3		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short awin74_4		; Yes! Factor found
	jmp	short anext74		; Test next factor from sieve
awin74_1:mov	edx, 0			; Factor found!!! Return it
	jmp	short awin74
awin74_2:mov	edx, 8			; Factor found!!! Return it
	jmp	short awin74
awin74_3:mov	edx, 16			; Factor found!!! Return it
	jmp	short awin74
awin74_4:mov	edx, 24			; Factor found!!! Return it
awin74:	mov	eax, YMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, YMM_F2[rdx]
	mov	ecx, YMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

anext74:sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	absf74			; Test next factor from sieve

;************************************
; For 75 to 86-bit factors using AVX2
;************************************

;
; Check all the bits in the sieve looking for a factor to test
;

atlp86:	finit				; Set for 64-bit precision
	mov	rsi, sieve		; Sieve address
	lea	rbp, [rsi+sievesize]	; Sieve end address
	mov	edi, queuedcnt		; Count of queued factors to be tested
	mov	r8, rcx			; Save factor
	mov	rcx, shift_count
	dec	rcx
	mov	r14, 1			; Form trial factor limit
	ror	r14, cl
	mov	rcx, r8			; Restore factor
asvlp86:mov	rax, [rsi]		; Load word from sieve
	lea	rsi, [rsi+8]		; Bump sieve address
absf86:	bsf	rdx, rax		; Look for a set bit
	jnz	atest86			; Found one, go test the factor
	add	rcx, facdist64      	; Add facdist * 64 to the factor
	adc	rbx, 0
	cmp	rbx, r14		; Jump if overflow
	jae	short aoflow86
	cmp	rsi, rbp		; End of sieve?
	jl	short asvlp86		; Loop to test next sieve qword

; Check repetition counter

	mov	savefac1, rcx		; Save for the restart or more sieving
	mov	savefac0, rbx
	mov	queuedcnt, edi		; Save count of queued factors
	dec	reps
	jnz	initsv

; Return so caller can check for ESC

	shr	rcx, 32
	mov	FACMSW, ecx
	mov	FACHSW, ebx
	mov	rax, 2			; Return for ESC check
	jmp	done

; Handle overflow

aoflow86:and	rdi, rdi		; Are there untested factors?
	jnz	short arem86		; Yes, go do remaining trial factors
	mov	FACHSW, r14d		; Return end point
	mov	FACMSW, 0
	mov	rax, 2			; Return for ESC check
	jmp	done
arem86:	mov	r8, QWORD PTR YMM_F1	; Copy first trial factor
	mov	r9, QWORD PTR YMM_F2
	mov	rdx, QWORD PTR YMM_F3
	mov	QWORD PTR YMM_F1[rdi*8], r8
	mov	QWORD PTR YMM_F2[rdi*8], r9
	mov	QWORD PTR YMM_F3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_COMPARE_VAL1
	mov	r9, QWORD PTR YMM_COMPARE_VAL2
	mov	rdx, QWORD PTR YMM_COMPARE_VAL3
	mov	QWORD PTR YMM_COMPARE_VAL1[rdi*8], r8
	mov	QWORD PTR YMM_COMPARE_VAL2[rdi*8], r9
	mov	QWORD PTR YMM_COMPARE_VAL3[rdi*8], rdx
	mov	r8, QWORD PTR YMM_INVFAC
	mov	QWORD PTR YMM_INVFAC[rdi*8], r8
	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	short arem86		; No, go copy another
	jmp	ado86			; Yes, go test them

;
; Gather trial factors to be tested all at once to minimize
; processor stalls.
;

atest86:btr	rax, rdx		; Clear the sieve bit
	mov	r8, rcx			; Copy base factor
	mov	r9, rbx
	add	r8, facdists[rdx*8]	; Determine factor to test
	adc	r9, 0
	cmp	r9, r14			; Test for overflow
	jae	aoflow86		; Jump if overflow

;
; Compute the factor to test and 63 most significant bits of 1 / factor
;
;; OPT...  old 32-bit code....  convert to divpd(in both)???

	mov	fac1[rdi*8], r8		; Save the factor to test
	mov	fac1hi[rdi*8], r9

	shld	r9, r8, 34
	mov	temp, r9
	fild	temp
	fmul	TWO_TO_30
	and	r8, 3FFFFFFFh
	mov	temp, r8
	fiadd	DWORD PTR temp		; We now have the factor to test
	fld	TWO_TO_FACSIZE_PLUS_62	; Constant to generate 63 bit inverse
	fdivrp	st(1), st
	fistp	QWORD PTR YMM_INVFAC[rdi*8]

; Compute the factor in 30 bit chunks
;  OPT - just save r8/r9 and use sse2/avx instr to convert to 30 bit chunks ??? (If better, do it in 32-bit code too)

	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_F3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_F2[rdi*8], r8d
	mov	YMM_F1[rdi*8], r9d

; Compute factor + 1 for comparing against when loop is done

;OPT....	replace this with a subtract 1 at loop's end and compare to YMM_F1/F2/F3???  subtract 1 must propgate carry too.
;OPT....	replace with SSE2 instructions that do the same thing as below
	mov	r8, fac1[rdi*8] 		; Restore the factor to test
	mov	r9, fac1hi[rdi*8]
	inc	r8
	adc	r9, 0
	shld	r9, r8, 4
	mov	edx, 3FFFFFFFh
	and	rdx, r8
	mov	YMM_COMPARE_VAL3[rdi*8], edx
	shr	r8, 30
	and	r8, 3FFFFFFFh
	mov	YMM_COMPARE_VAL2[rdi*8], r8d
	mov	YMM_COMPARE_VAL1[rdi*8], r9d

	inc	rdi			; One more factor queued up
	cmp	rdi, 4			; Have enough been queued up?
	jne	absf86			; No, go test more sieve bits

;
; Now test the accumulated trial factors
;

;; OPT - save/restore fewer registers  (affects winner checking and avx2_fac_initval code)
ado86:	mov	SAVED_REG1, rsi		; Save sieve testing registers
	mov	SAVED_REG2, rax
	mov	SAVED_REG3, rbx
	mov	SAVED_REG4, rcx
	mov	SAVED_REG5, rbp

; Work on initval.
; This is like the aqloop code except that we avoid the initial squaring.

	avx2_fac_initval

; Square remainder and get new remainder.

	mov	edi, SSE2_LOOP_COUNTER	; Number of times to loop
aloop86:avx2_fac 86
	dec	edi			; Decrement loop counter
	jnz	aloop86

; If result = factor + 1, then we found a divisor of 2**p - 1

	vpcmpeqd ymm2, ymm2, YMM_COMPARE_VAL3	; See if remainder is factor + 1
	vpcmpeqd ymm1, ymm1, YMM_COMPARE_VAL2
	vpcmpeqd ymm0, ymm0, YMM_COMPARE_VAL1
	vpand	ymm2, ymm2, ymm1
	vpand	ymm2, ymm2, ymm0
	vpmovmskb rcx, ymm2
	cmp	cl, 0FFh		; See if we matched
	je	short awin86_1		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short awin86_2		; Yes! Factor found
	shr	ecx, 16
	cmp	cl, 0FFh		; See if we matched
	je	short awin86_3		; Yes! Factor found
	cmp	ch, 0FFh		; See if we matched
	je	short awin86_4		; Yes! Factor found
	jmp	short anext86		; Test next factor from sieve
awin86_1:mov	edx, 0			; Factor found!!! Return it
	jmp	short awin86
awin86_2:mov	edx, 8			; Factor found!!! Return it
	jmp	short awin86
awin86_3:mov	edx, 16			; Factor found!!! Return it
	jmp	short awin86
awin86_4:mov	edx, 24			; Factor found!!! Return it
awin86:	mov	eax, YMM_F3[rdx]	; Factor found!!! Return it
	mov	ebx, YMM_F2[rdx]
	mov	ecx, YMM_F1[rdx]
	shl	eax, 2
	shrd	eax, ebx, 2
	shl	ebx, 2
	shrd	ebx, ecx, 4
	shr	ecx, 4
	mov	FACLSW, eax
	mov	FACMSW, ebx
	mov	FACHSW, ecx
	mov	rax, 1			; return TRUE
	jmp	done

anext86:sub	rdi, rdi		; Clear queued factors count
	mov	rbp, SAVED_REG5		; Restore sieve testing register
	mov	rcx, SAVED_REG4
	mov	rbx, SAVED_REG3
	mov	rax, SAVED_REG2
	mov	rsi, SAVED_REG1
	jmp	absf86			; Test next factor from sieve

; Pop registers and return

done:	ad_epilog 0,0,rbx,rbp,rsi,rdi,r12,r13,r14,r15,xmm6,xmm7,xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15

factor64 ENDP

_TEXT	ENDS
END
